
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Workspace
 * 
 */
export type Workspace = $Result.DefaultSelection<Prisma.$WorkspacePayload>
/**
 * Model WorkspaceMember
 * 
 */
export type WorkspaceMember = $Result.DefaultSelection<Prisma.$WorkspaceMemberPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model Position
 * 
 */
export type Position = $Result.DefaultSelection<Prisma.$PositionPayload>
/**
 * Model PositionLevel
 * 
 */
export type PositionLevel = $Result.DefaultSelection<Prisma.$PositionLevelPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model EmploymentHistory
 * 
 */
export type EmploymentHistory = $Result.DefaultSelection<Prisma.$EmploymentHistoryPayload>
/**
 * Model EmployeeDocument
 * 
 */
export type EmployeeDocument = $Result.DefaultSelection<Prisma.$EmployeeDocumentPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectMember
 * 
 */
export type ProjectMember = $Result.DefaultSelection<Prisma.$ProjectMemberPayload>
/**
 * Model ProjectRole
 * 
 */
export type ProjectRole = $Result.DefaultSelection<Prisma.$ProjectRolePayload>
/**
 * Model LeaveType
 * 
 */
export type LeaveType = $Result.DefaultSelection<Prisma.$LeaveTypePayload>
/**
 * Model LeaveQuota
 * 
 */
export type LeaveQuota = $Result.DefaultSelection<Prisma.$LeaveQuotaPayload>
/**
 * Model Leave
 * 
 */
export type Leave = $Result.DefaultSelection<Prisma.$LeavePayload>
/**
 * Model OvertimePolicy
 * 
 */
export type OvertimePolicy = $Result.DefaultSelection<Prisma.$OvertimePolicyPayload>
/**
 * Model Overtime
 * 
 */
export type Overtime = $Result.DefaultSelection<Prisma.$OvertimePayload>
/**
 * Model ApprovalTemplate
 * 
 */
export type ApprovalTemplate = $Result.DefaultSelection<Prisma.$ApprovalTemplatePayload>
/**
 * Model ApprovalStep
 * 
 */
export type ApprovalStep = $Result.DefaultSelection<Prisma.$ApprovalStepPayload>
/**
 * Model Approval
 * 
 */
export type Approval = $Result.DefaultSelection<Prisma.$ApprovalPayload>
/**
 * Model ApprovalAction
 * 
 */
export type ApprovalAction = $Result.DefaultSelection<Prisma.$ApprovalActionPayload>
/**
 * Model Settings
 * 
 */
export type Settings = $Result.DefaultSelection<Prisma.$SettingsPayload>
/**
 * Model UserConsent
 * 
 */
export type UserConsent = $Result.DefaultSelection<Prisma.$UserConsentPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Invitation
 * 
 */
export type Invitation = $Result.DefaultSelection<Prisma.$InvitationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  SUPERADMIN: 'SUPERADMIN',
  ADMIN: 'ADMIN',
  USER: 'USER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  PENDING: 'PENDING'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const WorkspaceStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type WorkspaceStatus = (typeof WorkspaceStatus)[keyof typeof WorkspaceStatus]


export const PlanType: {
  FREE: 'FREE',
  BASIC: 'BASIC',
  PREMIUM: 'PREMIUM',
  ENTERPRISE: 'ENTERPRISE'
};

export type PlanType = (typeof PlanType)[keyof typeof PlanType]


export const MemberRole: {
  OWNER: 'OWNER',
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  MEMBER: 'MEMBER'
};

export type MemberRole = (typeof MemberRole)[keyof typeof MemberRole]


export const MemberStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  PENDING: 'PENDING'
};

export type MemberStatus = (typeof MemberStatus)[keyof typeof MemberStatus]


export const EmployeeStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  PROBATION: 'PROBATION',
  TERMINATED: 'TERMINATED',
  RESIGNED: 'RESIGNED',
  PENDING: 'PENDING'
};

export type EmployeeStatus = (typeof EmployeeStatus)[keyof typeof EmployeeStatus]


export const EmploymentType: {
  FULL_TIME: 'FULL_TIME',
  PART_TIME: 'PART_TIME',
  CONTRACT: 'CONTRACT',
  INTERN: 'INTERN',
  FREELANCE: 'FREELANCE'
};

export type EmploymentType = (typeof EmploymentType)[keyof typeof EmploymentType]


export const ProjectStatus: {
  PLANNING: 'PLANNING',
  IN_PROGRESS: 'IN_PROGRESS',
  ON_HOLD: 'ON_HOLD',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const ProjectPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type ProjectPriority = (typeof ProjectPriority)[keyof typeof ProjectPriority]


export const LeaveStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type LeaveStatus = (typeof LeaveStatus)[keyof typeof LeaveStatus]


export const OvertimeStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type OvertimeStatus = (typeof OvertimeStatus)[keyof typeof OvertimeStatus]


export const ApproverType: {
  DIRECT_MANAGER: 'DIRECT_MANAGER',
  DEPARTMENT_HEAD: 'DEPARTMENT_HEAD',
  SPECIFIC_USER: 'SPECIFIC_USER',
  POSITION: 'POSITION',
  ROLE: 'ROLE'
};

export type ApproverType = (typeof ApproverType)[keyof typeof ApproverType]


export const ApprovalStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type ApprovalStatus = (typeof ApprovalStatus)[keyof typeof ApprovalStatus]


export const InvitationType: {
  EMPLOYEE: 'EMPLOYEE',
  EMPLOYEE_NEW: 'EMPLOYEE_NEW',
  WORKSPACE: 'WORKSPACE'
};

export type InvitationType = (typeof InvitationType)[keyof typeof InvitationType]


export const InvitationStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED'
};

export type InvitationStatus = (typeof InvitationStatus)[keyof typeof InvitationStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type WorkspaceStatus = $Enums.WorkspaceStatus

export const WorkspaceStatus: typeof $Enums.WorkspaceStatus

export type PlanType = $Enums.PlanType

export const PlanType: typeof $Enums.PlanType

export type MemberRole = $Enums.MemberRole

export const MemberRole: typeof $Enums.MemberRole

export type MemberStatus = $Enums.MemberStatus

export const MemberStatus: typeof $Enums.MemberStatus

export type EmployeeStatus = $Enums.EmployeeStatus

export const EmployeeStatus: typeof $Enums.EmployeeStatus

export type EmploymentType = $Enums.EmploymentType

export const EmploymentType: typeof $Enums.EmploymentType

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type ProjectPriority = $Enums.ProjectPriority

export const ProjectPriority: typeof $Enums.ProjectPriority

export type LeaveStatus = $Enums.LeaveStatus

export const LeaveStatus: typeof $Enums.LeaveStatus

export type OvertimeStatus = $Enums.OvertimeStatus

export const OvertimeStatus: typeof $Enums.OvertimeStatus

export type ApproverType = $Enums.ApproverType

export const ApproverType: typeof $Enums.ApproverType

export type ApprovalStatus = $Enums.ApprovalStatus

export const ApprovalStatus: typeof $Enums.ApprovalStatus

export type InvitationType = $Enums.InvitationType

export const InvitationType: typeof $Enums.InvitationType

export type InvitationStatus = $Enums.InvitationStatus

export const InvitationStatus: typeof $Enums.InvitationStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspace`: Exposes CRUD operations for the **Workspace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workspaces
    * const workspaces = await prisma.workspace.findMany()
    * ```
    */
  get workspace(): Prisma.WorkspaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workspaceMember`: Exposes CRUD operations for the **WorkspaceMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkspaceMembers
    * const workspaceMembers = await prisma.workspaceMember.findMany()
    * ```
    */
  get workspaceMember(): Prisma.WorkspaceMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.position`: Exposes CRUD operations for the **Position** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Positions
    * const positions = await prisma.position.findMany()
    * ```
    */
  get position(): Prisma.PositionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.positionLevel`: Exposes CRUD operations for the **PositionLevel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PositionLevels
    * const positionLevels = await prisma.positionLevel.findMany()
    * ```
    */
  get positionLevel(): Prisma.PositionLevelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employmentHistory`: Exposes CRUD operations for the **EmploymentHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmploymentHistories
    * const employmentHistories = await prisma.employmentHistory.findMany()
    * ```
    */
  get employmentHistory(): Prisma.EmploymentHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeDocument`: Exposes CRUD operations for the **EmployeeDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeDocuments
    * const employeeDocuments = await prisma.employeeDocument.findMany()
    * ```
    */
  get employeeDocument(): Prisma.EmployeeDocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectMember`: Exposes CRUD operations for the **ProjectMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMembers
    * const projectMembers = await prisma.projectMember.findMany()
    * ```
    */
  get projectMember(): Prisma.ProjectMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectRole`: Exposes CRUD operations for the **ProjectRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectRoles
    * const projectRoles = await prisma.projectRole.findMany()
    * ```
    */
  get projectRole(): Prisma.ProjectRoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaveType`: Exposes CRUD operations for the **LeaveType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveTypes
    * const leaveTypes = await prisma.leaveType.findMany()
    * ```
    */
  get leaveType(): Prisma.LeaveTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leaveQuota`: Exposes CRUD operations for the **LeaveQuota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveQuotas
    * const leaveQuotas = await prisma.leaveQuota.findMany()
    * ```
    */
  get leaveQuota(): Prisma.LeaveQuotaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.leave`: Exposes CRUD operations for the **Leave** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaves
    * const leaves = await prisma.leave.findMany()
    * ```
    */
  get leave(): Prisma.LeaveDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.overtimePolicy`: Exposes CRUD operations for the **OvertimePolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OvertimePolicies
    * const overtimePolicies = await prisma.overtimePolicy.findMany()
    * ```
    */
  get overtimePolicy(): Prisma.OvertimePolicyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.overtime`: Exposes CRUD operations for the **Overtime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Overtimes
    * const overtimes = await prisma.overtime.findMany()
    * ```
    */
  get overtime(): Prisma.OvertimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.approvalTemplate`: Exposes CRUD operations for the **ApprovalTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApprovalTemplates
    * const approvalTemplates = await prisma.approvalTemplate.findMany()
    * ```
    */
  get approvalTemplate(): Prisma.ApprovalTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.approvalStep`: Exposes CRUD operations for the **ApprovalStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApprovalSteps
    * const approvalSteps = await prisma.approvalStep.findMany()
    * ```
    */
  get approvalStep(): Prisma.ApprovalStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.approval`: Exposes CRUD operations for the **Approval** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Approvals
    * const approvals = await prisma.approval.findMany()
    * ```
    */
  get approval(): Prisma.ApprovalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.approvalAction`: Exposes CRUD operations for the **ApprovalAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApprovalActions
    * const approvalActions = await prisma.approvalAction.findMany()
    * ```
    */
  get approvalAction(): Prisma.ApprovalActionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **Settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.SettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userConsent`: Exposes CRUD operations for the **UserConsent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserConsents
    * const userConsents = await prisma.userConsent.findMany()
    * ```
    */
  get userConsent(): Prisma.UserConsentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitation`: Exposes CRUD operations for the **Invitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitation.findMany()
    * ```
    */
  get invitation(): Prisma.InvitationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    User: 'User',
    Workspace: 'Workspace',
    WorkspaceMember: 'WorkspaceMember',
    Department: 'Department',
    Team: 'Team',
    Position: 'Position',
    PositionLevel: 'PositionLevel',
    Employee: 'Employee',
    EmploymentHistory: 'EmploymentHistory',
    EmployeeDocument: 'EmployeeDocument',
    Project: 'Project',
    ProjectMember: 'ProjectMember',
    ProjectRole: 'ProjectRole',
    LeaveType: 'LeaveType',
    LeaveQuota: 'LeaveQuota',
    Leave: 'Leave',
    OvertimePolicy: 'OvertimePolicy',
    Overtime: 'Overtime',
    ApprovalTemplate: 'ApprovalTemplate',
    ApprovalStep: 'ApprovalStep',
    Approval: 'Approval',
    ApprovalAction: 'ApprovalAction',
    Settings: 'Settings',
    UserConsent: 'UserConsent',
    ActivityLog: 'ActivityLog',
    AuditLog: 'AuditLog',
    Invitation: 'Invitation'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account" | "session" | "verificationToken" | "user" | "workspace" | "workspaceMember" | "department" | "team" | "position" | "positionLevel" | "employee" | "employmentHistory" | "employeeDocument" | "project" | "projectMember" | "projectRole" | "leaveType" | "leaveQuota" | "leave" | "overtimePolicy" | "overtime" | "approvalTemplate" | "approvalStep" | "approval" | "approvalAction" | "settings" | "userConsent" | "activityLog" | "auditLog" | "invitation"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Workspace: {
        payload: Prisma.$WorkspacePayload<ExtArgs>
        fields: Prisma.WorkspaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findFirst: {
            args: Prisma.WorkspaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findMany: {
            args: Prisma.WorkspaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          create: {
            args: Prisma.WorkspaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          createMany: {
            args: Prisma.WorkspaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          delete: {
            args: Prisma.WorkspaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          update: {
            args: Prisma.WorkspaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          aggregate: {
            args: Prisma.WorkspaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspace>
          }
          groupBy: {
            args: Prisma.WorkspaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceCountAggregateOutputType> | number
          }
        }
      }
      WorkspaceMember: {
        payload: Prisma.$WorkspaceMemberPayload<ExtArgs>
        fields: Prisma.WorkspaceMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          findFirst: {
            args: Prisma.WorkspaceMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          findMany: {
            args: Prisma.WorkspaceMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>[]
          }
          create: {
            args: Prisma.WorkspaceMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          createMany: {
            args: Prisma.WorkspaceMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>[]
          }
          delete: {
            args: Prisma.WorkspaceMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          update: {
            args: Prisma.WorkspaceMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspaceMemberPayload>
          }
          aggregate: {
            args: Prisma.WorkspaceMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspaceMember>
          }
          groupBy: {
            args: Prisma.WorkspaceMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceMemberCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceMemberCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      Position: {
        payload: Prisma.$PositionPayload<ExtArgs>
        fields: Prisma.PositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          findFirst: {
            args: Prisma.PositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          findMany: {
            args: Prisma.PositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          create: {
            args: Prisma.PositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          createMany: {
            args: Prisma.PositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PositionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          delete: {
            args: Prisma.PositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          update: {
            args: Prisma.PositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          deleteMany: {
            args: Prisma.PositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PositionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>[]
          }
          upsert: {
            args: Prisma.PositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionPayload>
          }
          aggregate: {
            args: Prisma.PositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosition>
          }
          groupBy: {
            args: Prisma.PositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PositionCountArgs<ExtArgs>
            result: $Utils.Optional<PositionCountAggregateOutputType> | number
          }
        }
      }
      PositionLevel: {
        payload: Prisma.$PositionLevelPayload<ExtArgs>
        fields: Prisma.PositionLevelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PositionLevelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionLevelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PositionLevelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionLevelPayload>
          }
          findFirst: {
            args: Prisma.PositionLevelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionLevelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PositionLevelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionLevelPayload>
          }
          findMany: {
            args: Prisma.PositionLevelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionLevelPayload>[]
          }
          create: {
            args: Prisma.PositionLevelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionLevelPayload>
          }
          createMany: {
            args: Prisma.PositionLevelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PositionLevelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionLevelPayload>[]
          }
          delete: {
            args: Prisma.PositionLevelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionLevelPayload>
          }
          update: {
            args: Prisma.PositionLevelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionLevelPayload>
          }
          deleteMany: {
            args: Prisma.PositionLevelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PositionLevelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PositionLevelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionLevelPayload>[]
          }
          upsert: {
            args: Prisma.PositionLevelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PositionLevelPayload>
          }
          aggregate: {
            args: Prisma.PositionLevelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePositionLevel>
          }
          groupBy: {
            args: Prisma.PositionLevelGroupByArgs<ExtArgs>
            result: $Utils.Optional<PositionLevelGroupByOutputType>[]
          }
          count: {
            args: Prisma.PositionLevelCountArgs<ExtArgs>
            result: $Utils.Optional<PositionLevelCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      EmploymentHistory: {
        payload: Prisma.$EmploymentHistoryPayload<ExtArgs>
        fields: Prisma.EmploymentHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmploymentHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmploymentHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentHistoryPayload>
          }
          findFirst: {
            args: Prisma.EmploymentHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmploymentHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentHistoryPayload>
          }
          findMany: {
            args: Prisma.EmploymentHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentHistoryPayload>[]
          }
          create: {
            args: Prisma.EmploymentHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentHistoryPayload>
          }
          createMany: {
            args: Prisma.EmploymentHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmploymentHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentHistoryPayload>[]
          }
          delete: {
            args: Prisma.EmploymentHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentHistoryPayload>
          }
          update: {
            args: Prisma.EmploymentHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentHistoryPayload>
          }
          deleteMany: {
            args: Prisma.EmploymentHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmploymentHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmploymentHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentHistoryPayload>[]
          }
          upsert: {
            args: Prisma.EmploymentHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentHistoryPayload>
          }
          aggregate: {
            args: Prisma.EmploymentHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmploymentHistory>
          }
          groupBy: {
            args: Prisma.EmploymentHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmploymentHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmploymentHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<EmploymentHistoryCountAggregateOutputType> | number
          }
        }
      }
      EmployeeDocument: {
        payload: Prisma.$EmployeeDocumentPayload<ExtArgs>
        fields: Prisma.EmployeeDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>
          }
          findFirst: {
            args: Prisma.EmployeeDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>
          }
          findMany: {
            args: Prisma.EmployeeDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>[]
          }
          create: {
            args: Prisma.EmployeeDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>
          }
          createMany: {
            args: Prisma.EmployeeDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>[]
          }
          delete: {
            args: Prisma.EmployeeDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>
          }
          update: {
            args: Prisma.EmployeeDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeDocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>[]
          }
          upsert: {
            args: Prisma.EmployeeDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDocumentPayload>
          }
          aggregate: {
            args: Prisma.EmployeeDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeDocument>
          }
          groupBy: {
            args: Prisma.EmployeeDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeDocumentCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectMember: {
        payload: Prisma.$ProjectMemberPayload<ExtArgs>
        fields: Prisma.ProjectMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findFirst: {
            args: Prisma.ProjectMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          findMany: {
            args: Prisma.ProjectMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          create: {
            args: Prisma.ProjectMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          createMany: {
            args: Prisma.ProjectMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          delete: {
            args: Prisma.ProjectMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          update: {
            args: Prisma.ProjectMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>[]
          }
          upsert: {
            args: Prisma.ProjectMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMemberPayload>
          }
          aggregate: {
            args: Prisma.ProjectMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMember>
          }
          groupBy: {
            args: Prisma.ProjectMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMemberCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMemberCountAggregateOutputType> | number
          }
        }
      }
      ProjectRole: {
        payload: Prisma.$ProjectRolePayload<ExtArgs>
        fields: Prisma.ProjectRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>
          }
          findFirst: {
            args: Prisma.ProjectRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>
          }
          findMany: {
            args: Prisma.ProjectRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>[]
          }
          create: {
            args: Prisma.ProjectRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>
          }
          createMany: {
            args: Prisma.ProjectRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectRoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>[]
          }
          delete: {
            args: Prisma.ProjectRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>
          }
          update: {
            args: Prisma.ProjectRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>
          }
          deleteMany: {
            args: Prisma.ProjectRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectRoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>[]
          }
          upsert: {
            args: Prisma.ProjectRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectRolePayload>
          }
          aggregate: {
            args: Prisma.ProjectRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectRole>
          }
          groupBy: {
            args: Prisma.ProjectRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectRoleCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectRoleCountAggregateOutputType> | number
          }
        }
      }
      LeaveType: {
        payload: Prisma.$LeaveTypePayload<ExtArgs>
        fields: Prisma.LeaveTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          findFirst: {
            args: Prisma.LeaveTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          findMany: {
            args: Prisma.LeaveTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>[]
          }
          create: {
            args: Prisma.LeaveTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          createMany: {
            args: Prisma.LeaveTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>[]
          }
          delete: {
            args: Prisma.LeaveTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          update: {
            args: Prisma.LeaveTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          deleteMany: {
            args: Prisma.LeaveTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaveTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>[]
          }
          upsert: {
            args: Prisma.LeaveTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveTypePayload>
          }
          aggregate: {
            args: Prisma.LeaveTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveType>
          }
          groupBy: {
            args: Prisma.LeaveTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveTypeCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveTypeCountAggregateOutputType> | number
          }
        }
      }
      LeaveQuota: {
        payload: Prisma.$LeaveQuotaPayload<ExtArgs>
        fields: Prisma.LeaveQuotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveQuotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveQuotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveQuotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveQuotaPayload>
          }
          findFirst: {
            args: Prisma.LeaveQuotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveQuotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveQuotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveQuotaPayload>
          }
          findMany: {
            args: Prisma.LeaveQuotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveQuotaPayload>[]
          }
          create: {
            args: Prisma.LeaveQuotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveQuotaPayload>
          }
          createMany: {
            args: Prisma.LeaveQuotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveQuotaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveQuotaPayload>[]
          }
          delete: {
            args: Prisma.LeaveQuotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveQuotaPayload>
          }
          update: {
            args: Prisma.LeaveQuotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveQuotaPayload>
          }
          deleteMany: {
            args: Prisma.LeaveQuotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveQuotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaveQuotaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveQuotaPayload>[]
          }
          upsert: {
            args: Prisma.LeaveQuotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveQuotaPayload>
          }
          aggregate: {
            args: Prisma.LeaveQuotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveQuota>
          }
          groupBy: {
            args: Prisma.LeaveQuotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveQuotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveQuotaCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveQuotaCountAggregateOutputType> | number
          }
        }
      }
      Leave: {
        payload: Prisma.$LeavePayload<ExtArgs>
        fields: Prisma.LeaveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findFirst: {
            args: Prisma.LeaveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findMany: {
            args: Prisma.LeaveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          create: {
            args: Prisma.LeaveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          createMany: {
            args: Prisma.LeaveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          delete: {
            args: Prisma.LeaveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          update: {
            args: Prisma.LeaveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          deleteMany: {
            args: Prisma.LeaveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeaveUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          upsert: {
            args: Prisma.LeaveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          aggregate: {
            args: Prisma.LeaveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeave>
          }
          groupBy: {
            args: Prisma.LeaveGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveCountAggregateOutputType> | number
          }
        }
      }
      OvertimePolicy: {
        payload: Prisma.$OvertimePolicyPayload<ExtArgs>
        fields: Prisma.OvertimePolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OvertimePolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OvertimePolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePolicyPayload>
          }
          findFirst: {
            args: Prisma.OvertimePolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OvertimePolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePolicyPayload>
          }
          findMany: {
            args: Prisma.OvertimePolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePolicyPayload>[]
          }
          create: {
            args: Prisma.OvertimePolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePolicyPayload>
          }
          createMany: {
            args: Prisma.OvertimePolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OvertimePolicyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePolicyPayload>[]
          }
          delete: {
            args: Prisma.OvertimePolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePolicyPayload>
          }
          update: {
            args: Prisma.OvertimePolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePolicyPayload>
          }
          deleteMany: {
            args: Prisma.OvertimePolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OvertimePolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OvertimePolicyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePolicyPayload>[]
          }
          upsert: {
            args: Prisma.OvertimePolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePolicyPayload>
          }
          aggregate: {
            args: Prisma.OvertimePolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOvertimePolicy>
          }
          groupBy: {
            args: Prisma.OvertimePolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<OvertimePolicyGroupByOutputType>[]
          }
          count: {
            args: Prisma.OvertimePolicyCountArgs<ExtArgs>
            result: $Utils.Optional<OvertimePolicyCountAggregateOutputType> | number
          }
        }
      }
      Overtime: {
        payload: Prisma.$OvertimePayload<ExtArgs>
        fields: Prisma.OvertimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OvertimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OvertimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          findFirst: {
            args: Prisma.OvertimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OvertimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          findMany: {
            args: Prisma.OvertimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>[]
          }
          create: {
            args: Prisma.OvertimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          createMany: {
            args: Prisma.OvertimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OvertimeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>[]
          }
          delete: {
            args: Prisma.OvertimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          update: {
            args: Prisma.OvertimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          deleteMany: {
            args: Prisma.OvertimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OvertimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OvertimeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>[]
          }
          upsert: {
            args: Prisma.OvertimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OvertimePayload>
          }
          aggregate: {
            args: Prisma.OvertimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOvertime>
          }
          groupBy: {
            args: Prisma.OvertimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<OvertimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.OvertimeCountArgs<ExtArgs>
            result: $Utils.Optional<OvertimeCountAggregateOutputType> | number
          }
        }
      }
      ApprovalTemplate: {
        payload: Prisma.$ApprovalTemplatePayload<ExtArgs>
        fields: Prisma.ApprovalTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTemplatePayload>
          }
          findFirst: {
            args: Prisma.ApprovalTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTemplatePayload>
          }
          findMany: {
            args: Prisma.ApprovalTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTemplatePayload>[]
          }
          create: {
            args: Prisma.ApprovalTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTemplatePayload>
          }
          createMany: {
            args: Prisma.ApprovalTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTemplatePayload>[]
          }
          delete: {
            args: Prisma.ApprovalTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTemplatePayload>
          }
          update: {
            args: Prisma.ApprovalTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTemplatePayload>
          }
          deleteMany: {
            args: Prisma.ApprovalTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApprovalTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTemplatePayload>[]
          }
          upsert: {
            args: Prisma.ApprovalTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalTemplatePayload>
          }
          aggregate: {
            args: Prisma.ApprovalTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApprovalTemplate>
          }
          groupBy: {
            args: Prisma.ApprovalTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalTemplateCountAggregateOutputType> | number
          }
        }
      }
      ApprovalStep: {
        payload: Prisma.$ApprovalStepPayload<ExtArgs>
        fields: Prisma.ApprovalStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload>
          }
          findFirst: {
            args: Prisma.ApprovalStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload>
          }
          findMany: {
            args: Prisma.ApprovalStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload>[]
          }
          create: {
            args: Prisma.ApprovalStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload>
          }
          createMany: {
            args: Prisma.ApprovalStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload>[]
          }
          delete: {
            args: Prisma.ApprovalStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload>
          }
          update: {
            args: Prisma.ApprovalStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload>
          }
          deleteMany: {
            args: Prisma.ApprovalStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApprovalStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload>[]
          }
          upsert: {
            args: Prisma.ApprovalStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalStepPayload>
          }
          aggregate: {
            args: Prisma.ApprovalStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApprovalStep>
          }
          groupBy: {
            args: Prisma.ApprovalStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalStepCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalStepCountAggregateOutputType> | number
          }
        }
      }
      Approval: {
        payload: Prisma.$ApprovalPayload<ExtArgs>
        fields: Prisma.ApprovalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          findFirst: {
            args: Prisma.ApprovalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          findMany: {
            args: Prisma.ApprovalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>[]
          }
          create: {
            args: Prisma.ApprovalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          createMany: {
            args: Prisma.ApprovalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>[]
          }
          delete: {
            args: Prisma.ApprovalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          update: {
            args: Prisma.ApprovalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          deleteMany: {
            args: Prisma.ApprovalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApprovalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>[]
          }
          upsert: {
            args: Prisma.ApprovalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalPayload>
          }
          aggregate: {
            args: Prisma.ApprovalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApproval>
          }
          groupBy: {
            args: Prisma.ApprovalGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalCountAggregateOutputType> | number
          }
        }
      }
      ApprovalAction: {
        payload: Prisma.$ApprovalActionPayload<ExtArgs>
        fields: Prisma.ApprovalActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApprovalActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApprovalActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload>
          }
          findFirst: {
            args: Prisma.ApprovalActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApprovalActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload>
          }
          findMany: {
            args: Prisma.ApprovalActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload>[]
          }
          create: {
            args: Prisma.ApprovalActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload>
          }
          createMany: {
            args: Prisma.ApprovalActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApprovalActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload>[]
          }
          delete: {
            args: Prisma.ApprovalActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload>
          }
          update: {
            args: Prisma.ApprovalActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload>
          }
          deleteMany: {
            args: Prisma.ApprovalActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApprovalActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApprovalActionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload>[]
          }
          upsert: {
            args: Prisma.ApprovalActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApprovalActionPayload>
          }
          aggregate: {
            args: Prisma.ApprovalActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApprovalAction>
          }
          groupBy: {
            args: Prisma.ApprovalActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApprovalActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApprovalActionCountArgs<ExtArgs>
            result: $Utils.Optional<ApprovalActionCountAggregateOutputType> | number
          }
        }
      }
      Settings: {
        payload: Prisma.$SettingsPayload<ExtArgs>
        fields: Prisma.SettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findFirst: {
            args: Prisma.SettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          findMany: {
            args: Prisma.SettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          create: {
            args: Prisma.SettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          createMany: {
            args: Prisma.SettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          delete: {
            args: Prisma.SettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          update: {
            args: Prisma.SettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          deleteMany: {
            args: Prisma.SettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>[]
          }
          upsert: {
            args: Prisma.SettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingsPayload>
          }
          aggregate: {
            args: Prisma.SettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSettings>
          }
          groupBy: {
            args: Prisma.SettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SettingsCountAggregateOutputType> | number
          }
        }
      }
      UserConsent: {
        payload: Prisma.$UserConsentPayload<ExtArgs>
        fields: Prisma.UserConsentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserConsentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserConsentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          findFirst: {
            args: Prisma.UserConsentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserConsentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          findMany: {
            args: Prisma.UserConsentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>[]
          }
          create: {
            args: Prisma.UserConsentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          createMany: {
            args: Prisma.UserConsentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserConsentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>[]
          }
          delete: {
            args: Prisma.UserConsentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          update: {
            args: Prisma.UserConsentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          deleteMany: {
            args: Prisma.UserConsentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserConsentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserConsentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>[]
          }
          upsert: {
            args: Prisma.UserConsentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserConsentPayload>
          }
          aggregate: {
            args: Prisma.UserConsentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserConsent>
          }
          groupBy: {
            args: Prisma.UserConsentGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserConsentGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserConsentCountArgs<ExtArgs>
            result: $Utils.Optional<UserConsentCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Invitation: {
        payload: Prisma.$InvitationPayload<ExtArgs>
        fields: Prisma.InvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findFirst: {
            args: Prisma.InvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findMany: {
            args: Prisma.InvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          create: {
            args: Prisma.InvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          createMany: {
            args: Prisma.InvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          delete: {
            args: Prisma.InvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          update: {
            args: Prisma.InvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          deleteMany: {
            args: Prisma.InvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          upsert: {
            args: Prisma.InvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          aggregate: {
            args: Prisma.InvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitation>
          }
          groupBy: {
            args: Prisma.InvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    user?: UserOmit
    workspace?: WorkspaceOmit
    workspaceMember?: WorkspaceMemberOmit
    department?: DepartmentOmit
    team?: TeamOmit
    position?: PositionOmit
    positionLevel?: PositionLevelOmit
    employee?: EmployeeOmit
    employmentHistory?: EmploymentHistoryOmit
    employeeDocument?: EmployeeDocumentOmit
    project?: ProjectOmit
    projectMember?: ProjectMemberOmit
    projectRole?: ProjectRoleOmit
    leaveType?: LeaveTypeOmit
    leaveQuota?: LeaveQuotaOmit
    leave?: LeaveOmit
    overtimePolicy?: OvertimePolicyOmit
    overtime?: OvertimeOmit
    approvalTemplate?: ApprovalTemplateOmit
    approvalStep?: ApprovalStepOmit
    approval?: ApprovalOmit
    approvalAction?: ApprovalActionOmit
    settings?: SettingsOmit
    userConsent?: UserConsentOmit
    activityLog?: ActivityLogOmit
    auditLog?: AuditLogOmit
    invitation?: InvitationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    activityLogs: number
    workspaceMember: number
    approvalActions: number
    consents: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    activityLogs?: boolean | UserCountOutputTypeCountActivityLogsArgs
    workspaceMember?: boolean | UserCountOutputTypeCountWorkspaceMemberArgs
    approvalActions?: boolean | UserCountOutputTypeCountApprovalActionsArgs
    consents?: boolean | UserCountOutputTypeCountConsentsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkspaceMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovalActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalActionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConsentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserConsentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type WorkspaceCountOutputType
   */

  export type WorkspaceCountOutputType = {
    members: number
    departments: number
    teams: number
    positions: number
    positionLevels: number
    employees: number
    projects: number
    projectRoles: number
    leaveTypes: number
    leaveQuotas: number
    leaves: number
    overtimePolicies: number
    overtimes: number
    approvalTemplates: number
    approvals: number
    settings: number
    auditLogs: number
    invitations: number
  }

  export type WorkspaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | WorkspaceCountOutputTypeCountMembersArgs
    departments?: boolean | WorkspaceCountOutputTypeCountDepartmentsArgs
    teams?: boolean | WorkspaceCountOutputTypeCountTeamsArgs
    positions?: boolean | WorkspaceCountOutputTypeCountPositionsArgs
    positionLevels?: boolean | WorkspaceCountOutputTypeCountPositionLevelsArgs
    employees?: boolean | WorkspaceCountOutputTypeCountEmployeesArgs
    projects?: boolean | WorkspaceCountOutputTypeCountProjectsArgs
    projectRoles?: boolean | WorkspaceCountOutputTypeCountProjectRolesArgs
    leaveTypes?: boolean | WorkspaceCountOutputTypeCountLeaveTypesArgs
    leaveQuotas?: boolean | WorkspaceCountOutputTypeCountLeaveQuotasArgs
    leaves?: boolean | WorkspaceCountOutputTypeCountLeavesArgs
    overtimePolicies?: boolean | WorkspaceCountOutputTypeCountOvertimePoliciesArgs
    overtimes?: boolean | WorkspaceCountOutputTypeCountOvertimesArgs
    approvalTemplates?: boolean | WorkspaceCountOutputTypeCountApprovalTemplatesArgs
    approvals?: boolean | WorkspaceCountOutputTypeCountApprovalsArgs
    settings?: boolean | WorkspaceCountOutputTypeCountSettingsArgs
    auditLogs?: boolean | WorkspaceCountOutputTypeCountAuditLogsArgs
    invitations?: boolean | WorkspaceCountOutputTypeCountInvitationsArgs
  }

  // Custom InputTypes
  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceCountOutputType
     */
    select?: WorkspaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceMemberWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountPositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PositionWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountPositionLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PositionLevelWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountProjectRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectRoleWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountLeaveTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveTypeWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountLeaveQuotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveQuotaWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountOvertimePoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OvertimePolicyWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountOvertimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OvertimeWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountApprovalTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalTemplateWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountSettingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    teams: number
    employees: number
    children: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teams?: boolean | DepartmentCountOutputTypeCountTeamsArgs
    employees?: boolean | DepartmentCountOutputTypeCountEmployeesArgs
    children?: boolean | DepartmentCountOutputTypeCountChildrenArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    employees: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | TeamCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type PositionCountOutputType
   */

  export type PositionCountOutputType = {
    employees: number
    employmentHistory: number
  }

  export type PositionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | PositionCountOutputTypeCountEmployeesArgs
    employmentHistory?: boolean | PositionCountOutputTypeCountEmploymentHistoryArgs
  }

  // Custom InputTypes
  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionCountOutputType
     */
    select?: PositionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * PositionCountOutputType without action
   */
  export type PositionCountOutputTypeCountEmploymentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploymentHistoryWhereInput
  }


  /**
   * Count Type PositionLevelCountOutputType
   */

  export type PositionLevelCountOutputType = {
    employees: number
    employmentHistory: number
  }

  export type PositionLevelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | PositionLevelCountOutputTypeCountEmployeesArgs
    employmentHistory?: boolean | PositionLevelCountOutputTypeCountEmploymentHistoryArgs
  }

  // Custom InputTypes
  /**
   * PositionLevelCountOutputType without action
   */
  export type PositionLevelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionLevelCountOutputType
     */
    select?: PositionLevelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PositionLevelCountOutputType without action
   */
  export type PositionLevelCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * PositionLevelCountOutputType without action
   */
  export type PositionLevelCountOutputTypeCountEmploymentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploymentHistoryWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    subordinates: number
    projectMembers: number
    employmentHistory: number
    documents: number
    leaveQuotas: number
    leaves: number
    overtimes: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subordinates?: boolean | EmployeeCountOutputTypeCountSubordinatesArgs
    projectMembers?: boolean | EmployeeCountOutputTypeCountProjectMembersArgs
    employmentHistory?: boolean | EmployeeCountOutputTypeCountEmploymentHistoryArgs
    documents?: boolean | EmployeeCountOutputTypeCountDocumentsArgs
    leaveQuotas?: boolean | EmployeeCountOutputTypeCountLeaveQuotasArgs
    leaves?: boolean | EmployeeCountOutputTypeCountLeavesArgs
    overtimes?: boolean | EmployeeCountOutputTypeCountOvertimesArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountSubordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountProjectMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountEmploymentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploymentHistoryWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeDocumentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLeaveQuotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveQuotaWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountOvertimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OvertimeWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    members: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ProjectCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }


  /**
   * Count Type ProjectRoleCountOutputType
   */

  export type ProjectRoleCountOutputType = {
    projectMembers: number
  }

  export type ProjectRoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectMembers?: boolean | ProjectRoleCountOutputTypeCountProjectMembersArgs
  }

  // Custom InputTypes
  /**
   * ProjectRoleCountOutputType without action
   */
  export type ProjectRoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRoleCountOutputType
     */
    select?: ProjectRoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectRoleCountOutputType without action
   */
  export type ProjectRoleCountOutputTypeCountProjectMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
  }


  /**
   * Count Type LeaveTypeCountOutputType
   */

  export type LeaveTypeCountOutputType = {
    leaveQuotas: number
    leaves: number
  }

  export type LeaveTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leaveQuotas?: boolean | LeaveTypeCountOutputTypeCountLeaveQuotasArgs
    leaves?: boolean | LeaveTypeCountOutputTypeCountLeavesArgs
  }

  // Custom InputTypes
  /**
   * LeaveTypeCountOutputType without action
   */
  export type LeaveTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveTypeCountOutputType
     */
    select?: LeaveTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeaveTypeCountOutputType without action
   */
  export type LeaveTypeCountOutputTypeCountLeaveQuotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveQuotaWhereInput
  }

  /**
   * LeaveTypeCountOutputType without action
   */
  export type LeaveTypeCountOutputTypeCountLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
  }


  /**
   * Count Type OvertimePolicyCountOutputType
   */

  export type OvertimePolicyCountOutputType = {
    overtimes: number
  }

  export type OvertimePolicyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    overtimes?: boolean | OvertimePolicyCountOutputTypeCountOvertimesArgs
  }

  // Custom InputTypes
  /**
   * OvertimePolicyCountOutputType without action
   */
  export type OvertimePolicyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimePolicyCountOutputType
     */
    select?: OvertimePolicyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OvertimePolicyCountOutputType without action
   */
  export type OvertimePolicyCountOutputTypeCountOvertimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OvertimeWhereInput
  }


  /**
   * Count Type ApprovalTemplateCountOutputType
   */

  export type ApprovalTemplateCountOutputType = {
    steps: number
    approvals: number
  }

  export type ApprovalTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    steps?: boolean | ApprovalTemplateCountOutputTypeCountStepsArgs
    approvals?: boolean | ApprovalTemplateCountOutputTypeCountApprovalsArgs
  }

  // Custom InputTypes
  /**
   * ApprovalTemplateCountOutputType without action
   */
  export type ApprovalTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTemplateCountOutputType
     */
    select?: ApprovalTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApprovalTemplateCountOutputType without action
   */
  export type ApprovalTemplateCountOutputTypeCountStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalStepWhereInput
  }

  /**
   * ApprovalTemplateCountOutputType without action
   */
  export type ApprovalTemplateCountOutputTypeCountApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWhereInput
  }


  /**
   * Count Type ApprovalCountOutputType
   */

  export type ApprovalCountOutputType = {
    actions: number
  }

  export type ApprovalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actions?: boolean | ApprovalCountOutputTypeCountActionsArgs
  }

  // Custom InputTypes
  /**
   * ApprovalCountOutputType without action
   */
  export type ApprovalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalCountOutputType
     */
    select?: ApprovalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApprovalCountOutputType without action
   */
  export type ApprovalCountOutputTypeCountActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalActionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    password: string | null
    image: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLogin: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    password: string | null
    image: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLogin: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    password: number
    image: number
    role: number
    status: number
    createdAt: number
    updatedAt: number
    lastLogin: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    role?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    role?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    password?: true
    image?: true
    role?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    emailVerified: Date | null
    password: string | null
    image: string | null
    role: $Enums.UserRole
    status: $Enums.UserStatus
    createdAt: Date
    updatedAt: Date
    lastLogin: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    employee?: boolean | User$employeeArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    workspaceMember?: boolean | User$workspaceMemberArgs<ExtArgs>
    approvalActions?: boolean | User$approvalActionsArgs<ExtArgs>
    consents?: boolean | User$consentsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    password?: boolean
    image?: boolean
    role?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "password" | "image" | "role" | "status" | "createdAt" | "updatedAt" | "lastLogin", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    employee?: boolean | User$employeeArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    workspaceMember?: boolean | User$workspaceMemberArgs<ExtArgs>
    approvalActions?: boolean | User$approvalActionsArgs<ExtArgs>
    consents?: boolean | User$consentsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      employee: Prisma.$EmployeePayload<ExtArgs> | null
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      workspaceMember: Prisma.$WorkspaceMemberPayload<ExtArgs>[]
      approvalActions: Prisma.$ApprovalActionPayload<ExtArgs>[]
      consents: Prisma.$UserConsentPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      emailVerified: Date | null
      password: string | null
      image: string | null
      role: $Enums.UserRole
      status: $Enums.UserStatus
      createdAt: Date
      updatedAt: Date
      lastLogin: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employee<T extends User$employeeArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    activityLogs<T extends User$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workspaceMember<T extends User$workspaceMemberArgs<ExtArgs> = {}>(args?: Subset<T, User$workspaceMemberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvalActions<T extends User$approvalActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$approvalActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    consents<T extends User$consentsArgs<ExtArgs> = {}>(args?: Subset<T, User$consentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly password: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.employee
   */
  export type User$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * User.activityLogs
   */
  export type User$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.workspaceMember
   */
  export type User$workspaceMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    where?: WorkspaceMemberWhereInput
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    cursor?: WorkspaceMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceMemberScalarFieldEnum | WorkspaceMemberScalarFieldEnum[]
  }

  /**
   * User.approvalActions
   */
  export type User$approvalActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalAction
     */
    omit?: ApprovalActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    where?: ApprovalActionWhereInput
    orderBy?: ApprovalActionOrderByWithRelationInput | ApprovalActionOrderByWithRelationInput[]
    cursor?: ApprovalActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalActionScalarFieldEnum | ApprovalActionScalarFieldEnum[]
  }

  /**
   * User.consents
   */
  export type User$consentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    where?: UserConsentWhereInput
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    cursor?: UserConsentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Workspace
   */

  export type AggregateWorkspace = {
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  export type WorkspaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    address: string | null
    taxId: string | null
    phone: string | null
    email: string | null
    contactPerson: string | null
    status: $Enums.WorkspaceStatus | null
    planType: $Enums.PlanType | null
    subscriptionStart: Date | null
    subscriptionEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    logo: string | null
    address: string | null
    taxId: string | null
    phone: string | null
    email: string | null
    contactPerson: string | null
    status: $Enums.WorkspaceStatus | null
    planType: $Enums.PlanType | null
    subscriptionStart: Date | null
    subscriptionEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    logo: number
    address: number
    taxId: number
    phone: number
    email: number
    contactPerson: number
    status: number
    planType: number
    subscriptionStart: number
    subscriptionEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    address?: true
    taxId?: true
    phone?: true
    email?: true
    contactPerson?: true
    status?: true
    planType?: true
    subscriptionStart?: true
    subscriptionEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    address?: true
    taxId?: true
    phone?: true
    email?: true
    contactPerson?: true
    status?: true
    planType?: true
    subscriptionStart?: true
    subscriptionEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    logo?: true
    address?: true
    taxId?: true
    phone?: true
    email?: true
    contactPerson?: true
    status?: true
    planType?: true
    subscriptionStart?: true
    subscriptionEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkspaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspace to aggregate.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workspaces
    **/
    _count?: true | WorkspaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceMaxAggregateInputType
  }

  export type GetWorkspaceAggregateType<T extends WorkspaceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspace[P]>
      : GetScalarType<T[P], AggregateWorkspace[P]>
  }




  export type WorkspaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceWhereInput
    orderBy?: WorkspaceOrderByWithAggregationInput | WorkspaceOrderByWithAggregationInput[]
    by: WorkspaceScalarFieldEnum[] | WorkspaceScalarFieldEnum
    having?: WorkspaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceCountAggregateInputType | true
    _min?: WorkspaceMinAggregateInputType
    _max?: WorkspaceMaxAggregateInputType
  }

  export type WorkspaceGroupByOutputType = {
    id: string
    name: string
    slug: string
    logo: string | null
    address: string | null
    taxId: string | null
    phone: string | null
    email: string | null
    contactPerson: string | null
    status: $Enums.WorkspaceStatus
    planType: $Enums.PlanType
    subscriptionStart: Date | null
    subscriptionEnd: Date | null
    createdAt: Date
    updatedAt: Date
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  type GetWorkspaceGroupByPayload<T extends WorkspaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    address?: boolean
    taxId?: boolean
    phone?: boolean
    email?: boolean
    contactPerson?: boolean
    status?: boolean
    planType?: boolean
    subscriptionStart?: boolean
    subscriptionEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    members?: boolean | Workspace$membersArgs<ExtArgs>
    departments?: boolean | Workspace$departmentsArgs<ExtArgs>
    teams?: boolean | Workspace$teamsArgs<ExtArgs>
    positions?: boolean | Workspace$positionsArgs<ExtArgs>
    positionLevels?: boolean | Workspace$positionLevelsArgs<ExtArgs>
    employees?: boolean | Workspace$employeesArgs<ExtArgs>
    projects?: boolean | Workspace$projectsArgs<ExtArgs>
    projectRoles?: boolean | Workspace$projectRolesArgs<ExtArgs>
    leaveTypes?: boolean | Workspace$leaveTypesArgs<ExtArgs>
    leaveQuotas?: boolean | Workspace$leaveQuotasArgs<ExtArgs>
    leaves?: boolean | Workspace$leavesArgs<ExtArgs>
    overtimePolicies?: boolean | Workspace$overtimePoliciesArgs<ExtArgs>
    overtimes?: boolean | Workspace$overtimesArgs<ExtArgs>
    approvalTemplates?: boolean | Workspace$approvalTemplatesArgs<ExtArgs>
    approvals?: boolean | Workspace$approvalsArgs<ExtArgs>
    settings?: boolean | Workspace$settingsArgs<ExtArgs>
    auditLogs?: boolean | Workspace$auditLogsArgs<ExtArgs>
    invitations?: boolean | Workspace$invitationsArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    address?: boolean
    taxId?: boolean
    phone?: boolean
    email?: boolean
    contactPerson?: boolean
    status?: boolean
    planType?: boolean
    subscriptionStart?: boolean
    subscriptionEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    address?: boolean
    taxId?: boolean
    phone?: boolean
    email?: boolean
    contactPerson?: boolean
    status?: boolean
    planType?: boolean
    subscriptionStart?: boolean
    subscriptionEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    logo?: boolean
    address?: boolean
    taxId?: boolean
    phone?: boolean
    email?: boolean
    contactPerson?: boolean
    status?: boolean
    planType?: boolean
    subscriptionStart?: boolean
    subscriptionEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkspaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "logo" | "address" | "taxId" | "phone" | "email" | "contactPerson" | "status" | "planType" | "subscriptionStart" | "subscriptionEnd" | "createdAt" | "updatedAt", ExtArgs["result"]["workspace"]>
  export type WorkspaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Workspace$membersArgs<ExtArgs>
    departments?: boolean | Workspace$departmentsArgs<ExtArgs>
    teams?: boolean | Workspace$teamsArgs<ExtArgs>
    positions?: boolean | Workspace$positionsArgs<ExtArgs>
    positionLevels?: boolean | Workspace$positionLevelsArgs<ExtArgs>
    employees?: boolean | Workspace$employeesArgs<ExtArgs>
    projects?: boolean | Workspace$projectsArgs<ExtArgs>
    projectRoles?: boolean | Workspace$projectRolesArgs<ExtArgs>
    leaveTypes?: boolean | Workspace$leaveTypesArgs<ExtArgs>
    leaveQuotas?: boolean | Workspace$leaveQuotasArgs<ExtArgs>
    leaves?: boolean | Workspace$leavesArgs<ExtArgs>
    overtimePolicies?: boolean | Workspace$overtimePoliciesArgs<ExtArgs>
    overtimes?: boolean | Workspace$overtimesArgs<ExtArgs>
    approvalTemplates?: boolean | Workspace$approvalTemplatesArgs<ExtArgs>
    approvals?: boolean | Workspace$approvalsArgs<ExtArgs>
    settings?: boolean | Workspace$settingsArgs<ExtArgs>
    auditLogs?: boolean | Workspace$auditLogsArgs<ExtArgs>
    invitations?: boolean | Workspace$invitationsArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkspaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WorkspaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WorkspacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workspace"
    objects: {
      members: Prisma.$WorkspaceMemberPayload<ExtArgs>[]
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
      teams: Prisma.$TeamPayload<ExtArgs>[]
      positions: Prisma.$PositionPayload<ExtArgs>[]
      positionLevels: Prisma.$PositionLevelPayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      projectRoles: Prisma.$ProjectRolePayload<ExtArgs>[]
      leaveTypes: Prisma.$LeaveTypePayload<ExtArgs>[]
      leaveQuotas: Prisma.$LeaveQuotaPayload<ExtArgs>[]
      leaves: Prisma.$LeavePayload<ExtArgs>[]
      overtimePolicies: Prisma.$OvertimePolicyPayload<ExtArgs>[]
      overtimes: Prisma.$OvertimePayload<ExtArgs>[]
      approvalTemplates: Prisma.$ApprovalTemplatePayload<ExtArgs>[]
      approvals: Prisma.$ApprovalPayload<ExtArgs>[]
      settings: Prisma.$SettingsPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      invitations: Prisma.$InvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      logo: string | null
      address: string | null
      taxId: string | null
      phone: string | null
      email: string | null
      contactPerson: string | null
      status: $Enums.WorkspaceStatus
      planType: $Enums.PlanType
      subscriptionStart: Date | null
      subscriptionEnd: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workspace"]>
    composites: {}
  }

  type WorkspaceGetPayload<S extends boolean | null | undefined | WorkspaceDefaultArgs> = $Result.GetResult<Prisma.$WorkspacePayload, S>

  type WorkspaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceCountAggregateInputType | true
    }

  export interface WorkspaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workspace'], meta: { name: 'Workspace' } }
    /**
     * Find zero or one Workspace that matches the filter.
     * @param {WorkspaceFindUniqueArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceFindUniqueArgs>(args: SelectSubset<T, WorkspaceFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workspace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceFindUniqueOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workspace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceFindFirstArgs>(args?: SelectSubset<T, WorkspaceFindFirstArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workspace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workspaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workspaces
     * const workspaces = await prisma.workspace.findMany()
     * 
     * // Get first 10 Workspaces
     * const workspaces = await prisma.workspace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceWithIdOnly = await prisma.workspace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceFindManyArgs>(args?: SelectSubset<T, WorkspaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workspace.
     * @param {WorkspaceCreateArgs} args - Arguments to create a Workspace.
     * @example
     * // Create one Workspace
     * const Workspace = await prisma.workspace.create({
     *   data: {
     *     // ... data to create a Workspace
     *   }
     * })
     * 
     */
    create<T extends WorkspaceCreateArgs>(args: SelectSubset<T, WorkspaceCreateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workspaces.
     * @param {WorkspaceCreateManyArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceCreateManyArgs>(args?: SelectSubset<T, WorkspaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workspaces and returns the data saved in the database.
     * @param {WorkspaceCreateManyAndReturnArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workspace.
     * @param {WorkspaceDeleteArgs} args - Arguments to delete one Workspace.
     * @example
     * // Delete one Workspace
     * const Workspace = await prisma.workspace.delete({
     *   where: {
     *     // ... filter to delete one Workspace
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceDeleteArgs>(args: SelectSubset<T, WorkspaceDeleteArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workspace.
     * @param {WorkspaceUpdateArgs} args - Arguments to update one Workspace.
     * @example
     * // Update one Workspace
     * const workspace = await prisma.workspace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUpdateArgs>(args: SelectSubset<T, WorkspaceUpdateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workspaces.
     * @param {WorkspaceDeleteManyArgs} args - Arguments to filter Workspaces to delete.
     * @example
     * // Delete a few Workspaces
     * const { count } = await prisma.workspace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceDeleteManyArgs>(args?: SelectSubset<T, WorkspaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUpdateManyArgs>(args: SelectSubset<T, WorkspaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces and returns the data updated in the database.
     * @param {WorkspaceUpdateManyAndReturnArgs} args - Arguments to update many Workspaces.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workspace.
     * @param {WorkspaceUpsertArgs} args - Arguments to update or create a Workspace.
     * @example
     * // Update or create a Workspace
     * const workspace = await prisma.workspace.upsert({
     *   create: {
     *     // ... data to create a Workspace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workspace we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUpsertArgs>(args: SelectSubset<T, WorkspaceUpsertArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceCountArgs} args - Arguments to filter Workspaces to count.
     * @example
     * // Count the number of Workspaces
     * const count = await prisma.workspace.count({
     *   where: {
     *     // ... the filter for the Workspaces we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceCountArgs>(
      args?: Subset<T, WorkspaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceAggregateArgs>(args: Subset<T, WorkspaceAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceAggregateType<T>>

    /**
     * Group by Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workspace model
   */
  readonly fields: WorkspaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workspace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Workspace$membersArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    departments<T extends Workspace$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    teams<T extends Workspace$teamsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    positions<T extends Workspace$positionsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$positionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    positionLevels<T extends Workspace$positionLevelsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$positionLevelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Workspace$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends Workspace$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectRoles<T extends Workspace$projectRolesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$projectRolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaveTypes<T extends Workspace$leaveTypesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$leaveTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaveQuotas<T extends Workspace$leaveQuotasArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$leaveQuotasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveQuotaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaves<T extends Workspace$leavesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$leavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    overtimePolicies<T extends Workspace$overtimePoliciesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$overtimePoliciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    overtimes<T extends Workspace$overtimesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$overtimesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvalTemplates<T extends Workspace$approvalTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$approvalTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvals<T extends Workspace$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settings<T extends Workspace$settingsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$settingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends Workspace$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends Workspace$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workspace model
   */
  interface WorkspaceFieldRefs {
    readonly id: FieldRef<"Workspace", 'String'>
    readonly name: FieldRef<"Workspace", 'String'>
    readonly slug: FieldRef<"Workspace", 'String'>
    readonly logo: FieldRef<"Workspace", 'String'>
    readonly address: FieldRef<"Workspace", 'String'>
    readonly taxId: FieldRef<"Workspace", 'String'>
    readonly phone: FieldRef<"Workspace", 'String'>
    readonly email: FieldRef<"Workspace", 'String'>
    readonly contactPerson: FieldRef<"Workspace", 'String'>
    readonly status: FieldRef<"Workspace", 'WorkspaceStatus'>
    readonly planType: FieldRef<"Workspace", 'PlanType'>
    readonly subscriptionStart: FieldRef<"Workspace", 'DateTime'>
    readonly subscriptionEnd: FieldRef<"Workspace", 'DateTime'>
    readonly createdAt: FieldRef<"Workspace", 'DateTime'>
    readonly updatedAt: FieldRef<"Workspace", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workspace findUnique
   */
  export type WorkspaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findUniqueOrThrow
   */
  export type WorkspaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findFirst
   */
  export type WorkspaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findFirstOrThrow
   */
  export type WorkspaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findMany
   */
  export type WorkspaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspaces to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace create
   */
  export type WorkspaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Workspace.
     */
    data: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
  }

  /**
   * Workspace createMany
   */
  export type WorkspaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workspace createManyAndReturn
   */
  export type WorkspaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workspace update
   */
  export type WorkspaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Workspace.
     */
    data: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
    /**
     * Choose, which Workspace to update.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace updateMany
   */
  export type WorkspaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to update.
     */
    limit?: number
  }

  /**
   * Workspace updateManyAndReturn
   */
  export type WorkspaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to update.
     */
    limit?: number
  }

  /**
   * Workspace upsert
   */
  export type WorkspaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Workspace to update in case it exists.
     */
    where: WorkspaceWhereUniqueInput
    /**
     * In case the Workspace found by the `where` argument doesn't exist, create a new Workspace with this data.
     */
    create: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
    /**
     * In case the Workspace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
  }

  /**
   * Workspace delete
   */
  export type WorkspaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter which Workspace to delete.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace deleteMany
   */
  export type WorkspaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspaces to delete
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to delete.
     */
    limit?: number
  }

  /**
   * Workspace.members
   */
  export type Workspace$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    where?: WorkspaceMemberWhereInput
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    cursor?: WorkspaceMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceMemberScalarFieldEnum | WorkspaceMemberScalarFieldEnum[]
  }

  /**
   * Workspace.departments
   */
  export type Workspace$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Workspace.teams
   */
  export type Workspace$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Workspace.positions
   */
  export type Workspace$positionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    where?: PositionWhereInput
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    cursor?: PositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Workspace.positionLevels
   */
  export type Workspace$positionLevelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionLevel
     */
    select?: PositionLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PositionLevel
     */
    omit?: PositionLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionLevelInclude<ExtArgs> | null
    where?: PositionLevelWhereInput
    orderBy?: PositionLevelOrderByWithRelationInput | PositionLevelOrderByWithRelationInput[]
    cursor?: PositionLevelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PositionLevelScalarFieldEnum | PositionLevelScalarFieldEnum[]
  }

  /**
   * Workspace.employees
   */
  export type Workspace$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Workspace.projects
   */
  export type Workspace$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Workspace.projectRoles
   */
  export type Workspace$projectRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    where?: ProjectRoleWhereInput
    orderBy?: ProjectRoleOrderByWithRelationInput | ProjectRoleOrderByWithRelationInput[]
    cursor?: ProjectRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectRoleScalarFieldEnum | ProjectRoleScalarFieldEnum[]
  }

  /**
   * Workspace.leaveTypes
   */
  export type Workspace$leaveTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    where?: LeaveTypeWhereInput
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    cursor?: LeaveTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }

  /**
   * Workspace.leaveQuotas
   */
  export type Workspace$leaveQuotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveQuota
     */
    select?: LeaveQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveQuota
     */
    omit?: LeaveQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveQuotaInclude<ExtArgs> | null
    where?: LeaveQuotaWhereInput
    orderBy?: LeaveQuotaOrderByWithRelationInput | LeaveQuotaOrderByWithRelationInput[]
    cursor?: LeaveQuotaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveQuotaScalarFieldEnum | LeaveQuotaScalarFieldEnum[]
  }

  /**
   * Workspace.leaves
   */
  export type Workspace$leavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    cursor?: LeaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Workspace.overtimePolicies
   */
  export type Workspace$overtimePoliciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimePolicy
     */
    select?: OvertimePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimePolicy
     */
    omit?: OvertimePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimePolicyInclude<ExtArgs> | null
    where?: OvertimePolicyWhereInput
    orderBy?: OvertimePolicyOrderByWithRelationInput | OvertimePolicyOrderByWithRelationInput[]
    cursor?: OvertimePolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OvertimePolicyScalarFieldEnum | OvertimePolicyScalarFieldEnum[]
  }

  /**
   * Workspace.overtimes
   */
  export type Workspace$overtimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    where?: OvertimeWhereInput
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    cursor?: OvertimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OvertimeScalarFieldEnum | OvertimeScalarFieldEnum[]
  }

  /**
   * Workspace.approvalTemplates
   */
  export type Workspace$approvalTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTemplate
     */
    select?: ApprovalTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTemplate
     */
    omit?: ApprovalTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTemplateInclude<ExtArgs> | null
    where?: ApprovalTemplateWhereInput
    orderBy?: ApprovalTemplateOrderByWithRelationInput | ApprovalTemplateOrderByWithRelationInput[]
    cursor?: ApprovalTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalTemplateScalarFieldEnum | ApprovalTemplateScalarFieldEnum[]
  }

  /**
   * Workspace.approvals
   */
  export type Workspace$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    where?: ApprovalWhereInput
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    cursor?: ApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Workspace.settings
   */
  export type Workspace$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    cursor?: SettingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Workspace.auditLogs
   */
  export type Workspace$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Workspace.invitations
   */
  export type Workspace$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Workspace without action
   */
  export type WorkspaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
  }


  /**
   * Model WorkspaceMember
   */

  export type AggregateWorkspaceMember = {
    _count: WorkspaceMemberCountAggregateOutputType | null
    _min: WorkspaceMemberMinAggregateOutputType | null
    _max: WorkspaceMemberMaxAggregateOutputType | null
  }

  export type WorkspaceMemberMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    role: $Enums.MemberRole | null
    joinedAt: Date | null
    invitedBy: string | null
    status: $Enums.MemberStatus | null
  }

  export type WorkspaceMemberMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    role: $Enums.MemberRole | null
    joinedAt: Date | null
    invitedBy: string | null
    status: $Enums.MemberStatus | null
  }

  export type WorkspaceMemberCountAggregateOutputType = {
    id: number
    workspaceId: number
    userId: number
    role: number
    joinedAt: number
    invitedBy: number
    status: number
    _all: number
  }


  export type WorkspaceMemberMinAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    invitedBy?: true
    status?: true
  }

  export type WorkspaceMemberMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    invitedBy?: true
    status?: true
  }

  export type WorkspaceMemberCountAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    role?: true
    joinedAt?: true
    invitedBy?: true
    status?: true
    _all?: true
  }

  export type WorkspaceMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceMember to aggregate.
     */
    where?: WorkspaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceMembers to fetch.
     */
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkspaceMembers
    **/
    _count?: true | WorkspaceMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceMemberMaxAggregateInputType
  }

  export type GetWorkspaceMemberAggregateType<T extends WorkspaceMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspaceMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspaceMember[P]>
      : GetScalarType<T[P], AggregateWorkspaceMember[P]>
  }




  export type WorkspaceMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceMemberWhereInput
    orderBy?: WorkspaceMemberOrderByWithAggregationInput | WorkspaceMemberOrderByWithAggregationInput[]
    by: WorkspaceMemberScalarFieldEnum[] | WorkspaceMemberScalarFieldEnum
    having?: WorkspaceMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceMemberCountAggregateInputType | true
    _min?: WorkspaceMemberMinAggregateInputType
    _max?: WorkspaceMemberMaxAggregateInputType
  }

  export type WorkspaceMemberGroupByOutputType = {
    id: string
    workspaceId: string
    userId: string
    role: $Enums.MemberRole
    joinedAt: Date
    invitedBy: string | null
    status: $Enums.MemberStatus
    _count: WorkspaceMemberCountAggregateOutputType | null
    _min: WorkspaceMemberMinAggregateOutputType | null
    _max: WorkspaceMemberMaxAggregateOutputType | null
  }

  type GetWorkspaceMemberGroupByPayload<T extends WorkspaceMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceMemberGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceMemberGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
    status?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceMember"]>

  export type WorkspaceMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
    status?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceMember"]>

  export type WorkspaceMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
    status?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspaceMember"]>

  export type WorkspaceMemberSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    role?: boolean
    joinedAt?: boolean
    invitedBy?: boolean
    status?: boolean
  }

  export type WorkspaceMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "userId" | "role" | "joinedAt" | "invitedBy" | "status", ExtArgs["result"]["workspaceMember"]>
  export type WorkspaceMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkspaceMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WorkspaceMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WorkspaceMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkspaceMember"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      userId: string
      role: $Enums.MemberRole
      joinedAt: Date
      invitedBy: string | null
      status: $Enums.MemberStatus
    }, ExtArgs["result"]["workspaceMember"]>
    composites: {}
  }

  type WorkspaceMemberGetPayload<S extends boolean | null | undefined | WorkspaceMemberDefaultArgs> = $Result.GetResult<Prisma.$WorkspaceMemberPayload, S>

  type WorkspaceMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceMemberCountAggregateInputType | true
    }

  export interface WorkspaceMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkspaceMember'], meta: { name: 'WorkspaceMember' } }
    /**
     * Find zero or one WorkspaceMember that matches the filter.
     * @param {WorkspaceMemberFindUniqueArgs} args - Arguments to find a WorkspaceMember
     * @example
     * // Get one WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceMemberFindUniqueArgs>(args: SelectSubset<T, WorkspaceMemberFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkspaceMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceMemberFindUniqueOrThrowArgs} args - Arguments to find a WorkspaceMember
     * @example
     * // Get one WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberFindFirstArgs} args - Arguments to find a WorkspaceMember
     * @example
     * // Get one WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceMemberFindFirstArgs>(args?: SelectSubset<T, WorkspaceMemberFindFirstArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkspaceMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberFindFirstOrThrowArgs} args - Arguments to find a WorkspaceMember
     * @example
     * // Get one WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkspaceMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkspaceMembers
     * const workspaceMembers = await prisma.workspaceMember.findMany()
     * 
     * // Get first 10 WorkspaceMembers
     * const workspaceMembers = await prisma.workspaceMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceMemberWithIdOnly = await prisma.workspaceMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceMemberFindManyArgs>(args?: SelectSubset<T, WorkspaceMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkspaceMember.
     * @param {WorkspaceMemberCreateArgs} args - Arguments to create a WorkspaceMember.
     * @example
     * // Create one WorkspaceMember
     * const WorkspaceMember = await prisma.workspaceMember.create({
     *   data: {
     *     // ... data to create a WorkspaceMember
     *   }
     * })
     * 
     */
    create<T extends WorkspaceMemberCreateArgs>(args: SelectSubset<T, WorkspaceMemberCreateArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkspaceMembers.
     * @param {WorkspaceMemberCreateManyArgs} args - Arguments to create many WorkspaceMembers.
     * @example
     * // Create many WorkspaceMembers
     * const workspaceMember = await prisma.workspaceMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceMemberCreateManyArgs>(args?: SelectSubset<T, WorkspaceMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkspaceMembers and returns the data saved in the database.
     * @param {WorkspaceMemberCreateManyAndReturnArgs} args - Arguments to create many WorkspaceMembers.
     * @example
     * // Create many WorkspaceMembers
     * const workspaceMember = await prisma.workspaceMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkspaceMembers and only return the `id`
     * const workspaceMemberWithIdOnly = await prisma.workspaceMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkspaceMember.
     * @param {WorkspaceMemberDeleteArgs} args - Arguments to delete one WorkspaceMember.
     * @example
     * // Delete one WorkspaceMember
     * const WorkspaceMember = await prisma.workspaceMember.delete({
     *   where: {
     *     // ... filter to delete one WorkspaceMember
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceMemberDeleteArgs>(args: SelectSubset<T, WorkspaceMemberDeleteArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkspaceMember.
     * @param {WorkspaceMemberUpdateArgs} args - Arguments to update one WorkspaceMember.
     * @example
     * // Update one WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceMemberUpdateArgs>(args: SelectSubset<T, WorkspaceMemberUpdateArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkspaceMembers.
     * @param {WorkspaceMemberDeleteManyArgs} args - Arguments to filter WorkspaceMembers to delete.
     * @example
     * // Delete a few WorkspaceMembers
     * const { count } = await prisma.workspaceMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceMemberDeleteManyArgs>(args?: SelectSubset<T, WorkspaceMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkspaceMembers
     * const workspaceMember = await prisma.workspaceMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceMemberUpdateManyArgs>(args: SelectSubset<T, WorkspaceMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkspaceMembers and returns the data updated in the database.
     * @param {WorkspaceMemberUpdateManyAndReturnArgs} args - Arguments to update many WorkspaceMembers.
     * @example
     * // Update many WorkspaceMembers
     * const workspaceMember = await prisma.workspaceMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkspaceMembers and only return the `id`
     * const workspaceMemberWithIdOnly = await prisma.workspaceMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkspaceMember.
     * @param {WorkspaceMemberUpsertArgs} args - Arguments to update or create a WorkspaceMember.
     * @example
     * // Update or create a WorkspaceMember
     * const workspaceMember = await prisma.workspaceMember.upsert({
     *   create: {
     *     // ... data to create a WorkspaceMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkspaceMember we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceMemberUpsertArgs>(args: SelectSubset<T, WorkspaceMemberUpsertArgs<ExtArgs>>): Prisma__WorkspaceMemberClient<$Result.GetResult<Prisma.$WorkspaceMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkspaceMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberCountArgs} args - Arguments to filter WorkspaceMembers to count.
     * @example
     * // Count the number of WorkspaceMembers
     * const count = await prisma.workspaceMember.count({
     *   where: {
     *     // ... the filter for the WorkspaceMembers we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceMemberCountArgs>(
      args?: Subset<T, WorkspaceMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkspaceMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceMemberAggregateArgs>(args: Subset<T, WorkspaceMemberAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceMemberAggregateType<T>>

    /**
     * Group by WorkspaceMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceMemberGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkspaceMember model
   */
  readonly fields: WorkspaceMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkspaceMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkspaceMember model
   */
  interface WorkspaceMemberFieldRefs {
    readonly id: FieldRef<"WorkspaceMember", 'String'>
    readonly workspaceId: FieldRef<"WorkspaceMember", 'String'>
    readonly userId: FieldRef<"WorkspaceMember", 'String'>
    readonly role: FieldRef<"WorkspaceMember", 'MemberRole'>
    readonly joinedAt: FieldRef<"WorkspaceMember", 'DateTime'>
    readonly invitedBy: FieldRef<"WorkspaceMember", 'String'>
    readonly status: FieldRef<"WorkspaceMember", 'MemberStatus'>
  }
    

  // Custom InputTypes
  /**
   * WorkspaceMember findUnique
   */
  export type WorkspaceMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceMember to fetch.
     */
    where: WorkspaceMemberWhereUniqueInput
  }

  /**
   * WorkspaceMember findUniqueOrThrow
   */
  export type WorkspaceMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceMember to fetch.
     */
    where: WorkspaceMemberWhereUniqueInput
  }

  /**
   * WorkspaceMember findFirst
   */
  export type WorkspaceMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceMember to fetch.
     */
    where?: WorkspaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceMembers to fetch.
     */
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceMembers.
     */
    cursor?: WorkspaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceMembers.
     */
    distinct?: WorkspaceMemberScalarFieldEnum | WorkspaceMemberScalarFieldEnum[]
  }

  /**
   * WorkspaceMember findFirstOrThrow
   */
  export type WorkspaceMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceMember to fetch.
     */
    where?: WorkspaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceMembers to fetch.
     */
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkspaceMembers.
     */
    cursor?: WorkspaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkspaceMembers.
     */
    distinct?: WorkspaceMemberScalarFieldEnum | WorkspaceMemberScalarFieldEnum[]
  }

  /**
   * WorkspaceMember findMany
   */
  export type WorkspaceMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter, which WorkspaceMembers to fetch.
     */
    where?: WorkspaceMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkspaceMembers to fetch.
     */
    orderBy?: WorkspaceMemberOrderByWithRelationInput | WorkspaceMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkspaceMembers.
     */
    cursor?: WorkspaceMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkspaceMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkspaceMembers.
     */
    skip?: number
    distinct?: WorkspaceMemberScalarFieldEnum | WorkspaceMemberScalarFieldEnum[]
  }

  /**
   * WorkspaceMember create
   */
  export type WorkspaceMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkspaceMember.
     */
    data: XOR<WorkspaceMemberCreateInput, WorkspaceMemberUncheckedCreateInput>
  }

  /**
   * WorkspaceMember createMany
   */
  export type WorkspaceMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkspaceMembers.
     */
    data: WorkspaceMemberCreateManyInput | WorkspaceMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WorkspaceMember createManyAndReturn
   */
  export type WorkspaceMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * The data used to create many WorkspaceMembers.
     */
    data: WorkspaceMemberCreateManyInput | WorkspaceMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceMember update
   */
  export type WorkspaceMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkspaceMember.
     */
    data: XOR<WorkspaceMemberUpdateInput, WorkspaceMemberUncheckedUpdateInput>
    /**
     * Choose, which WorkspaceMember to update.
     */
    where: WorkspaceMemberWhereUniqueInput
  }

  /**
   * WorkspaceMember updateMany
   */
  export type WorkspaceMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkspaceMembers.
     */
    data: XOR<WorkspaceMemberUpdateManyMutationInput, WorkspaceMemberUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceMembers to update
     */
    where?: WorkspaceMemberWhereInput
    /**
     * Limit how many WorkspaceMembers to update.
     */
    limit?: number
  }

  /**
   * WorkspaceMember updateManyAndReturn
   */
  export type WorkspaceMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * The data used to update WorkspaceMembers.
     */
    data: XOR<WorkspaceMemberUpdateManyMutationInput, WorkspaceMemberUncheckedUpdateManyInput>
    /**
     * Filter which WorkspaceMembers to update
     */
    where?: WorkspaceMemberWhereInput
    /**
     * Limit how many WorkspaceMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkspaceMember upsert
   */
  export type WorkspaceMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkspaceMember to update in case it exists.
     */
    where: WorkspaceMemberWhereUniqueInput
    /**
     * In case the WorkspaceMember found by the `where` argument doesn't exist, create a new WorkspaceMember with this data.
     */
    create: XOR<WorkspaceMemberCreateInput, WorkspaceMemberUncheckedCreateInput>
    /**
     * In case the WorkspaceMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceMemberUpdateInput, WorkspaceMemberUncheckedUpdateInput>
  }

  /**
   * WorkspaceMember delete
   */
  export type WorkspaceMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
    /**
     * Filter which WorkspaceMember to delete.
     */
    where: WorkspaceMemberWhereUniqueInput
  }

  /**
   * WorkspaceMember deleteMany
   */
  export type WorkspaceMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkspaceMembers to delete
     */
    where?: WorkspaceMemberWhereInput
    /**
     * Limit how many WorkspaceMembers to delete.
     */
    limit?: number
  }

  /**
   * WorkspaceMember without action
   */
  export type WorkspaceMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceMember
     */
    select?: WorkspaceMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkspaceMember
     */
    omit?: WorkspaceMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceMemberInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    code: string | null
    description: string | null
    managerId: string | null
    parentId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    code: string | null
    description: string | null
    managerId: string | null
    parentId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    code: number
    description: number
    managerId: number
    parentId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    code?: true
    description?: true
    managerId?: true
    parentId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    code?: true
    description?: true
    managerId?: true
    parentId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    code?: true
    description?: true
    managerId?: true
    parentId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    code: string | null
    description: string | null
    managerId: string | null
    parentId: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    managerId?: boolean
    parentId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    teams?: boolean | Department$teamsArgs<ExtArgs>
    employees?: boolean | Department$employeesArgs<ExtArgs>
    parent?: boolean | Department$parentArgs<ExtArgs>
    children?: boolean | Department$childrenArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    managerId?: boolean
    parentId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    parent?: boolean | Department$parentArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    managerId?: boolean
    parentId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    parent?: boolean | Department$parentArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    managerId?: boolean
    parentId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "code" | "description" | "managerId" | "parentId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    teams?: boolean | Department$teamsArgs<ExtArgs>
    employees?: boolean | Department$employeesArgs<ExtArgs>
    parent?: boolean | Department$parentArgs<ExtArgs>
    children?: boolean | Department$childrenArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    parent?: boolean | Department$parentArgs<ExtArgs>
  }
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    parent?: boolean | Department$parentArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      teams: Prisma.$TeamPayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      parent: Prisma.$DepartmentPayload<ExtArgs> | null
      children: Prisma.$DepartmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      code: string | null
      description: string | null
      managerId: string | null
      parentId: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teams<T extends Department$teamsArgs<ExtArgs> = {}>(args?: Subset<T, Department$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Department$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Department$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    parent<T extends Department$parentArgs<ExtArgs> = {}>(args?: Subset<T, Department$parentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Department$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Department$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly workspaceId: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly code: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly managerId: FieldRef<"Department", 'String'>
    readonly parentId: FieldRef<"Department", 'String'>
    readonly status: FieldRef<"Department", 'String'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.teams
   */
  export type Department$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Department.employees
   */
  export type Department$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Department.parent
   */
  export type Department$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Department.children
   */
  export type Department$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    departmentId: string | null
    name: string | null
    description: string | null
    leaderId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    departmentId: string | null
    name: string | null
    description: string | null
    leaderId: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    workspaceId: number
    departmentId: number
    name: number
    description: number
    leaderId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    workspaceId?: true
    departmentId?: true
    name?: true
    description?: true
    leaderId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    departmentId?: true
    name?: true
    description?: true
    leaderId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    workspaceId?: true
    departmentId?: true
    name?: true
    description?: true
    leaderId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    workspaceId: string
    departmentId: string
    name: string
    description: string | null
    leaderId: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    departmentId?: boolean
    name?: boolean
    description?: boolean
    leaderId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    employees?: boolean | Team$employeesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    departmentId?: boolean
    name?: boolean
    description?: boolean
    leaderId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    departmentId?: boolean
    name?: boolean
    description?: boolean
    leaderId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    departmentId?: boolean
    name?: boolean
    description?: boolean
    leaderId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "departmentId" | "name" | "description" | "leaderId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["team"]>
  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
    employees?: boolean | Team$employeesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }
  export type TeamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    department?: boolean | DepartmentDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs>
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      departmentId: string
      name: string
      description: string | null
      leaderId: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams and returns the data updated in the database.
     * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    department<T extends DepartmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DepartmentDefaultArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employees<T extends Team$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Team$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly workspaceId: FieldRef<"Team", 'String'>
    readonly departmentId: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
    readonly description: FieldRef<"Team", 'String'>
    readonly leaderId: FieldRef<"Team", 'String'>
    readonly status: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
  }

  /**
   * Team updateManyAndReturn
   */
  export type TeamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
    /**
     * Limit how many Teams to delete.
     */
    limit?: number
  }

  /**
   * Team.employees
   */
  export type Team$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model Position
   */

  export type AggregatePosition = {
    _count: PositionCountAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  export type PositionMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    code: string | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    code: string | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    code: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PositionMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    code?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    code?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    code?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Position to aggregate.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Positions
    **/
    _count?: true | PositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PositionMaxAggregateInputType
  }

  export type GetPositionAggregateType<T extends PositionAggregateArgs> = {
        [P in keyof T & keyof AggregatePosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosition[P]>
      : GetScalarType<T[P], AggregatePosition[P]>
  }




  export type PositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PositionWhereInput
    orderBy?: PositionOrderByWithAggregationInput | PositionOrderByWithAggregationInput[]
    by: PositionScalarFieldEnum[] | PositionScalarFieldEnum
    having?: PositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PositionCountAggregateInputType | true
    _min?: PositionMinAggregateInputType
    _max?: PositionMaxAggregateInputType
  }

  export type PositionGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    code: string | null
    description: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: PositionCountAggregateOutputType | null
    _min: PositionMinAggregateOutputType | null
    _max: PositionMaxAggregateOutputType | null
  }

  type GetPositionGroupByPayload<T extends PositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PositionGroupByOutputType[P]>
            : GetScalarType<T[P], PositionGroupByOutputType[P]>
        }
      >
    >


  export type PositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employees?: boolean | Position$employeesArgs<ExtArgs>
    employmentHistory?: boolean | Position$employmentHistoryArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type PositionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type PositionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["position"]>

  export type PositionSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PositionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "code" | "description" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["position"]>
  export type PositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employees?: boolean | Position$employeesArgs<ExtArgs>
    employmentHistory?: boolean | Position$employmentHistoryArgs<ExtArgs>
    _count?: boolean | PositionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PositionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type PositionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $PositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Position"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      employmentHistory: Prisma.$EmploymentHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      code: string | null
      description: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["position"]>
    composites: {}
  }

  type PositionGetPayload<S extends boolean | null | undefined | PositionDefaultArgs> = $Result.GetResult<Prisma.$PositionPayload, S>

  type PositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PositionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PositionCountAggregateInputType | true
    }

  export interface PositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Position'], meta: { name: 'Position' } }
    /**
     * Find zero or one Position that matches the filter.
     * @param {PositionFindUniqueArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PositionFindUniqueArgs>(args: SelectSubset<T, PositionFindUniqueArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Position that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PositionFindUniqueOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PositionFindUniqueOrThrowArgs>(args: SelectSubset<T, PositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PositionFindFirstArgs>(args?: SelectSubset<T, PositionFindFirstArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Position that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindFirstOrThrowArgs} args - Arguments to find a Position
     * @example
     * // Get one Position
     * const position = await prisma.position.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PositionFindFirstOrThrowArgs>(args?: SelectSubset<T, PositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Positions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Positions
     * const positions = await prisma.position.findMany()
     * 
     * // Get first 10 Positions
     * const positions = await prisma.position.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const positionWithIdOnly = await prisma.position.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PositionFindManyArgs>(args?: SelectSubset<T, PositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Position.
     * @param {PositionCreateArgs} args - Arguments to create a Position.
     * @example
     * // Create one Position
     * const Position = await prisma.position.create({
     *   data: {
     *     // ... data to create a Position
     *   }
     * })
     * 
     */
    create<T extends PositionCreateArgs>(args: SelectSubset<T, PositionCreateArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Positions.
     * @param {PositionCreateManyArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PositionCreateManyArgs>(args?: SelectSubset<T, PositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Positions and returns the data saved in the database.
     * @param {PositionCreateManyAndReturnArgs} args - Arguments to create many Positions.
     * @example
     * // Create many Positions
     * const position = await prisma.position.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Positions and only return the `id`
     * const positionWithIdOnly = await prisma.position.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PositionCreateManyAndReturnArgs>(args?: SelectSubset<T, PositionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Position.
     * @param {PositionDeleteArgs} args - Arguments to delete one Position.
     * @example
     * // Delete one Position
     * const Position = await prisma.position.delete({
     *   where: {
     *     // ... filter to delete one Position
     *   }
     * })
     * 
     */
    delete<T extends PositionDeleteArgs>(args: SelectSubset<T, PositionDeleteArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Position.
     * @param {PositionUpdateArgs} args - Arguments to update one Position.
     * @example
     * // Update one Position
     * const position = await prisma.position.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PositionUpdateArgs>(args: SelectSubset<T, PositionUpdateArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Positions.
     * @param {PositionDeleteManyArgs} args - Arguments to filter Positions to delete.
     * @example
     * // Delete a few Positions
     * const { count } = await prisma.position.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PositionDeleteManyArgs>(args?: SelectSubset<T, PositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PositionUpdateManyArgs>(args: SelectSubset<T, PositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Positions and returns the data updated in the database.
     * @param {PositionUpdateManyAndReturnArgs} args - Arguments to update many Positions.
     * @example
     * // Update many Positions
     * const position = await prisma.position.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Positions and only return the `id`
     * const positionWithIdOnly = await prisma.position.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PositionUpdateManyAndReturnArgs>(args: SelectSubset<T, PositionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Position.
     * @param {PositionUpsertArgs} args - Arguments to update or create a Position.
     * @example
     * // Update or create a Position
     * const position = await prisma.position.upsert({
     *   create: {
     *     // ... data to create a Position
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Position we want to update
     *   }
     * })
     */
    upsert<T extends PositionUpsertArgs>(args: SelectSubset<T, PositionUpsertArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Positions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionCountArgs} args - Arguments to filter Positions to count.
     * @example
     * // Count the number of Positions
     * const count = await prisma.position.count({
     *   where: {
     *     // ... the filter for the Positions we want to count
     *   }
     * })
    **/
    count<T extends PositionCountArgs>(
      args?: Subset<T, PositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PositionAggregateArgs>(args: Subset<T, PositionAggregateArgs>): Prisma.PrismaPromise<GetPositionAggregateType<T>>

    /**
     * Group by Position.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PositionGroupByArgs['orderBy'] }
        : { orderBy?: PositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Position model
   */
  readonly fields: PositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Position.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employees<T extends Position$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Position$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employmentHistory<T extends Position$employmentHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Position$employmentHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Position model
   */
  interface PositionFieldRefs {
    readonly id: FieldRef<"Position", 'String'>
    readonly workspaceId: FieldRef<"Position", 'String'>
    readonly name: FieldRef<"Position", 'String'>
    readonly code: FieldRef<"Position", 'String'>
    readonly description: FieldRef<"Position", 'String'>
    readonly status: FieldRef<"Position", 'String'>
    readonly createdAt: FieldRef<"Position", 'DateTime'>
    readonly updatedAt: FieldRef<"Position", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Position findUnique
   */
  export type PositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findUniqueOrThrow
   */
  export type PositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position findFirst
   */
  export type PositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position findFirstOrThrow
   */
  export type PositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Position to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Positions.
     */
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position findMany
   */
  export type PositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter, which Positions to fetch.
     */
    where?: PositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Positions to fetch.
     */
    orderBy?: PositionOrderByWithRelationInput | PositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Positions.
     */
    cursor?: PositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Positions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Positions.
     */
    skip?: number
    distinct?: PositionScalarFieldEnum | PositionScalarFieldEnum[]
  }

  /**
   * Position create
   */
  export type PositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The data needed to create a Position.
     */
    data: XOR<PositionCreateInput, PositionUncheckedCreateInput>
  }

  /**
   * Position createMany
   */
  export type PositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Positions.
     */
    data: PositionCreateManyInput | PositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Position createManyAndReturn
   */
  export type PositionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * The data used to create many Positions.
     */
    data: PositionCreateManyInput | PositionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Position update
   */
  export type PositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The data needed to update a Position.
     */
    data: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
    /**
     * Choose, which Position to update.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position updateMany
   */
  export type PositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Positions.
     */
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to update.
     */
    limit?: number
  }

  /**
   * Position updateManyAndReturn
   */
  export type PositionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * The data used to update Positions.
     */
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyInput>
    /**
     * Filter which Positions to update
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Position upsert
   */
  export type PositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * The filter to search for the Position to update in case it exists.
     */
    where: PositionWhereUniqueInput
    /**
     * In case the Position found by the `where` argument doesn't exist, create a new Position with this data.
     */
    create: XOR<PositionCreateInput, PositionUncheckedCreateInput>
    /**
     * In case the Position was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PositionUpdateInput, PositionUncheckedUpdateInput>
  }

  /**
   * Position delete
   */
  export type PositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    /**
     * Filter which Position to delete.
     */
    where: PositionWhereUniqueInput
  }

  /**
   * Position deleteMany
   */
  export type PositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Positions to delete
     */
    where?: PositionWhereInput
    /**
     * Limit how many Positions to delete.
     */
    limit?: number
  }

  /**
   * Position.employees
   */
  export type Position$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Position.employmentHistory
   */
  export type Position$employmentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentHistory
     */
    select?: EmploymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentHistory
     */
    omit?: EmploymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentHistoryInclude<ExtArgs> | null
    where?: EmploymentHistoryWhereInput
    orderBy?: EmploymentHistoryOrderByWithRelationInput | EmploymentHistoryOrderByWithRelationInput[]
    cursor?: EmploymentHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmploymentHistoryScalarFieldEnum | EmploymentHistoryScalarFieldEnum[]
  }

  /**
   * Position without action
   */
  export type PositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
  }


  /**
   * Model PositionLevel
   */

  export type AggregatePositionLevel = {
    _count: PositionLevelCountAggregateOutputType | null
    _avg: PositionLevelAvgAggregateOutputType | null
    _sum: PositionLevelSumAggregateOutputType | null
    _min: PositionLevelMinAggregateOutputType | null
    _max: PositionLevelMaxAggregateOutputType | null
  }

  export type PositionLevelAvgAggregateOutputType = {
    level: number | null
  }

  export type PositionLevelSumAggregateOutputType = {
    level: number | null
  }

  export type PositionLevelMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    level: number | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionLevelMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    level: number | null
    description: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PositionLevelCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    level: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PositionLevelAvgAggregateInputType = {
    level?: true
  }

  export type PositionLevelSumAggregateInputType = {
    level?: true
  }

  export type PositionLevelMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    level?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionLevelMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    level?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PositionLevelCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    level?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PositionLevelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PositionLevel to aggregate.
     */
    where?: PositionLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PositionLevels to fetch.
     */
    orderBy?: PositionLevelOrderByWithRelationInput | PositionLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PositionLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PositionLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PositionLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PositionLevels
    **/
    _count?: true | PositionLevelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PositionLevelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PositionLevelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PositionLevelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PositionLevelMaxAggregateInputType
  }

  export type GetPositionLevelAggregateType<T extends PositionLevelAggregateArgs> = {
        [P in keyof T & keyof AggregatePositionLevel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePositionLevel[P]>
      : GetScalarType<T[P], AggregatePositionLevel[P]>
  }




  export type PositionLevelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PositionLevelWhereInput
    orderBy?: PositionLevelOrderByWithAggregationInput | PositionLevelOrderByWithAggregationInput[]
    by: PositionLevelScalarFieldEnum[] | PositionLevelScalarFieldEnum
    having?: PositionLevelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PositionLevelCountAggregateInputType | true
    _avg?: PositionLevelAvgAggregateInputType
    _sum?: PositionLevelSumAggregateInputType
    _min?: PositionLevelMinAggregateInputType
    _max?: PositionLevelMaxAggregateInputType
  }

  export type PositionLevelGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    level: number
    description: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: PositionLevelCountAggregateOutputType | null
    _avg: PositionLevelAvgAggregateOutputType | null
    _sum: PositionLevelSumAggregateOutputType | null
    _min: PositionLevelMinAggregateOutputType | null
    _max: PositionLevelMaxAggregateOutputType | null
  }

  type GetPositionLevelGroupByPayload<T extends PositionLevelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PositionLevelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PositionLevelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PositionLevelGroupByOutputType[P]>
            : GetScalarType<T[P], PositionLevelGroupByOutputType[P]>
        }
      >
    >


  export type PositionLevelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    level?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employees?: boolean | PositionLevel$employeesArgs<ExtArgs>
    employmentHistory?: boolean | PositionLevel$employmentHistoryArgs<ExtArgs>
    _count?: boolean | PositionLevelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["positionLevel"]>

  export type PositionLevelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    level?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["positionLevel"]>

  export type PositionLevelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    level?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["positionLevel"]>

  export type PositionLevelSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    level?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PositionLevelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "level" | "description" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["positionLevel"]>
  export type PositionLevelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employees?: boolean | PositionLevel$employeesArgs<ExtArgs>
    employmentHistory?: boolean | PositionLevel$employmentHistoryArgs<ExtArgs>
    _count?: boolean | PositionLevelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PositionLevelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type PositionLevelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $PositionLevelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PositionLevel"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      employmentHistory: Prisma.$EmploymentHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      level: number
      description: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["positionLevel"]>
    composites: {}
  }

  type PositionLevelGetPayload<S extends boolean | null | undefined | PositionLevelDefaultArgs> = $Result.GetResult<Prisma.$PositionLevelPayload, S>

  type PositionLevelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PositionLevelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PositionLevelCountAggregateInputType | true
    }

  export interface PositionLevelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PositionLevel'], meta: { name: 'PositionLevel' } }
    /**
     * Find zero or one PositionLevel that matches the filter.
     * @param {PositionLevelFindUniqueArgs} args - Arguments to find a PositionLevel
     * @example
     * // Get one PositionLevel
     * const positionLevel = await prisma.positionLevel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PositionLevelFindUniqueArgs>(args: SelectSubset<T, PositionLevelFindUniqueArgs<ExtArgs>>): Prisma__PositionLevelClient<$Result.GetResult<Prisma.$PositionLevelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PositionLevel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PositionLevelFindUniqueOrThrowArgs} args - Arguments to find a PositionLevel
     * @example
     * // Get one PositionLevel
     * const positionLevel = await prisma.positionLevel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PositionLevelFindUniqueOrThrowArgs>(args: SelectSubset<T, PositionLevelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PositionLevelClient<$Result.GetResult<Prisma.$PositionLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PositionLevel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionLevelFindFirstArgs} args - Arguments to find a PositionLevel
     * @example
     * // Get one PositionLevel
     * const positionLevel = await prisma.positionLevel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PositionLevelFindFirstArgs>(args?: SelectSubset<T, PositionLevelFindFirstArgs<ExtArgs>>): Prisma__PositionLevelClient<$Result.GetResult<Prisma.$PositionLevelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PositionLevel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionLevelFindFirstOrThrowArgs} args - Arguments to find a PositionLevel
     * @example
     * // Get one PositionLevel
     * const positionLevel = await prisma.positionLevel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PositionLevelFindFirstOrThrowArgs>(args?: SelectSubset<T, PositionLevelFindFirstOrThrowArgs<ExtArgs>>): Prisma__PositionLevelClient<$Result.GetResult<Prisma.$PositionLevelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PositionLevels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionLevelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PositionLevels
     * const positionLevels = await prisma.positionLevel.findMany()
     * 
     * // Get first 10 PositionLevels
     * const positionLevels = await prisma.positionLevel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const positionLevelWithIdOnly = await prisma.positionLevel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PositionLevelFindManyArgs>(args?: SelectSubset<T, PositionLevelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionLevelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PositionLevel.
     * @param {PositionLevelCreateArgs} args - Arguments to create a PositionLevel.
     * @example
     * // Create one PositionLevel
     * const PositionLevel = await prisma.positionLevel.create({
     *   data: {
     *     // ... data to create a PositionLevel
     *   }
     * })
     * 
     */
    create<T extends PositionLevelCreateArgs>(args: SelectSubset<T, PositionLevelCreateArgs<ExtArgs>>): Prisma__PositionLevelClient<$Result.GetResult<Prisma.$PositionLevelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PositionLevels.
     * @param {PositionLevelCreateManyArgs} args - Arguments to create many PositionLevels.
     * @example
     * // Create many PositionLevels
     * const positionLevel = await prisma.positionLevel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PositionLevelCreateManyArgs>(args?: SelectSubset<T, PositionLevelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PositionLevels and returns the data saved in the database.
     * @param {PositionLevelCreateManyAndReturnArgs} args - Arguments to create many PositionLevels.
     * @example
     * // Create many PositionLevels
     * const positionLevel = await prisma.positionLevel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PositionLevels and only return the `id`
     * const positionLevelWithIdOnly = await prisma.positionLevel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PositionLevelCreateManyAndReturnArgs>(args?: SelectSubset<T, PositionLevelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionLevelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PositionLevel.
     * @param {PositionLevelDeleteArgs} args - Arguments to delete one PositionLevel.
     * @example
     * // Delete one PositionLevel
     * const PositionLevel = await prisma.positionLevel.delete({
     *   where: {
     *     // ... filter to delete one PositionLevel
     *   }
     * })
     * 
     */
    delete<T extends PositionLevelDeleteArgs>(args: SelectSubset<T, PositionLevelDeleteArgs<ExtArgs>>): Prisma__PositionLevelClient<$Result.GetResult<Prisma.$PositionLevelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PositionLevel.
     * @param {PositionLevelUpdateArgs} args - Arguments to update one PositionLevel.
     * @example
     * // Update one PositionLevel
     * const positionLevel = await prisma.positionLevel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PositionLevelUpdateArgs>(args: SelectSubset<T, PositionLevelUpdateArgs<ExtArgs>>): Prisma__PositionLevelClient<$Result.GetResult<Prisma.$PositionLevelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PositionLevels.
     * @param {PositionLevelDeleteManyArgs} args - Arguments to filter PositionLevels to delete.
     * @example
     * // Delete a few PositionLevels
     * const { count } = await prisma.positionLevel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PositionLevelDeleteManyArgs>(args?: SelectSubset<T, PositionLevelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PositionLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionLevelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PositionLevels
     * const positionLevel = await prisma.positionLevel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PositionLevelUpdateManyArgs>(args: SelectSubset<T, PositionLevelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PositionLevels and returns the data updated in the database.
     * @param {PositionLevelUpdateManyAndReturnArgs} args - Arguments to update many PositionLevels.
     * @example
     * // Update many PositionLevels
     * const positionLevel = await prisma.positionLevel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PositionLevels and only return the `id`
     * const positionLevelWithIdOnly = await prisma.positionLevel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PositionLevelUpdateManyAndReturnArgs>(args: SelectSubset<T, PositionLevelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PositionLevelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PositionLevel.
     * @param {PositionLevelUpsertArgs} args - Arguments to update or create a PositionLevel.
     * @example
     * // Update or create a PositionLevel
     * const positionLevel = await prisma.positionLevel.upsert({
     *   create: {
     *     // ... data to create a PositionLevel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PositionLevel we want to update
     *   }
     * })
     */
    upsert<T extends PositionLevelUpsertArgs>(args: SelectSubset<T, PositionLevelUpsertArgs<ExtArgs>>): Prisma__PositionLevelClient<$Result.GetResult<Prisma.$PositionLevelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PositionLevels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionLevelCountArgs} args - Arguments to filter PositionLevels to count.
     * @example
     * // Count the number of PositionLevels
     * const count = await prisma.positionLevel.count({
     *   where: {
     *     // ... the filter for the PositionLevels we want to count
     *   }
     * })
    **/
    count<T extends PositionLevelCountArgs>(
      args?: Subset<T, PositionLevelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PositionLevelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PositionLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionLevelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PositionLevelAggregateArgs>(args: Subset<T, PositionLevelAggregateArgs>): Prisma.PrismaPromise<GetPositionLevelAggregateType<T>>

    /**
     * Group by PositionLevel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PositionLevelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PositionLevelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PositionLevelGroupByArgs['orderBy'] }
        : { orderBy?: PositionLevelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PositionLevelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPositionLevelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PositionLevel model
   */
  readonly fields: PositionLevelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PositionLevel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PositionLevelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employees<T extends PositionLevel$employeesArgs<ExtArgs> = {}>(args?: Subset<T, PositionLevel$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employmentHistory<T extends PositionLevel$employmentHistoryArgs<ExtArgs> = {}>(args?: Subset<T, PositionLevel$employmentHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PositionLevel model
   */
  interface PositionLevelFieldRefs {
    readonly id: FieldRef<"PositionLevel", 'String'>
    readonly workspaceId: FieldRef<"PositionLevel", 'String'>
    readonly name: FieldRef<"PositionLevel", 'String'>
    readonly level: FieldRef<"PositionLevel", 'Int'>
    readonly description: FieldRef<"PositionLevel", 'String'>
    readonly status: FieldRef<"PositionLevel", 'String'>
    readonly createdAt: FieldRef<"PositionLevel", 'DateTime'>
    readonly updatedAt: FieldRef<"PositionLevel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PositionLevel findUnique
   */
  export type PositionLevelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionLevel
     */
    select?: PositionLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PositionLevel
     */
    omit?: PositionLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionLevelInclude<ExtArgs> | null
    /**
     * Filter, which PositionLevel to fetch.
     */
    where: PositionLevelWhereUniqueInput
  }

  /**
   * PositionLevel findUniqueOrThrow
   */
  export type PositionLevelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionLevel
     */
    select?: PositionLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PositionLevel
     */
    omit?: PositionLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionLevelInclude<ExtArgs> | null
    /**
     * Filter, which PositionLevel to fetch.
     */
    where: PositionLevelWhereUniqueInput
  }

  /**
   * PositionLevel findFirst
   */
  export type PositionLevelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionLevel
     */
    select?: PositionLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PositionLevel
     */
    omit?: PositionLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionLevelInclude<ExtArgs> | null
    /**
     * Filter, which PositionLevel to fetch.
     */
    where?: PositionLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PositionLevels to fetch.
     */
    orderBy?: PositionLevelOrderByWithRelationInput | PositionLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PositionLevels.
     */
    cursor?: PositionLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PositionLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PositionLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PositionLevels.
     */
    distinct?: PositionLevelScalarFieldEnum | PositionLevelScalarFieldEnum[]
  }

  /**
   * PositionLevel findFirstOrThrow
   */
  export type PositionLevelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionLevel
     */
    select?: PositionLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PositionLevel
     */
    omit?: PositionLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionLevelInclude<ExtArgs> | null
    /**
     * Filter, which PositionLevel to fetch.
     */
    where?: PositionLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PositionLevels to fetch.
     */
    orderBy?: PositionLevelOrderByWithRelationInput | PositionLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PositionLevels.
     */
    cursor?: PositionLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PositionLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PositionLevels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PositionLevels.
     */
    distinct?: PositionLevelScalarFieldEnum | PositionLevelScalarFieldEnum[]
  }

  /**
   * PositionLevel findMany
   */
  export type PositionLevelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionLevel
     */
    select?: PositionLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PositionLevel
     */
    omit?: PositionLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionLevelInclude<ExtArgs> | null
    /**
     * Filter, which PositionLevels to fetch.
     */
    where?: PositionLevelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PositionLevels to fetch.
     */
    orderBy?: PositionLevelOrderByWithRelationInput | PositionLevelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PositionLevels.
     */
    cursor?: PositionLevelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PositionLevels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PositionLevels.
     */
    skip?: number
    distinct?: PositionLevelScalarFieldEnum | PositionLevelScalarFieldEnum[]
  }

  /**
   * PositionLevel create
   */
  export type PositionLevelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionLevel
     */
    select?: PositionLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PositionLevel
     */
    omit?: PositionLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionLevelInclude<ExtArgs> | null
    /**
     * The data needed to create a PositionLevel.
     */
    data: XOR<PositionLevelCreateInput, PositionLevelUncheckedCreateInput>
  }

  /**
   * PositionLevel createMany
   */
  export type PositionLevelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PositionLevels.
     */
    data: PositionLevelCreateManyInput | PositionLevelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PositionLevel createManyAndReturn
   */
  export type PositionLevelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionLevel
     */
    select?: PositionLevelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PositionLevel
     */
    omit?: PositionLevelOmit<ExtArgs> | null
    /**
     * The data used to create many PositionLevels.
     */
    data: PositionLevelCreateManyInput | PositionLevelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionLevelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PositionLevel update
   */
  export type PositionLevelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionLevel
     */
    select?: PositionLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PositionLevel
     */
    omit?: PositionLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionLevelInclude<ExtArgs> | null
    /**
     * The data needed to update a PositionLevel.
     */
    data: XOR<PositionLevelUpdateInput, PositionLevelUncheckedUpdateInput>
    /**
     * Choose, which PositionLevel to update.
     */
    where: PositionLevelWhereUniqueInput
  }

  /**
   * PositionLevel updateMany
   */
  export type PositionLevelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PositionLevels.
     */
    data: XOR<PositionLevelUpdateManyMutationInput, PositionLevelUncheckedUpdateManyInput>
    /**
     * Filter which PositionLevels to update
     */
    where?: PositionLevelWhereInput
    /**
     * Limit how many PositionLevels to update.
     */
    limit?: number
  }

  /**
   * PositionLevel updateManyAndReturn
   */
  export type PositionLevelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionLevel
     */
    select?: PositionLevelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PositionLevel
     */
    omit?: PositionLevelOmit<ExtArgs> | null
    /**
     * The data used to update PositionLevels.
     */
    data: XOR<PositionLevelUpdateManyMutationInput, PositionLevelUncheckedUpdateManyInput>
    /**
     * Filter which PositionLevels to update
     */
    where?: PositionLevelWhereInput
    /**
     * Limit how many PositionLevels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionLevelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PositionLevel upsert
   */
  export type PositionLevelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionLevel
     */
    select?: PositionLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PositionLevel
     */
    omit?: PositionLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionLevelInclude<ExtArgs> | null
    /**
     * The filter to search for the PositionLevel to update in case it exists.
     */
    where: PositionLevelWhereUniqueInput
    /**
     * In case the PositionLevel found by the `where` argument doesn't exist, create a new PositionLevel with this data.
     */
    create: XOR<PositionLevelCreateInput, PositionLevelUncheckedCreateInput>
    /**
     * In case the PositionLevel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PositionLevelUpdateInput, PositionLevelUncheckedUpdateInput>
  }

  /**
   * PositionLevel delete
   */
  export type PositionLevelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionLevel
     */
    select?: PositionLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PositionLevel
     */
    omit?: PositionLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionLevelInclude<ExtArgs> | null
    /**
     * Filter which PositionLevel to delete.
     */
    where: PositionLevelWhereUniqueInput
  }

  /**
   * PositionLevel deleteMany
   */
  export type PositionLevelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PositionLevels to delete
     */
    where?: PositionLevelWhereInput
    /**
     * Limit how many PositionLevels to delete.
     */
    limit?: number
  }

  /**
   * PositionLevel.employees
   */
  export type PositionLevel$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * PositionLevel.employmentHistory
   */
  export type PositionLevel$employmentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentHistory
     */
    select?: EmploymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentHistory
     */
    omit?: EmploymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentHistoryInclude<ExtArgs> | null
    where?: EmploymentHistoryWhereInput
    orderBy?: EmploymentHistoryOrderByWithRelationInput | EmploymentHistoryOrderByWithRelationInput[]
    cursor?: EmploymentHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmploymentHistoryScalarFieldEnum | EmploymentHistoryScalarFieldEnum[]
  }

  /**
   * PositionLevel without action
   */
  export type PositionLevelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionLevel
     */
    select?: PositionLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PositionLevel
     */
    omit?: PositionLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionLevelInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    employeeCode: string | null
    firstName: string | null
    lastName: string | null
    thaiFirstName: string | null
    thaiLastName: string | null
    nickname: string | null
    email: string | null
    phone: string | null
    emergencyContact: string | null
    birthdate: Date | null
    gender: string | null
    nationalId: string | null
    nationalIdIv: string | null
    passportNumber: string | null
    passportNumberIv: string | null
    address: string | null
    taxId: string | null
    bankAccount: string | null
    bankAccountIv: string | null
    bankName: string | null
    hireDate: Date | null
    probationEndDate: Date | null
    resignDate: Date | null
    departmentId: string | null
    teamId: string | null
    positionId: string | null
    positionLevelId: string | null
    managerId: string | null
    status: $Enums.EmployeeStatus | null
    employmentType: $Enums.EmploymentType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    employeeCode: string | null
    firstName: string | null
    lastName: string | null
    thaiFirstName: string | null
    thaiLastName: string | null
    nickname: string | null
    email: string | null
    phone: string | null
    emergencyContact: string | null
    birthdate: Date | null
    gender: string | null
    nationalId: string | null
    nationalIdIv: string | null
    passportNumber: string | null
    passportNumberIv: string | null
    address: string | null
    taxId: string | null
    bankAccount: string | null
    bankAccountIv: string | null
    bankName: string | null
    hireDate: Date | null
    probationEndDate: Date | null
    resignDate: Date | null
    departmentId: string | null
    teamId: string | null
    positionId: string | null
    positionLevelId: string | null
    managerId: string | null
    status: $Enums.EmployeeStatus | null
    employmentType: $Enums.EmploymentType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    workspaceId: number
    userId: number
    employeeCode: number
    firstName: number
    lastName: number
    thaiFirstName: number
    thaiLastName: number
    nickname: number
    email: number
    phone: number
    emergencyContact: number
    birthdate: number
    gender: number
    nationalId: number
    nationalIdIv: number
    passportNumber: number
    passportNumberIv: number
    address: number
    taxId: number
    bankAccount: number
    bankAccountIv: number
    bankName: number
    hireDate: number
    probationEndDate: number
    resignDate: number
    departmentId: number
    teamId: number
    positionId: number
    positionLevelId: number
    managerId: number
    status: number
    employmentType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    employeeCode?: true
    firstName?: true
    lastName?: true
    thaiFirstName?: true
    thaiLastName?: true
    nickname?: true
    email?: true
    phone?: true
    emergencyContact?: true
    birthdate?: true
    gender?: true
    nationalId?: true
    nationalIdIv?: true
    passportNumber?: true
    passportNumberIv?: true
    address?: true
    taxId?: true
    bankAccount?: true
    bankAccountIv?: true
    bankName?: true
    hireDate?: true
    probationEndDate?: true
    resignDate?: true
    departmentId?: true
    teamId?: true
    positionId?: true
    positionLevelId?: true
    managerId?: true
    status?: true
    employmentType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    employeeCode?: true
    firstName?: true
    lastName?: true
    thaiFirstName?: true
    thaiLastName?: true
    nickname?: true
    email?: true
    phone?: true
    emergencyContact?: true
    birthdate?: true
    gender?: true
    nationalId?: true
    nationalIdIv?: true
    passportNumber?: true
    passportNumberIv?: true
    address?: true
    taxId?: true
    bankAccount?: true
    bankAccountIv?: true
    bankName?: true
    hireDate?: true
    probationEndDate?: true
    resignDate?: true
    departmentId?: true
    teamId?: true
    positionId?: true
    positionLevelId?: true
    managerId?: true
    status?: true
    employmentType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    employeeCode?: true
    firstName?: true
    lastName?: true
    thaiFirstName?: true
    thaiLastName?: true
    nickname?: true
    email?: true
    phone?: true
    emergencyContact?: true
    birthdate?: true
    gender?: true
    nationalId?: true
    nationalIdIv?: true
    passportNumber?: true
    passportNumberIv?: true
    address?: true
    taxId?: true
    bankAccount?: true
    bankAccountIv?: true
    bankName?: true
    hireDate?: true
    probationEndDate?: true
    resignDate?: true
    departmentId?: true
    teamId?: true
    positionId?: true
    positionLevelId?: true
    managerId?: true
    status?: true
    employmentType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    workspaceId: string
    userId: string | null
    employeeCode: string | null
    firstName: string
    lastName: string
    thaiFirstName: string | null
    thaiLastName: string | null
    nickname: string | null
    email: string
    phone: string | null
    emergencyContact: string | null
    birthdate: Date | null
    gender: string | null
    nationalId: string | null
    nationalIdIv: string | null
    passportNumber: string | null
    passportNumberIv: string | null
    address: string | null
    taxId: string | null
    bankAccount: string | null
    bankAccountIv: string | null
    bankName: string | null
    hireDate: Date
    probationEndDate: Date | null
    resignDate: Date | null
    departmentId: string | null
    teamId: string | null
    positionId: string | null
    positionLevelId: string | null
    managerId: string | null
    status: $Enums.EmployeeStatus
    employmentType: $Enums.EmploymentType
    createdAt: Date
    updatedAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    employeeCode?: boolean
    firstName?: boolean
    lastName?: boolean
    thaiFirstName?: boolean
    thaiLastName?: boolean
    nickname?: boolean
    email?: boolean
    phone?: boolean
    emergencyContact?: boolean
    birthdate?: boolean
    gender?: boolean
    nationalId?: boolean
    nationalIdIv?: boolean
    passportNumber?: boolean
    passportNumberIv?: boolean
    address?: boolean
    taxId?: boolean
    bankAccount?: boolean
    bankAccountIv?: boolean
    bankName?: boolean
    hireDate?: boolean
    probationEndDate?: boolean
    resignDate?: boolean
    departmentId?: boolean
    teamId?: boolean
    positionId?: boolean
    positionLevelId?: boolean
    managerId?: boolean
    status?: boolean
    employmentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Employee$userArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    department?: boolean | Employee$departmentArgs<ExtArgs>
    team?: boolean | Employee$teamArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    positionLevel?: boolean | Employee$positionLevelArgs<ExtArgs>
    manager?: boolean | Employee$managerArgs<ExtArgs>
    subordinates?: boolean | Employee$subordinatesArgs<ExtArgs>
    projectMembers?: boolean | Employee$projectMembersArgs<ExtArgs>
    employmentHistory?: boolean | Employee$employmentHistoryArgs<ExtArgs>
    documents?: boolean | Employee$documentsArgs<ExtArgs>
    leaveQuotas?: boolean | Employee$leaveQuotasArgs<ExtArgs>
    leaves?: boolean | Employee$leavesArgs<ExtArgs>
    overtimes?: boolean | Employee$overtimesArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    employeeCode?: boolean
    firstName?: boolean
    lastName?: boolean
    thaiFirstName?: boolean
    thaiLastName?: boolean
    nickname?: boolean
    email?: boolean
    phone?: boolean
    emergencyContact?: boolean
    birthdate?: boolean
    gender?: boolean
    nationalId?: boolean
    nationalIdIv?: boolean
    passportNumber?: boolean
    passportNumberIv?: boolean
    address?: boolean
    taxId?: boolean
    bankAccount?: boolean
    bankAccountIv?: boolean
    bankName?: boolean
    hireDate?: boolean
    probationEndDate?: boolean
    resignDate?: boolean
    departmentId?: boolean
    teamId?: boolean
    positionId?: boolean
    positionLevelId?: boolean
    managerId?: boolean
    status?: boolean
    employmentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Employee$userArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    department?: boolean | Employee$departmentArgs<ExtArgs>
    team?: boolean | Employee$teamArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    positionLevel?: boolean | Employee$positionLevelArgs<ExtArgs>
    manager?: boolean | Employee$managerArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    employeeCode?: boolean
    firstName?: boolean
    lastName?: boolean
    thaiFirstName?: boolean
    thaiLastName?: boolean
    nickname?: boolean
    email?: boolean
    phone?: boolean
    emergencyContact?: boolean
    birthdate?: boolean
    gender?: boolean
    nationalId?: boolean
    nationalIdIv?: boolean
    passportNumber?: boolean
    passportNumberIv?: boolean
    address?: boolean
    taxId?: boolean
    bankAccount?: boolean
    bankAccountIv?: boolean
    bankName?: boolean
    hireDate?: boolean
    probationEndDate?: boolean
    resignDate?: boolean
    departmentId?: boolean
    teamId?: boolean
    positionId?: boolean
    positionLevelId?: boolean
    managerId?: boolean
    status?: boolean
    employmentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Employee$userArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    department?: boolean | Employee$departmentArgs<ExtArgs>
    team?: boolean | Employee$teamArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    positionLevel?: boolean | Employee$positionLevelArgs<ExtArgs>
    manager?: boolean | Employee$managerArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    employeeCode?: boolean
    firstName?: boolean
    lastName?: boolean
    thaiFirstName?: boolean
    thaiLastName?: boolean
    nickname?: boolean
    email?: boolean
    phone?: boolean
    emergencyContact?: boolean
    birthdate?: boolean
    gender?: boolean
    nationalId?: boolean
    nationalIdIv?: boolean
    passportNumber?: boolean
    passportNumberIv?: boolean
    address?: boolean
    taxId?: boolean
    bankAccount?: boolean
    bankAccountIv?: boolean
    bankName?: boolean
    hireDate?: boolean
    probationEndDate?: boolean
    resignDate?: boolean
    departmentId?: boolean
    teamId?: boolean
    positionId?: boolean
    positionLevelId?: boolean
    managerId?: boolean
    status?: boolean
    employmentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "userId" | "employeeCode" | "firstName" | "lastName" | "thaiFirstName" | "thaiLastName" | "nickname" | "email" | "phone" | "emergencyContact" | "birthdate" | "gender" | "nationalId" | "nationalIdIv" | "passportNumber" | "passportNumberIv" | "address" | "taxId" | "bankAccount" | "bankAccountIv" | "bankName" | "hireDate" | "probationEndDate" | "resignDate" | "departmentId" | "teamId" | "positionId" | "positionLevelId" | "managerId" | "status" | "employmentType" | "createdAt" | "updatedAt", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Employee$userArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    department?: boolean | Employee$departmentArgs<ExtArgs>
    team?: boolean | Employee$teamArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    positionLevel?: boolean | Employee$positionLevelArgs<ExtArgs>
    manager?: boolean | Employee$managerArgs<ExtArgs>
    subordinates?: boolean | Employee$subordinatesArgs<ExtArgs>
    projectMembers?: boolean | Employee$projectMembersArgs<ExtArgs>
    employmentHistory?: boolean | Employee$employmentHistoryArgs<ExtArgs>
    documents?: boolean | Employee$documentsArgs<ExtArgs>
    leaveQuotas?: boolean | Employee$leaveQuotasArgs<ExtArgs>
    leaves?: boolean | Employee$leavesArgs<ExtArgs>
    overtimes?: boolean | Employee$overtimesArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Employee$userArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    department?: boolean | Employee$departmentArgs<ExtArgs>
    team?: boolean | Employee$teamArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    positionLevel?: boolean | Employee$positionLevelArgs<ExtArgs>
    manager?: boolean | Employee$managerArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Employee$userArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    department?: boolean | Employee$departmentArgs<ExtArgs>
    team?: boolean | Employee$teamArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    positionLevel?: boolean | Employee$positionLevelArgs<ExtArgs>
    manager?: boolean | Employee$managerArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      team: Prisma.$TeamPayload<ExtArgs> | null
      position: Prisma.$PositionPayload<ExtArgs> | null
      positionLevel: Prisma.$PositionLevelPayload<ExtArgs> | null
      manager: Prisma.$EmployeePayload<ExtArgs> | null
      subordinates: Prisma.$EmployeePayload<ExtArgs>[]
      projectMembers: Prisma.$ProjectMemberPayload<ExtArgs>[]
      employmentHistory: Prisma.$EmploymentHistoryPayload<ExtArgs>[]
      documents: Prisma.$EmployeeDocumentPayload<ExtArgs>[]
      leaveQuotas: Prisma.$LeaveQuotaPayload<ExtArgs>[]
      leaves: Prisma.$LeavePayload<ExtArgs>[]
      overtimes: Prisma.$OvertimePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      userId: string | null
      employeeCode: string | null
      firstName: string
      lastName: string
      thaiFirstName: string | null
      thaiLastName: string | null
      nickname: string | null
      email: string
      phone: string | null
      emergencyContact: string | null
      birthdate: Date | null
      gender: string | null
      nationalId: string | null
      nationalIdIv: string | null
      passportNumber: string | null
      passportNumberIv: string | null
      address: string | null
      taxId: string | null
      bankAccount: string | null
      bankAccountIv: string | null
      bankName: string | null
      hireDate: Date
      probationEndDate: Date | null
      resignDate: Date | null
      departmentId: string | null
      teamId: string | null
      positionId: string | null
      positionLevelId: string | null
      managerId: string | null
      status: $Enums.EmployeeStatus
      employmentType: $Enums.EmploymentType
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Employee$userArgs<ExtArgs> = {}>(args?: Subset<T, Employee$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    department<T extends Employee$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Employee$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    team<T extends Employee$teamArgs<ExtArgs> = {}>(args?: Subset<T, Employee$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    position<T extends Employee$positionArgs<ExtArgs> = {}>(args?: Subset<T, Employee$positionArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    positionLevel<T extends Employee$positionLevelArgs<ExtArgs> = {}>(args?: Subset<T, Employee$positionLevelArgs<ExtArgs>>): Prisma__PositionLevelClient<$Result.GetResult<Prisma.$PositionLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    manager<T extends Employee$managerArgs<ExtArgs> = {}>(args?: Subset<T, Employee$managerArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    subordinates<T extends Employee$subordinatesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$subordinatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectMembers<T extends Employee$projectMembersArgs<ExtArgs> = {}>(args?: Subset<T, Employee$projectMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employmentHistory<T extends Employee$employmentHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Employee$employmentHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Employee$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaveQuotas<T extends Employee$leaveQuotasArgs<ExtArgs> = {}>(args?: Subset<T, Employee$leaveQuotasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveQuotaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaves<T extends Employee$leavesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$leavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    overtimes<T extends Employee$overtimesArgs<ExtArgs> = {}>(args?: Subset<T, Employee$overtimesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly workspaceId: FieldRef<"Employee", 'String'>
    readonly userId: FieldRef<"Employee", 'String'>
    readonly employeeCode: FieldRef<"Employee", 'String'>
    readonly firstName: FieldRef<"Employee", 'String'>
    readonly lastName: FieldRef<"Employee", 'String'>
    readonly thaiFirstName: FieldRef<"Employee", 'String'>
    readonly thaiLastName: FieldRef<"Employee", 'String'>
    readonly nickname: FieldRef<"Employee", 'String'>
    readonly email: FieldRef<"Employee", 'String'>
    readonly phone: FieldRef<"Employee", 'String'>
    readonly emergencyContact: FieldRef<"Employee", 'String'>
    readonly birthdate: FieldRef<"Employee", 'DateTime'>
    readonly gender: FieldRef<"Employee", 'String'>
    readonly nationalId: FieldRef<"Employee", 'String'>
    readonly nationalIdIv: FieldRef<"Employee", 'String'>
    readonly passportNumber: FieldRef<"Employee", 'String'>
    readonly passportNumberIv: FieldRef<"Employee", 'String'>
    readonly address: FieldRef<"Employee", 'String'>
    readonly taxId: FieldRef<"Employee", 'String'>
    readonly bankAccount: FieldRef<"Employee", 'String'>
    readonly bankAccountIv: FieldRef<"Employee", 'String'>
    readonly bankName: FieldRef<"Employee", 'String'>
    readonly hireDate: FieldRef<"Employee", 'DateTime'>
    readonly probationEndDate: FieldRef<"Employee", 'DateTime'>
    readonly resignDate: FieldRef<"Employee", 'DateTime'>
    readonly departmentId: FieldRef<"Employee", 'String'>
    readonly teamId: FieldRef<"Employee", 'String'>
    readonly positionId: FieldRef<"Employee", 'String'>
    readonly positionLevelId: FieldRef<"Employee", 'String'>
    readonly managerId: FieldRef<"Employee", 'String'>
    readonly status: FieldRef<"Employee", 'EmployeeStatus'>
    readonly employmentType: FieldRef<"Employee", 'EmploymentType'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.user
   */
  export type Employee$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Employee.department
   */
  export type Employee$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Employee.team
   */
  export type Employee$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Team
     */
    omit?: TeamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * Employee.position
   */
  export type Employee$positionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Position
     */
    select?: PositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Position
     */
    omit?: PositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionInclude<ExtArgs> | null
    where?: PositionWhereInput
  }

  /**
   * Employee.positionLevel
   */
  export type Employee$positionLevelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionLevel
     */
    select?: PositionLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PositionLevel
     */
    omit?: PositionLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionLevelInclude<ExtArgs> | null
    where?: PositionLevelWhereInput
  }

  /**
   * Employee.manager
   */
  export type Employee$managerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * Employee.subordinates
   */
  export type Employee$subordinatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee.projectMembers
   */
  export type Employee$projectMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * Employee.employmentHistory
   */
  export type Employee$employmentHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentHistory
     */
    select?: EmploymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentHistory
     */
    omit?: EmploymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentHistoryInclude<ExtArgs> | null
    where?: EmploymentHistoryWhereInput
    orderBy?: EmploymentHistoryOrderByWithRelationInput | EmploymentHistoryOrderByWithRelationInput[]
    cursor?: EmploymentHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmploymentHistoryScalarFieldEnum | EmploymentHistoryScalarFieldEnum[]
  }

  /**
   * Employee.documents
   */
  export type Employee$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    where?: EmployeeDocumentWhereInput
    orderBy?: EmployeeDocumentOrderByWithRelationInput | EmployeeDocumentOrderByWithRelationInput[]
    cursor?: EmployeeDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeDocumentScalarFieldEnum | EmployeeDocumentScalarFieldEnum[]
  }

  /**
   * Employee.leaveQuotas
   */
  export type Employee$leaveQuotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveQuota
     */
    select?: LeaveQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveQuota
     */
    omit?: LeaveQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveQuotaInclude<ExtArgs> | null
    where?: LeaveQuotaWhereInput
    orderBy?: LeaveQuotaOrderByWithRelationInput | LeaveQuotaOrderByWithRelationInput[]
    cursor?: LeaveQuotaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveQuotaScalarFieldEnum | LeaveQuotaScalarFieldEnum[]
  }

  /**
   * Employee.leaves
   */
  export type Employee$leavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    cursor?: LeaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Employee.overtimes
   */
  export type Employee$overtimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    where?: OvertimeWhereInput
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    cursor?: OvertimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OvertimeScalarFieldEnum | OvertimeScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model EmploymentHistory
   */

  export type AggregateEmploymentHistory = {
    _count: EmploymentHistoryCountAggregateOutputType | null
    _avg: EmploymentHistoryAvgAggregateOutputType | null
    _sum: EmploymentHistorySumAggregateOutputType | null
    _min: EmploymentHistoryMinAggregateOutputType | null
    _max: EmploymentHistoryMaxAggregateOutputType | null
  }

  export type EmploymentHistoryAvgAggregateOutputType = {
    salary: Decimal | null
  }

  export type EmploymentHistorySumAggregateOutputType = {
    salary: Decimal | null
  }

  export type EmploymentHistoryMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    positionId: string | null
    positionLevelId: string | null
    departmentId: string | null
    startDate: Date | null
    endDate: Date | null
    salary: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmploymentHistoryMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    positionId: string | null
    positionLevelId: string | null
    departmentId: string | null
    startDate: Date | null
    endDate: Date | null
    salary: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmploymentHistoryCountAggregateOutputType = {
    id: number
    employeeId: number
    positionId: number
    positionLevelId: number
    departmentId: number
    startDate: number
    endDate: number
    salary: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmploymentHistoryAvgAggregateInputType = {
    salary?: true
  }

  export type EmploymentHistorySumAggregateInputType = {
    salary?: true
  }

  export type EmploymentHistoryMinAggregateInputType = {
    id?: true
    employeeId?: true
    positionId?: true
    positionLevelId?: true
    departmentId?: true
    startDate?: true
    endDate?: true
    salary?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmploymentHistoryMaxAggregateInputType = {
    id?: true
    employeeId?: true
    positionId?: true
    positionLevelId?: true
    departmentId?: true
    startDate?: true
    endDate?: true
    salary?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmploymentHistoryCountAggregateInputType = {
    id?: true
    employeeId?: true
    positionId?: true
    positionLevelId?: true
    departmentId?: true
    startDate?: true
    endDate?: true
    salary?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmploymentHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmploymentHistory to aggregate.
     */
    where?: EmploymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentHistories to fetch.
     */
    orderBy?: EmploymentHistoryOrderByWithRelationInput | EmploymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmploymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmploymentHistories
    **/
    _count?: true | EmploymentHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmploymentHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmploymentHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmploymentHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmploymentHistoryMaxAggregateInputType
  }

  export type GetEmploymentHistoryAggregateType<T extends EmploymentHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateEmploymentHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmploymentHistory[P]>
      : GetScalarType<T[P], AggregateEmploymentHistory[P]>
  }




  export type EmploymentHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploymentHistoryWhereInput
    orderBy?: EmploymentHistoryOrderByWithAggregationInput | EmploymentHistoryOrderByWithAggregationInput[]
    by: EmploymentHistoryScalarFieldEnum[] | EmploymentHistoryScalarFieldEnum
    having?: EmploymentHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmploymentHistoryCountAggregateInputType | true
    _avg?: EmploymentHistoryAvgAggregateInputType
    _sum?: EmploymentHistorySumAggregateInputType
    _min?: EmploymentHistoryMinAggregateInputType
    _max?: EmploymentHistoryMaxAggregateInputType
  }

  export type EmploymentHistoryGroupByOutputType = {
    id: string
    employeeId: string
    positionId: string
    positionLevelId: string | null
    departmentId: string | null
    startDate: Date
    endDate: Date | null
    salary: Decimal | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmploymentHistoryCountAggregateOutputType | null
    _avg: EmploymentHistoryAvgAggregateOutputType | null
    _sum: EmploymentHistorySumAggregateOutputType | null
    _min: EmploymentHistoryMinAggregateOutputType | null
    _max: EmploymentHistoryMaxAggregateOutputType | null
  }

  type GetEmploymentHistoryGroupByPayload<T extends EmploymentHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmploymentHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmploymentHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmploymentHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], EmploymentHistoryGroupByOutputType[P]>
        }
      >
    >


  export type EmploymentHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    positionId?: boolean
    positionLevelId?: boolean
    departmentId?: boolean
    startDate?: boolean
    endDate?: boolean
    salary?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
    positionLevel?: boolean | EmploymentHistory$positionLevelArgs<ExtArgs>
  }, ExtArgs["result"]["employmentHistory"]>

  export type EmploymentHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    positionId?: boolean
    positionLevelId?: boolean
    departmentId?: boolean
    startDate?: boolean
    endDate?: boolean
    salary?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
    positionLevel?: boolean | EmploymentHistory$positionLevelArgs<ExtArgs>
  }, ExtArgs["result"]["employmentHistory"]>

  export type EmploymentHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    positionId?: boolean
    positionLevelId?: boolean
    departmentId?: boolean
    startDate?: boolean
    endDate?: boolean
    salary?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
    positionLevel?: boolean | EmploymentHistory$positionLevelArgs<ExtArgs>
  }, ExtArgs["result"]["employmentHistory"]>

  export type EmploymentHistorySelectScalar = {
    id?: boolean
    employeeId?: boolean
    positionId?: boolean
    positionLevelId?: boolean
    departmentId?: boolean
    startDate?: boolean
    endDate?: boolean
    salary?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmploymentHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "positionId" | "positionLevelId" | "departmentId" | "startDate" | "endDate" | "salary" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["employmentHistory"]>
  export type EmploymentHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
    positionLevel?: boolean | EmploymentHistory$positionLevelArgs<ExtArgs>
  }
  export type EmploymentHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
    positionLevel?: boolean | EmploymentHistory$positionLevelArgs<ExtArgs>
  }
  export type EmploymentHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    position?: boolean | PositionDefaultArgs<ExtArgs>
    positionLevel?: boolean | EmploymentHistory$positionLevelArgs<ExtArgs>
  }

  export type $EmploymentHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmploymentHistory"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      position: Prisma.$PositionPayload<ExtArgs>
      positionLevel: Prisma.$PositionLevelPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      positionId: string
      positionLevelId: string | null
      departmentId: string | null
      startDate: Date
      endDate: Date | null
      salary: Prisma.Decimal | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employmentHistory"]>
    composites: {}
  }

  type EmploymentHistoryGetPayload<S extends boolean | null | undefined | EmploymentHistoryDefaultArgs> = $Result.GetResult<Prisma.$EmploymentHistoryPayload, S>

  type EmploymentHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmploymentHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmploymentHistoryCountAggregateInputType | true
    }

  export interface EmploymentHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmploymentHistory'], meta: { name: 'EmploymentHistory' } }
    /**
     * Find zero or one EmploymentHistory that matches the filter.
     * @param {EmploymentHistoryFindUniqueArgs} args - Arguments to find a EmploymentHistory
     * @example
     * // Get one EmploymentHistory
     * const employmentHistory = await prisma.employmentHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmploymentHistoryFindUniqueArgs>(args: SelectSubset<T, EmploymentHistoryFindUniqueArgs<ExtArgs>>): Prisma__EmploymentHistoryClient<$Result.GetResult<Prisma.$EmploymentHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmploymentHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmploymentHistoryFindUniqueOrThrowArgs} args - Arguments to find a EmploymentHistory
     * @example
     * // Get one EmploymentHistory
     * const employmentHistory = await prisma.employmentHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmploymentHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, EmploymentHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmploymentHistoryClient<$Result.GetResult<Prisma.$EmploymentHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmploymentHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentHistoryFindFirstArgs} args - Arguments to find a EmploymentHistory
     * @example
     * // Get one EmploymentHistory
     * const employmentHistory = await prisma.employmentHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmploymentHistoryFindFirstArgs>(args?: SelectSubset<T, EmploymentHistoryFindFirstArgs<ExtArgs>>): Prisma__EmploymentHistoryClient<$Result.GetResult<Prisma.$EmploymentHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmploymentHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentHistoryFindFirstOrThrowArgs} args - Arguments to find a EmploymentHistory
     * @example
     * // Get one EmploymentHistory
     * const employmentHistory = await prisma.employmentHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmploymentHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, EmploymentHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmploymentHistoryClient<$Result.GetResult<Prisma.$EmploymentHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmploymentHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmploymentHistories
     * const employmentHistories = await prisma.employmentHistory.findMany()
     * 
     * // Get first 10 EmploymentHistories
     * const employmentHistories = await prisma.employmentHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employmentHistoryWithIdOnly = await prisma.employmentHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmploymentHistoryFindManyArgs>(args?: SelectSubset<T, EmploymentHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmploymentHistory.
     * @param {EmploymentHistoryCreateArgs} args - Arguments to create a EmploymentHistory.
     * @example
     * // Create one EmploymentHistory
     * const EmploymentHistory = await prisma.employmentHistory.create({
     *   data: {
     *     // ... data to create a EmploymentHistory
     *   }
     * })
     * 
     */
    create<T extends EmploymentHistoryCreateArgs>(args: SelectSubset<T, EmploymentHistoryCreateArgs<ExtArgs>>): Prisma__EmploymentHistoryClient<$Result.GetResult<Prisma.$EmploymentHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmploymentHistories.
     * @param {EmploymentHistoryCreateManyArgs} args - Arguments to create many EmploymentHistories.
     * @example
     * // Create many EmploymentHistories
     * const employmentHistory = await prisma.employmentHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmploymentHistoryCreateManyArgs>(args?: SelectSubset<T, EmploymentHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmploymentHistories and returns the data saved in the database.
     * @param {EmploymentHistoryCreateManyAndReturnArgs} args - Arguments to create many EmploymentHistories.
     * @example
     * // Create many EmploymentHistories
     * const employmentHistory = await prisma.employmentHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmploymentHistories and only return the `id`
     * const employmentHistoryWithIdOnly = await prisma.employmentHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmploymentHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, EmploymentHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmploymentHistory.
     * @param {EmploymentHistoryDeleteArgs} args - Arguments to delete one EmploymentHistory.
     * @example
     * // Delete one EmploymentHistory
     * const EmploymentHistory = await prisma.employmentHistory.delete({
     *   where: {
     *     // ... filter to delete one EmploymentHistory
     *   }
     * })
     * 
     */
    delete<T extends EmploymentHistoryDeleteArgs>(args: SelectSubset<T, EmploymentHistoryDeleteArgs<ExtArgs>>): Prisma__EmploymentHistoryClient<$Result.GetResult<Prisma.$EmploymentHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmploymentHistory.
     * @param {EmploymentHistoryUpdateArgs} args - Arguments to update one EmploymentHistory.
     * @example
     * // Update one EmploymentHistory
     * const employmentHistory = await prisma.employmentHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmploymentHistoryUpdateArgs>(args: SelectSubset<T, EmploymentHistoryUpdateArgs<ExtArgs>>): Prisma__EmploymentHistoryClient<$Result.GetResult<Prisma.$EmploymentHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmploymentHistories.
     * @param {EmploymentHistoryDeleteManyArgs} args - Arguments to filter EmploymentHistories to delete.
     * @example
     * // Delete a few EmploymentHistories
     * const { count } = await prisma.employmentHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmploymentHistoryDeleteManyArgs>(args?: SelectSubset<T, EmploymentHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmploymentHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmploymentHistories
     * const employmentHistory = await prisma.employmentHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmploymentHistoryUpdateManyArgs>(args: SelectSubset<T, EmploymentHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmploymentHistories and returns the data updated in the database.
     * @param {EmploymentHistoryUpdateManyAndReturnArgs} args - Arguments to update many EmploymentHistories.
     * @example
     * // Update many EmploymentHistories
     * const employmentHistory = await prisma.employmentHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmploymentHistories and only return the `id`
     * const employmentHistoryWithIdOnly = await prisma.employmentHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmploymentHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, EmploymentHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmploymentHistory.
     * @param {EmploymentHistoryUpsertArgs} args - Arguments to update or create a EmploymentHistory.
     * @example
     * // Update or create a EmploymentHistory
     * const employmentHistory = await prisma.employmentHistory.upsert({
     *   create: {
     *     // ... data to create a EmploymentHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmploymentHistory we want to update
     *   }
     * })
     */
    upsert<T extends EmploymentHistoryUpsertArgs>(args: SelectSubset<T, EmploymentHistoryUpsertArgs<ExtArgs>>): Prisma__EmploymentHistoryClient<$Result.GetResult<Prisma.$EmploymentHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmploymentHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentHistoryCountArgs} args - Arguments to filter EmploymentHistories to count.
     * @example
     * // Count the number of EmploymentHistories
     * const count = await prisma.employmentHistory.count({
     *   where: {
     *     // ... the filter for the EmploymentHistories we want to count
     *   }
     * })
    **/
    count<T extends EmploymentHistoryCountArgs>(
      args?: Subset<T, EmploymentHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmploymentHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmploymentHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmploymentHistoryAggregateArgs>(args: Subset<T, EmploymentHistoryAggregateArgs>): Prisma.PrismaPromise<GetEmploymentHistoryAggregateType<T>>

    /**
     * Group by EmploymentHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmploymentHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmploymentHistoryGroupByArgs['orderBy'] }
        : { orderBy?: EmploymentHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmploymentHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmploymentHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmploymentHistory model
   */
  readonly fields: EmploymentHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmploymentHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmploymentHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    position<T extends PositionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PositionDefaultArgs<ExtArgs>>): Prisma__PositionClient<$Result.GetResult<Prisma.$PositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    positionLevel<T extends EmploymentHistory$positionLevelArgs<ExtArgs> = {}>(args?: Subset<T, EmploymentHistory$positionLevelArgs<ExtArgs>>): Prisma__PositionLevelClient<$Result.GetResult<Prisma.$PositionLevelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmploymentHistory model
   */
  interface EmploymentHistoryFieldRefs {
    readonly id: FieldRef<"EmploymentHistory", 'String'>
    readonly employeeId: FieldRef<"EmploymentHistory", 'String'>
    readonly positionId: FieldRef<"EmploymentHistory", 'String'>
    readonly positionLevelId: FieldRef<"EmploymentHistory", 'String'>
    readonly departmentId: FieldRef<"EmploymentHistory", 'String'>
    readonly startDate: FieldRef<"EmploymentHistory", 'DateTime'>
    readonly endDate: FieldRef<"EmploymentHistory", 'DateTime'>
    readonly salary: FieldRef<"EmploymentHistory", 'Decimal'>
    readonly notes: FieldRef<"EmploymentHistory", 'String'>
    readonly createdAt: FieldRef<"EmploymentHistory", 'DateTime'>
    readonly updatedAt: FieldRef<"EmploymentHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmploymentHistory findUnique
   */
  export type EmploymentHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentHistory
     */
    select?: EmploymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentHistory
     */
    omit?: EmploymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentHistory to fetch.
     */
    where: EmploymentHistoryWhereUniqueInput
  }

  /**
   * EmploymentHistory findUniqueOrThrow
   */
  export type EmploymentHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentHistory
     */
    select?: EmploymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentHistory
     */
    omit?: EmploymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentHistory to fetch.
     */
    where: EmploymentHistoryWhereUniqueInput
  }

  /**
   * EmploymentHistory findFirst
   */
  export type EmploymentHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentHistory
     */
    select?: EmploymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentHistory
     */
    omit?: EmploymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentHistory to fetch.
     */
    where?: EmploymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentHistories to fetch.
     */
    orderBy?: EmploymentHistoryOrderByWithRelationInput | EmploymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmploymentHistories.
     */
    cursor?: EmploymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmploymentHistories.
     */
    distinct?: EmploymentHistoryScalarFieldEnum | EmploymentHistoryScalarFieldEnum[]
  }

  /**
   * EmploymentHistory findFirstOrThrow
   */
  export type EmploymentHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentHistory
     */
    select?: EmploymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentHistory
     */
    omit?: EmploymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentHistory to fetch.
     */
    where?: EmploymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentHistories to fetch.
     */
    orderBy?: EmploymentHistoryOrderByWithRelationInput | EmploymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmploymentHistories.
     */
    cursor?: EmploymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmploymentHistories.
     */
    distinct?: EmploymentHistoryScalarFieldEnum | EmploymentHistoryScalarFieldEnum[]
  }

  /**
   * EmploymentHistory findMany
   */
  export type EmploymentHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentHistory
     */
    select?: EmploymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentHistory
     */
    omit?: EmploymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentHistoryInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentHistories to fetch.
     */
    where?: EmploymentHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentHistories to fetch.
     */
    orderBy?: EmploymentHistoryOrderByWithRelationInput | EmploymentHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmploymentHistories.
     */
    cursor?: EmploymentHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentHistories.
     */
    skip?: number
    distinct?: EmploymentHistoryScalarFieldEnum | EmploymentHistoryScalarFieldEnum[]
  }

  /**
   * EmploymentHistory create
   */
  export type EmploymentHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentHistory
     */
    select?: EmploymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentHistory
     */
    omit?: EmploymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a EmploymentHistory.
     */
    data: XOR<EmploymentHistoryCreateInput, EmploymentHistoryUncheckedCreateInput>
  }

  /**
   * EmploymentHistory createMany
   */
  export type EmploymentHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmploymentHistories.
     */
    data: EmploymentHistoryCreateManyInput | EmploymentHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmploymentHistory createManyAndReturn
   */
  export type EmploymentHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentHistory
     */
    select?: EmploymentHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentHistory
     */
    omit?: EmploymentHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many EmploymentHistories.
     */
    data: EmploymentHistoryCreateManyInput | EmploymentHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmploymentHistory update
   */
  export type EmploymentHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentHistory
     */
    select?: EmploymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentHistory
     */
    omit?: EmploymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a EmploymentHistory.
     */
    data: XOR<EmploymentHistoryUpdateInput, EmploymentHistoryUncheckedUpdateInput>
    /**
     * Choose, which EmploymentHistory to update.
     */
    where: EmploymentHistoryWhereUniqueInput
  }

  /**
   * EmploymentHistory updateMany
   */
  export type EmploymentHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmploymentHistories.
     */
    data: XOR<EmploymentHistoryUpdateManyMutationInput, EmploymentHistoryUncheckedUpdateManyInput>
    /**
     * Filter which EmploymentHistories to update
     */
    where?: EmploymentHistoryWhereInput
    /**
     * Limit how many EmploymentHistories to update.
     */
    limit?: number
  }

  /**
   * EmploymentHistory updateManyAndReturn
   */
  export type EmploymentHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentHistory
     */
    select?: EmploymentHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentHistory
     */
    omit?: EmploymentHistoryOmit<ExtArgs> | null
    /**
     * The data used to update EmploymentHistories.
     */
    data: XOR<EmploymentHistoryUpdateManyMutationInput, EmploymentHistoryUncheckedUpdateManyInput>
    /**
     * Filter which EmploymentHistories to update
     */
    where?: EmploymentHistoryWhereInput
    /**
     * Limit how many EmploymentHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmploymentHistory upsert
   */
  export type EmploymentHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentHistory
     */
    select?: EmploymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentHistory
     */
    omit?: EmploymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the EmploymentHistory to update in case it exists.
     */
    where: EmploymentHistoryWhereUniqueInput
    /**
     * In case the EmploymentHistory found by the `where` argument doesn't exist, create a new EmploymentHistory with this data.
     */
    create: XOR<EmploymentHistoryCreateInput, EmploymentHistoryUncheckedCreateInput>
    /**
     * In case the EmploymentHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmploymentHistoryUpdateInput, EmploymentHistoryUncheckedUpdateInput>
  }

  /**
   * EmploymentHistory delete
   */
  export type EmploymentHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentHistory
     */
    select?: EmploymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentHistory
     */
    omit?: EmploymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentHistoryInclude<ExtArgs> | null
    /**
     * Filter which EmploymentHistory to delete.
     */
    where: EmploymentHistoryWhereUniqueInput
  }

  /**
   * EmploymentHistory deleteMany
   */
  export type EmploymentHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmploymentHistories to delete
     */
    where?: EmploymentHistoryWhereInput
    /**
     * Limit how many EmploymentHistories to delete.
     */
    limit?: number
  }

  /**
   * EmploymentHistory.positionLevel
   */
  export type EmploymentHistory$positionLevelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PositionLevel
     */
    select?: PositionLevelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PositionLevel
     */
    omit?: PositionLevelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PositionLevelInclude<ExtArgs> | null
    where?: PositionLevelWhereInput
  }

  /**
   * EmploymentHistory without action
   */
  export type EmploymentHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentHistory
     */
    select?: EmploymentHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmploymentHistory
     */
    omit?: EmploymentHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentHistoryInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeDocument
   */

  export type AggregateEmployeeDocument = {
    _count: EmployeeDocumentCountAggregateOutputType | null
    _avg: EmployeeDocumentAvgAggregateOutputType | null
    _sum: EmployeeDocumentSumAggregateOutputType | null
    _min: EmployeeDocumentMinAggregateOutputType | null
    _max: EmployeeDocumentMaxAggregateOutputType | null
  }

  export type EmployeeDocumentAvgAggregateOutputType = {
    size: number | null
  }

  export type EmployeeDocumentSumAggregateOutputType = {
    size: number | null
  }

  export type EmployeeDocumentMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    type: string | null
    name: string | null
    filename: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeDocumentMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    type: string | null
    name: string | null
    filename: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    uploadedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeDocumentCountAggregateOutputType = {
    id: number
    employeeId: number
    type: number
    name: number
    filename: number
    mimeType: number
    size: number
    url: number
    uploadedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeDocumentAvgAggregateInputType = {
    size?: true
  }

  export type EmployeeDocumentSumAggregateInputType = {
    size?: true
  }

  export type EmployeeDocumentMinAggregateInputType = {
    id?: true
    employeeId?: true
    type?: true
    name?: true
    filename?: true
    mimeType?: true
    size?: true
    url?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeDocumentMaxAggregateInputType = {
    id?: true
    employeeId?: true
    type?: true
    name?: true
    filename?: true
    mimeType?: true
    size?: true
    url?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeDocumentCountAggregateInputType = {
    id?: true
    employeeId?: true
    type?: true
    name?: true
    filename?: true
    mimeType?: true
    size?: true
    url?: true
    uploadedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeDocument to aggregate.
     */
    where?: EmployeeDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeDocuments to fetch.
     */
    orderBy?: EmployeeDocumentOrderByWithRelationInput | EmployeeDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeDocuments
    **/
    _count?: true | EmployeeDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeDocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeDocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeDocumentMaxAggregateInputType
  }

  export type GetEmployeeDocumentAggregateType<T extends EmployeeDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeDocument[P]>
      : GetScalarType<T[P], AggregateEmployeeDocument[P]>
  }




  export type EmployeeDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeDocumentWhereInput
    orderBy?: EmployeeDocumentOrderByWithAggregationInput | EmployeeDocumentOrderByWithAggregationInput[]
    by: EmployeeDocumentScalarFieldEnum[] | EmployeeDocumentScalarFieldEnum
    having?: EmployeeDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeDocumentCountAggregateInputType | true
    _avg?: EmployeeDocumentAvgAggregateInputType
    _sum?: EmployeeDocumentSumAggregateInputType
    _min?: EmployeeDocumentMinAggregateInputType
    _max?: EmployeeDocumentMaxAggregateInputType
  }

  export type EmployeeDocumentGroupByOutputType = {
    id: string
    employeeId: string
    type: string
    name: string
    filename: string
    mimeType: string
    size: number
    url: string
    uploadedBy: string
    createdAt: Date
    updatedAt: Date
    _count: EmployeeDocumentCountAggregateOutputType | null
    _avg: EmployeeDocumentAvgAggregateOutputType | null
    _sum: EmployeeDocumentSumAggregateOutputType | null
    _min: EmployeeDocumentMinAggregateOutputType | null
    _max: EmployeeDocumentMaxAggregateOutputType | null
  }

  type GetEmployeeDocumentGroupByPayload<T extends EmployeeDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeDocumentGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    type?: boolean
    name?: boolean
    filename?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeDocument"]>

  export type EmployeeDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    type?: boolean
    name?: boolean
    filename?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeDocument"]>

  export type EmployeeDocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    type?: boolean
    name?: boolean
    filename?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeDocument"]>

  export type EmployeeDocumentSelectScalar = {
    id?: boolean
    employeeId?: boolean
    type?: boolean
    name?: boolean
    filename?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    uploadedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeDocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "type" | "name" | "filename" | "mimeType" | "size" | "url" | "uploadedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["employeeDocument"]>
  export type EmployeeDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type EmployeeDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type EmployeeDocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $EmployeeDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeDocument"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      type: string
      name: string
      filename: string
      mimeType: string
      size: number
      url: string
      uploadedBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employeeDocument"]>
    composites: {}
  }

  type EmployeeDocumentGetPayload<S extends boolean | null | undefined | EmployeeDocumentDefaultArgs> = $Result.GetResult<Prisma.$EmployeeDocumentPayload, S>

  type EmployeeDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeDocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeDocumentCountAggregateInputType | true
    }

  export interface EmployeeDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeDocument'], meta: { name: 'EmployeeDocument' } }
    /**
     * Find zero or one EmployeeDocument that matches the filter.
     * @param {EmployeeDocumentFindUniqueArgs} args - Arguments to find a EmployeeDocument
     * @example
     * // Get one EmployeeDocument
     * const employeeDocument = await prisma.employeeDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeDocumentFindUniqueArgs>(args: SelectSubset<T, EmployeeDocumentFindUniqueArgs<ExtArgs>>): Prisma__EmployeeDocumentClient<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeDocument that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeDocumentFindUniqueOrThrowArgs} args - Arguments to find a EmployeeDocument
     * @example
     * // Get one EmployeeDocument
     * const employeeDocument = await prisma.employeeDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeDocumentClient<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDocumentFindFirstArgs} args - Arguments to find a EmployeeDocument
     * @example
     * // Get one EmployeeDocument
     * const employeeDocument = await prisma.employeeDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeDocumentFindFirstArgs>(args?: SelectSubset<T, EmployeeDocumentFindFirstArgs<ExtArgs>>): Prisma__EmployeeDocumentClient<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDocumentFindFirstOrThrowArgs} args - Arguments to find a EmployeeDocument
     * @example
     * // Get one EmployeeDocument
     * const employeeDocument = await prisma.employeeDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeDocumentClient<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeDocuments
     * const employeeDocuments = await prisma.employeeDocument.findMany()
     * 
     * // Get first 10 EmployeeDocuments
     * const employeeDocuments = await prisma.employeeDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeDocumentWithIdOnly = await prisma.employeeDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeDocumentFindManyArgs>(args?: SelectSubset<T, EmployeeDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeDocument.
     * @param {EmployeeDocumentCreateArgs} args - Arguments to create a EmployeeDocument.
     * @example
     * // Create one EmployeeDocument
     * const EmployeeDocument = await prisma.employeeDocument.create({
     *   data: {
     *     // ... data to create a EmployeeDocument
     *   }
     * })
     * 
     */
    create<T extends EmployeeDocumentCreateArgs>(args: SelectSubset<T, EmployeeDocumentCreateArgs<ExtArgs>>): Prisma__EmployeeDocumentClient<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeDocuments.
     * @param {EmployeeDocumentCreateManyArgs} args - Arguments to create many EmployeeDocuments.
     * @example
     * // Create many EmployeeDocuments
     * const employeeDocument = await prisma.employeeDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeDocumentCreateManyArgs>(args?: SelectSubset<T, EmployeeDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeDocuments and returns the data saved in the database.
     * @param {EmployeeDocumentCreateManyAndReturnArgs} args - Arguments to create many EmployeeDocuments.
     * @example
     * // Create many EmployeeDocuments
     * const employeeDocument = await prisma.employeeDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeDocuments and only return the `id`
     * const employeeDocumentWithIdOnly = await prisma.employeeDocument.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeDocument.
     * @param {EmployeeDocumentDeleteArgs} args - Arguments to delete one EmployeeDocument.
     * @example
     * // Delete one EmployeeDocument
     * const EmployeeDocument = await prisma.employeeDocument.delete({
     *   where: {
     *     // ... filter to delete one EmployeeDocument
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDocumentDeleteArgs>(args: SelectSubset<T, EmployeeDocumentDeleteArgs<ExtArgs>>): Prisma__EmployeeDocumentClient<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeDocument.
     * @param {EmployeeDocumentUpdateArgs} args - Arguments to update one EmployeeDocument.
     * @example
     * // Update one EmployeeDocument
     * const employeeDocument = await prisma.employeeDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeDocumentUpdateArgs>(args: SelectSubset<T, EmployeeDocumentUpdateArgs<ExtArgs>>): Prisma__EmployeeDocumentClient<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeDocuments.
     * @param {EmployeeDocumentDeleteManyArgs} args - Arguments to filter EmployeeDocuments to delete.
     * @example
     * // Delete a few EmployeeDocuments
     * const { count } = await prisma.employeeDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDocumentDeleteManyArgs>(args?: SelectSubset<T, EmployeeDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeDocuments
     * const employeeDocument = await prisma.employeeDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeDocumentUpdateManyArgs>(args: SelectSubset<T, EmployeeDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeDocuments and returns the data updated in the database.
     * @param {EmployeeDocumentUpdateManyAndReturnArgs} args - Arguments to update many EmployeeDocuments.
     * @example
     * // Update many EmployeeDocuments
     * const employeeDocument = await prisma.employeeDocument.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeDocuments and only return the `id`
     * const employeeDocumentWithIdOnly = await prisma.employeeDocument.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeDocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeDocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeDocument.
     * @param {EmployeeDocumentUpsertArgs} args - Arguments to update or create a EmployeeDocument.
     * @example
     * // Update or create a EmployeeDocument
     * const employeeDocument = await prisma.employeeDocument.upsert({
     *   create: {
     *     // ... data to create a EmployeeDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeDocument we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeDocumentUpsertArgs>(args: SelectSubset<T, EmployeeDocumentUpsertArgs<ExtArgs>>): Prisma__EmployeeDocumentClient<$Result.GetResult<Prisma.$EmployeeDocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDocumentCountArgs} args - Arguments to filter EmployeeDocuments to count.
     * @example
     * // Count the number of EmployeeDocuments
     * const count = await prisma.employeeDocument.count({
     *   where: {
     *     // ... the filter for the EmployeeDocuments we want to count
     *   }
     * })
    **/
    count<T extends EmployeeDocumentCountArgs>(
      args?: Subset<T, EmployeeDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeDocumentAggregateArgs>(args: Subset<T, EmployeeDocumentAggregateArgs>): Prisma.PrismaPromise<GetEmployeeDocumentAggregateType<T>>

    /**
     * Group by EmployeeDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeDocumentGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeDocument model
   */
  readonly fields: EmployeeDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeDocument model
   */
  interface EmployeeDocumentFieldRefs {
    readonly id: FieldRef<"EmployeeDocument", 'String'>
    readonly employeeId: FieldRef<"EmployeeDocument", 'String'>
    readonly type: FieldRef<"EmployeeDocument", 'String'>
    readonly name: FieldRef<"EmployeeDocument", 'String'>
    readonly filename: FieldRef<"EmployeeDocument", 'String'>
    readonly mimeType: FieldRef<"EmployeeDocument", 'String'>
    readonly size: FieldRef<"EmployeeDocument", 'Int'>
    readonly url: FieldRef<"EmployeeDocument", 'String'>
    readonly uploadedBy: FieldRef<"EmployeeDocument", 'String'>
    readonly createdAt: FieldRef<"EmployeeDocument", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeDocument findUnique
   */
  export type EmployeeDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeDocument to fetch.
     */
    where: EmployeeDocumentWhereUniqueInput
  }

  /**
   * EmployeeDocument findUniqueOrThrow
   */
  export type EmployeeDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeDocument to fetch.
     */
    where: EmployeeDocumentWhereUniqueInput
  }

  /**
   * EmployeeDocument findFirst
   */
  export type EmployeeDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeDocument to fetch.
     */
    where?: EmployeeDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeDocuments to fetch.
     */
    orderBy?: EmployeeDocumentOrderByWithRelationInput | EmployeeDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeDocuments.
     */
    cursor?: EmployeeDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeDocuments.
     */
    distinct?: EmployeeDocumentScalarFieldEnum | EmployeeDocumentScalarFieldEnum[]
  }

  /**
   * EmployeeDocument findFirstOrThrow
   */
  export type EmployeeDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeDocument to fetch.
     */
    where?: EmployeeDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeDocuments to fetch.
     */
    orderBy?: EmployeeDocumentOrderByWithRelationInput | EmployeeDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeDocuments.
     */
    cursor?: EmployeeDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeDocuments.
     */
    distinct?: EmployeeDocumentScalarFieldEnum | EmployeeDocumentScalarFieldEnum[]
  }

  /**
   * EmployeeDocument findMany
   */
  export type EmployeeDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeDocuments to fetch.
     */
    where?: EmployeeDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeDocuments to fetch.
     */
    orderBy?: EmployeeDocumentOrderByWithRelationInput | EmployeeDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeDocuments.
     */
    cursor?: EmployeeDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeDocuments.
     */
    skip?: number
    distinct?: EmployeeDocumentScalarFieldEnum | EmployeeDocumentScalarFieldEnum[]
  }

  /**
   * EmployeeDocument create
   */
  export type EmployeeDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeDocument.
     */
    data: XOR<EmployeeDocumentCreateInput, EmployeeDocumentUncheckedCreateInput>
  }

  /**
   * EmployeeDocument createMany
   */
  export type EmployeeDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeDocuments.
     */
    data: EmployeeDocumentCreateManyInput | EmployeeDocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeDocument createManyAndReturn
   */
  export type EmployeeDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeDocuments.
     */
    data: EmployeeDocumentCreateManyInput | EmployeeDocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeDocument update
   */
  export type EmployeeDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeDocument.
     */
    data: XOR<EmployeeDocumentUpdateInput, EmployeeDocumentUncheckedUpdateInput>
    /**
     * Choose, which EmployeeDocument to update.
     */
    where: EmployeeDocumentWhereUniqueInput
  }

  /**
   * EmployeeDocument updateMany
   */
  export type EmployeeDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeDocuments.
     */
    data: XOR<EmployeeDocumentUpdateManyMutationInput, EmployeeDocumentUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeDocuments to update
     */
    where?: EmployeeDocumentWhereInput
    /**
     * Limit how many EmployeeDocuments to update.
     */
    limit?: number
  }

  /**
   * EmployeeDocument updateManyAndReturn
   */
  export type EmployeeDocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeDocuments.
     */
    data: XOR<EmployeeDocumentUpdateManyMutationInput, EmployeeDocumentUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeDocuments to update
     */
    where?: EmployeeDocumentWhereInput
    /**
     * Limit how many EmployeeDocuments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeDocument upsert
   */
  export type EmployeeDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeDocument to update in case it exists.
     */
    where: EmployeeDocumentWhereUniqueInput
    /**
     * In case the EmployeeDocument found by the `where` argument doesn't exist, create a new EmployeeDocument with this data.
     */
    create: XOR<EmployeeDocumentCreateInput, EmployeeDocumentUncheckedCreateInput>
    /**
     * In case the EmployeeDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeDocumentUpdateInput, EmployeeDocumentUncheckedUpdateInput>
  }

  /**
   * EmployeeDocument delete
   */
  export type EmployeeDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
    /**
     * Filter which EmployeeDocument to delete.
     */
    where: EmployeeDocumentWhereUniqueInput
  }

  /**
   * EmployeeDocument deleteMany
   */
  export type EmployeeDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeDocuments to delete
     */
    where?: EmployeeDocumentWhereInput
    /**
     * Limit how many EmployeeDocuments to delete.
     */
    limit?: number
  }

  /**
   * EmployeeDocument without action
   */
  export type EmployeeDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDocument
     */
    select?: EmployeeDocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDocument
     */
    omit?: EmployeeDocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDocumentInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    budget: Decimal | null
  }

  export type ProjectSumAggregateOutputType = {
    budget: Decimal | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    code: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    budget: Decimal | null
    status: $Enums.ProjectStatus | null
    priority: $Enums.ProjectPriority | null
    managerId: string | null
    clientName: string | null
    clientContact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    code: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    budget: Decimal | null
    status: $Enums.ProjectStatus | null
    priority: $Enums.ProjectPriority | null
    managerId: string | null
    clientName: string | null
    clientContact: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    code: number
    description: number
    startDate: number
    endDate: number
    budget: number
    status: number
    priority: number
    managerId: number
    clientName: number
    clientContact: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    budget?: true
  }

  export type ProjectSumAggregateInputType = {
    budget?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    code?: true
    description?: true
    startDate?: true
    endDate?: true
    budget?: true
    status?: true
    priority?: true
    managerId?: true
    clientName?: true
    clientContact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    code?: true
    description?: true
    startDate?: true
    endDate?: true
    budget?: true
    status?: true
    priority?: true
    managerId?: true
    clientName?: true
    clientContact?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    code?: true
    description?: true
    startDate?: true
    endDate?: true
    budget?: true
    status?: true
    priority?: true
    managerId?: true
    clientName?: true
    clientContact?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    code: string | null
    description: string | null
    startDate: Date
    endDate: Date | null
    budget: Decimal | null
    status: $Enums.ProjectStatus
    priority: $Enums.ProjectPriority
    managerId: string | null
    clientName: string | null
    clientContact: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    budget?: boolean
    status?: boolean
    priority?: boolean
    managerId?: boolean
    clientName?: boolean
    clientContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    budget?: boolean
    status?: boolean
    priority?: boolean
    managerId?: boolean
    clientName?: boolean
    clientContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    budget?: boolean
    status?: boolean
    priority?: boolean
    managerId?: boolean
    clientName?: boolean
    clientContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    budget?: boolean
    status?: boolean
    priority?: boolean
    managerId?: boolean
    clientName?: boolean
    clientContact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "code" | "description" | "startDate" | "endDate" | "budget" | "status" | "priority" | "managerId" | "clientName" | "clientContact" | "createdAt" | "updatedAt", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    members?: boolean | Project$membersArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      members: Prisma.$ProjectMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      code: string | null
      description: string | null
      startDate: Date
      endDate: Date | null
      budget: Prisma.Decimal | null
      status: $Enums.ProjectStatus
      priority: $Enums.ProjectPriority
      managerId: string | null
      clientName: string | null
      clientContact: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    members<T extends Project$membersArgs<ExtArgs> = {}>(args?: Subset<T, Project$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly workspaceId: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly code: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly startDate: FieldRef<"Project", 'DateTime'>
    readonly endDate: FieldRef<"Project", 'DateTime'>
    readonly budget: FieldRef<"Project", 'Decimal'>
    readonly status: FieldRef<"Project", 'ProjectStatus'>
    readonly priority: FieldRef<"Project", 'ProjectPriority'>
    readonly managerId: FieldRef<"Project", 'String'>
    readonly clientName: FieldRef<"Project", 'String'>
    readonly clientContact: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.members
   */
  export type Project$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMember
   */

  export type AggregateProjectMember = {
    _count: ProjectMemberCountAggregateOutputType | null
    _avg: ProjectMemberAvgAggregateOutputType | null
    _sum: ProjectMemberSumAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  export type ProjectMemberAvgAggregateOutputType = {
    allocation: number | null
  }

  export type ProjectMemberSumAggregateOutputType = {
    allocation: number | null
  }

  export type ProjectMemberMinAggregateOutputType = {
    id: string | null
    projectId: string | null
    employeeId: string | null
    roleId: string | null
    allocation: number | null
    startDate: Date | null
    endDate: Date | null
  }

  export type ProjectMemberMaxAggregateOutputType = {
    id: string | null
    projectId: string | null
    employeeId: string | null
    roleId: string | null
    allocation: number | null
    startDate: Date | null
    endDate: Date | null
  }

  export type ProjectMemberCountAggregateOutputType = {
    id: number
    projectId: number
    employeeId: number
    roleId: number
    allocation: number
    startDate: number
    endDate: number
    _all: number
  }


  export type ProjectMemberAvgAggregateInputType = {
    allocation?: true
  }

  export type ProjectMemberSumAggregateInputType = {
    allocation?: true
  }

  export type ProjectMemberMinAggregateInputType = {
    id?: true
    projectId?: true
    employeeId?: true
    roleId?: true
    allocation?: true
    startDate?: true
    endDate?: true
  }

  export type ProjectMemberMaxAggregateInputType = {
    id?: true
    projectId?: true
    employeeId?: true
    roleId?: true
    allocation?: true
    startDate?: true
    endDate?: true
  }

  export type ProjectMemberCountAggregateInputType = {
    id?: true
    projectId?: true
    employeeId?: true
    roleId?: true
    allocation?: true
    startDate?: true
    endDate?: true
    _all?: true
  }

  export type ProjectMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMember to aggregate.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMembers
    **/
    _count?: true | ProjectMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type GetProjectMemberAggregateType<T extends ProjectMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMember[P]>
      : GetScalarType<T[P], AggregateProjectMember[P]>
  }




  export type ProjectMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithAggregationInput | ProjectMemberOrderByWithAggregationInput[]
    by: ProjectMemberScalarFieldEnum[] | ProjectMemberScalarFieldEnum
    having?: ProjectMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMemberCountAggregateInputType | true
    _avg?: ProjectMemberAvgAggregateInputType
    _sum?: ProjectMemberSumAggregateInputType
    _min?: ProjectMemberMinAggregateInputType
    _max?: ProjectMemberMaxAggregateInputType
  }

  export type ProjectMemberGroupByOutputType = {
    id: string
    projectId: string
    employeeId: string
    roleId: string
    allocation: number
    startDate: Date
    endDate: Date | null
    _count: ProjectMemberCountAggregateOutputType | null
    _avg: ProjectMemberAvgAggregateOutputType | null
    _sum: ProjectMemberSumAggregateOutputType | null
    _min: ProjectMemberMinAggregateOutputType | null
    _max: ProjectMemberMaxAggregateOutputType | null
  }

  type GetProjectMemberGroupByPayload<T extends ProjectMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMemberGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    employeeId?: boolean
    roleId?: boolean
    allocation?: boolean
    startDate?: boolean
    endDate?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    projectRole?: boolean | ProjectRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    employeeId?: boolean
    roleId?: boolean
    allocation?: boolean
    startDate?: boolean
    endDate?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    projectRole?: boolean | ProjectRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    projectId?: boolean
    employeeId?: boolean
    roleId?: boolean
    allocation?: boolean
    startDate?: boolean
    endDate?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    projectRole?: boolean | ProjectRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMember"]>

  export type ProjectMemberSelectScalar = {
    id?: boolean
    projectId?: boolean
    employeeId?: boolean
    roleId?: boolean
    allocation?: boolean
    startDate?: boolean
    endDate?: boolean
  }

  export type ProjectMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "projectId" | "employeeId" | "roleId" | "allocation" | "startDate" | "endDate", ExtArgs["result"]["projectMember"]>
  export type ProjectMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    projectRole?: boolean | ProjectRoleDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    projectRole?: boolean | ProjectRoleDefaultArgs<ExtArgs>
  }
  export type ProjectMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    projectRole?: boolean | ProjectRoleDefaultArgs<ExtArgs>
  }

  export type $ProjectMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMember"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
      projectRole: Prisma.$ProjectRolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      projectId: string
      employeeId: string
      roleId: string
      allocation: number
      startDate: Date
      endDate: Date | null
    }, ExtArgs["result"]["projectMember"]>
    composites: {}
  }

  type ProjectMemberGetPayload<S extends boolean | null | undefined | ProjectMemberDefaultArgs> = $Result.GetResult<Prisma.$ProjectMemberPayload, S>

  type ProjectMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectMemberCountAggregateInputType | true
    }

  export interface ProjectMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMember'], meta: { name: 'ProjectMember' } }
    /**
     * Find zero or one ProjectMember that matches the filter.
     * @param {ProjectMemberFindUniqueArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMemberFindUniqueArgs>(args: SelectSubset<T, ProjectMemberFindUniqueArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectMemberFindUniqueOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMemberFindFirstArgs>(args?: SelectSubset<T, ProjectMemberFindFirstArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindFirstOrThrowArgs} args - Arguments to find a ProjectMember
     * @example
     * // Get one ProjectMember
     * const projectMember = await prisma.projectMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany()
     * 
     * // Get first 10 ProjectMembers
     * const projectMembers = await prisma.projectMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMemberFindManyArgs>(args?: SelectSubset<T, ProjectMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectMember.
     * @param {ProjectMemberCreateArgs} args - Arguments to create a ProjectMember.
     * @example
     * // Create one ProjectMember
     * const ProjectMember = await prisma.projectMember.create({
     *   data: {
     *     // ... data to create a ProjectMember
     *   }
     * })
     * 
     */
    create<T extends ProjectMemberCreateArgs>(args: SelectSubset<T, ProjectMemberCreateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectMembers.
     * @param {ProjectMemberCreateManyArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMemberCreateManyArgs>(args?: SelectSubset<T, ProjectMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMembers and returns the data saved in the database.
     * @param {ProjectMemberCreateManyAndReturnArgs} args - Arguments to create many ProjectMembers.
     * @example
     * // Create many ProjectMembers
     * const projectMember = await prisma.projectMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectMember.
     * @param {ProjectMemberDeleteArgs} args - Arguments to delete one ProjectMember.
     * @example
     * // Delete one ProjectMember
     * const ProjectMember = await prisma.projectMember.delete({
     *   where: {
     *     // ... filter to delete one ProjectMember
     *   }
     * })
     * 
     */
    delete<T extends ProjectMemberDeleteArgs>(args: SelectSubset<T, ProjectMemberDeleteArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectMember.
     * @param {ProjectMemberUpdateArgs} args - Arguments to update one ProjectMember.
     * @example
     * // Update one ProjectMember
     * const projectMember = await prisma.projectMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMemberUpdateArgs>(args: SelectSubset<T, ProjectMemberUpdateArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectMembers.
     * @param {ProjectMemberDeleteManyArgs} args - Arguments to filter ProjectMembers to delete.
     * @example
     * // Delete a few ProjectMembers
     * const { count } = await prisma.projectMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMemberDeleteManyArgs>(args?: SelectSubset<T, ProjectMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMemberUpdateManyArgs>(args: SelectSubset<T, ProjectMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMembers and returns the data updated in the database.
     * @param {ProjectMemberUpdateManyAndReturnArgs} args - Arguments to update many ProjectMembers.
     * @example
     * // Update many ProjectMembers
     * const projectMember = await prisma.projectMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectMembers and only return the `id`
     * const projectMemberWithIdOnly = await prisma.projectMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectMember.
     * @param {ProjectMemberUpsertArgs} args - Arguments to update or create a ProjectMember.
     * @example
     * // Update or create a ProjectMember
     * const projectMember = await prisma.projectMember.upsert({
     *   create: {
     *     // ... data to create a ProjectMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMember we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMemberUpsertArgs>(args: SelectSubset<T, ProjectMemberUpsertArgs<ExtArgs>>): Prisma__ProjectMemberClient<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberCountArgs} args - Arguments to filter ProjectMembers to count.
     * @example
     * // Count the number of ProjectMembers
     * const count = await prisma.projectMember.count({
     *   where: {
     *     // ... the filter for the ProjectMembers we want to count
     *   }
     * })
    **/
    count<T extends ProjectMemberCountArgs>(
      args?: Subset<T, ProjectMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMemberAggregateArgs>(args: Subset<T, ProjectMemberAggregateArgs>): Prisma.PrismaPromise<GetProjectMemberAggregateType<T>>

    /**
     * Group by ProjectMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMemberGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMember model
   */
  readonly fields: ProjectMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    projectRole<T extends ProjectRoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectRoleDefaultArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMember model
   */
  interface ProjectMemberFieldRefs {
    readonly id: FieldRef<"ProjectMember", 'String'>
    readonly projectId: FieldRef<"ProjectMember", 'String'>
    readonly employeeId: FieldRef<"ProjectMember", 'String'>
    readonly roleId: FieldRef<"ProjectMember", 'String'>
    readonly allocation: FieldRef<"ProjectMember", 'Int'>
    readonly startDate: FieldRef<"ProjectMember", 'DateTime'>
    readonly endDate: FieldRef<"ProjectMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMember findUnique
   */
  export type ProjectMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findUniqueOrThrow
   */
  export type ProjectMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember findFirst
   */
  export type ProjectMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findFirstOrThrow
   */
  export type ProjectMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMember to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMembers.
     */
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember findMany
   */
  export type ProjectMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMembers to fetch.
     */
    where?: ProjectMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMembers to fetch.
     */
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMembers.
     */
    cursor?: ProjectMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMembers.
     */
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectMember create
   */
  export type ProjectMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMember.
     */
    data: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
  }

  /**
   * ProjectMember createMany
   */
  export type ProjectMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMember createManyAndReturn
   */
  export type ProjectMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectMembers.
     */
    data: ProjectMemberCreateManyInput | ProjectMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember update
   */
  export type ProjectMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMember.
     */
    data: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
    /**
     * Choose, which ProjectMember to update.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember updateMany
   */
  export type ProjectMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
  }

  /**
   * ProjectMember updateManyAndReturn
   */
  export type ProjectMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * The data used to update ProjectMembers.
     */
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMembers to update
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMember upsert
   */
  export type ProjectMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMember to update in case it exists.
     */
    where: ProjectMemberWhereUniqueInput
    /**
     * In case the ProjectMember found by the `where` argument doesn't exist, create a new ProjectMember with this data.
     */
    create: XOR<ProjectMemberCreateInput, ProjectMemberUncheckedCreateInput>
    /**
     * In case the ProjectMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMemberUpdateInput, ProjectMemberUncheckedUpdateInput>
  }

  /**
   * ProjectMember delete
   */
  export type ProjectMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    /**
     * Filter which ProjectMember to delete.
     */
    where: ProjectMemberWhereUniqueInput
  }

  /**
   * ProjectMember deleteMany
   */
  export type ProjectMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMembers to delete
     */
    where?: ProjectMemberWhereInput
    /**
     * Limit how many ProjectMembers to delete.
     */
    limit?: number
  }

  /**
   * ProjectMember without action
   */
  export type ProjectMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
  }


  /**
   * Model ProjectRole
   */

  export type AggregateProjectRole = {
    _count: ProjectRoleCountAggregateOutputType | null
    _min: ProjectRoleMinAggregateOutputType | null
    _max: ProjectRoleMaxAggregateOutputType | null
  }

  export type ProjectRoleMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectRoleMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectRoleCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectRoleMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectRoleMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectRoleCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectRole to aggregate.
     */
    where?: ProjectRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectRoles to fetch.
     */
    orderBy?: ProjectRoleOrderByWithRelationInput | ProjectRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectRoles
    **/
    _count?: true | ProjectRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectRoleMaxAggregateInputType
  }

  export type GetProjectRoleAggregateType<T extends ProjectRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectRole[P]>
      : GetScalarType<T[P], AggregateProjectRole[P]>
  }




  export type ProjectRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectRoleWhereInput
    orderBy?: ProjectRoleOrderByWithAggregationInput | ProjectRoleOrderByWithAggregationInput[]
    by: ProjectRoleScalarFieldEnum[] | ProjectRoleScalarFieldEnum
    having?: ProjectRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectRoleCountAggregateInputType | true
    _min?: ProjectRoleMinAggregateInputType
    _max?: ProjectRoleMaxAggregateInputType
  }

  export type ProjectRoleGroupByOutputType = {
    id: string
    workspaceId: string | null
    name: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectRoleCountAggregateOutputType | null
    _min: ProjectRoleMinAggregateOutputType | null
    _max: ProjectRoleMaxAggregateOutputType | null
  }

  type GetProjectRoleGroupByPayload<T extends ProjectRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectRoleGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectRoleGroupByOutputType[P]>
        }
      >
    >


  export type ProjectRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | ProjectRole$workspaceArgs<ExtArgs>
    projectMembers?: boolean | ProjectRole$projectMembersArgs<ExtArgs>
    _count?: boolean | ProjectRoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectRole"]>

  export type ProjectRoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | ProjectRole$workspaceArgs<ExtArgs>
  }, ExtArgs["result"]["projectRole"]>

  export type ProjectRoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | ProjectRole$workspaceArgs<ExtArgs>
  }, ExtArgs["result"]["projectRole"]>

  export type ProjectRoleSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectRoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["projectRole"]>
  export type ProjectRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | ProjectRole$workspaceArgs<ExtArgs>
    projectMembers?: boolean | ProjectRole$projectMembersArgs<ExtArgs>
    _count?: boolean | ProjectRoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectRoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | ProjectRole$workspaceArgs<ExtArgs>
  }
  export type ProjectRoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | ProjectRole$workspaceArgs<ExtArgs>
  }

  export type $ProjectRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectRole"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs> | null
      projectMembers: Prisma.$ProjectMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string | null
      name: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["projectRole"]>
    composites: {}
  }

  type ProjectRoleGetPayload<S extends boolean | null | undefined | ProjectRoleDefaultArgs> = $Result.GetResult<Prisma.$ProjectRolePayload, S>

  type ProjectRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectRoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectRoleCountAggregateInputType | true
    }

  export interface ProjectRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectRole'], meta: { name: 'ProjectRole' } }
    /**
     * Find zero or one ProjectRole that matches the filter.
     * @param {ProjectRoleFindUniqueArgs} args - Arguments to find a ProjectRole
     * @example
     * // Get one ProjectRole
     * const projectRole = await prisma.projectRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectRoleFindUniqueArgs>(args: SelectSubset<T, ProjectRoleFindUniqueArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectRole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectRoleFindUniqueOrThrowArgs} args - Arguments to find a ProjectRole
     * @example
     * // Get one ProjectRole
     * const projectRole = await prisma.projectRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleFindFirstArgs} args - Arguments to find a ProjectRole
     * @example
     * // Get one ProjectRole
     * const projectRole = await prisma.projectRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectRoleFindFirstArgs>(args?: SelectSubset<T, ProjectRoleFindFirstArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleFindFirstOrThrowArgs} args - Arguments to find a ProjectRole
     * @example
     * // Get one ProjectRole
     * const projectRole = await prisma.projectRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectRoles
     * const projectRoles = await prisma.projectRole.findMany()
     * 
     * // Get first 10 ProjectRoles
     * const projectRoles = await prisma.projectRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectRoleWithIdOnly = await prisma.projectRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectRoleFindManyArgs>(args?: SelectSubset<T, ProjectRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectRole.
     * @param {ProjectRoleCreateArgs} args - Arguments to create a ProjectRole.
     * @example
     * // Create one ProjectRole
     * const ProjectRole = await prisma.projectRole.create({
     *   data: {
     *     // ... data to create a ProjectRole
     *   }
     * })
     * 
     */
    create<T extends ProjectRoleCreateArgs>(args: SelectSubset<T, ProjectRoleCreateArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectRoles.
     * @param {ProjectRoleCreateManyArgs} args - Arguments to create many ProjectRoles.
     * @example
     * // Create many ProjectRoles
     * const projectRole = await prisma.projectRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectRoleCreateManyArgs>(args?: SelectSubset<T, ProjectRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectRoles and returns the data saved in the database.
     * @param {ProjectRoleCreateManyAndReturnArgs} args - Arguments to create many ProjectRoles.
     * @example
     * // Create many ProjectRoles
     * const projectRole = await prisma.projectRole.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectRoles and only return the `id`
     * const projectRoleWithIdOnly = await prisma.projectRole.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectRoleCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectRoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectRole.
     * @param {ProjectRoleDeleteArgs} args - Arguments to delete one ProjectRole.
     * @example
     * // Delete one ProjectRole
     * const ProjectRole = await prisma.projectRole.delete({
     *   where: {
     *     // ... filter to delete one ProjectRole
     *   }
     * })
     * 
     */
    delete<T extends ProjectRoleDeleteArgs>(args: SelectSubset<T, ProjectRoleDeleteArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectRole.
     * @param {ProjectRoleUpdateArgs} args - Arguments to update one ProjectRole.
     * @example
     * // Update one ProjectRole
     * const projectRole = await prisma.projectRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectRoleUpdateArgs>(args: SelectSubset<T, ProjectRoleUpdateArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectRoles.
     * @param {ProjectRoleDeleteManyArgs} args - Arguments to filter ProjectRoles to delete.
     * @example
     * // Delete a few ProjectRoles
     * const { count } = await prisma.projectRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectRoleDeleteManyArgs>(args?: SelectSubset<T, ProjectRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectRoles
     * const projectRole = await prisma.projectRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectRoleUpdateManyArgs>(args: SelectSubset<T, ProjectRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectRoles and returns the data updated in the database.
     * @param {ProjectRoleUpdateManyAndReturnArgs} args - Arguments to update many ProjectRoles.
     * @example
     * // Update many ProjectRoles
     * const projectRole = await prisma.projectRole.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectRoles and only return the `id`
     * const projectRoleWithIdOnly = await prisma.projectRole.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectRoleUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectRoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectRole.
     * @param {ProjectRoleUpsertArgs} args - Arguments to update or create a ProjectRole.
     * @example
     * // Update or create a ProjectRole
     * const projectRole = await prisma.projectRole.upsert({
     *   create: {
     *     // ... data to create a ProjectRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectRole we want to update
     *   }
     * })
     */
    upsert<T extends ProjectRoleUpsertArgs>(args: SelectSubset<T, ProjectRoleUpsertArgs<ExtArgs>>): Prisma__ProjectRoleClient<$Result.GetResult<Prisma.$ProjectRolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleCountArgs} args - Arguments to filter ProjectRoles to count.
     * @example
     * // Count the number of ProjectRoles
     * const count = await prisma.projectRole.count({
     *   where: {
     *     // ... the filter for the ProjectRoles we want to count
     *   }
     * })
    **/
    count<T extends ProjectRoleCountArgs>(
      args?: Subset<T, ProjectRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectRoleAggregateArgs>(args: Subset<T, ProjectRoleAggregateArgs>): Prisma.PrismaPromise<GetProjectRoleAggregateType<T>>

    /**
     * Group by ProjectRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectRoleGroupByArgs['orderBy'] }
        : { orderBy?: ProjectRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectRole model
   */
  readonly fields: ProjectRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends ProjectRole$workspaceArgs<ExtArgs> = {}>(args?: Subset<T, ProjectRole$workspaceArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    projectMembers<T extends ProjectRole$projectMembersArgs<ExtArgs> = {}>(args?: Subset<T, ProjectRole$projectMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectRole model
   */
  interface ProjectRoleFieldRefs {
    readonly id: FieldRef<"ProjectRole", 'String'>
    readonly workspaceId: FieldRef<"ProjectRole", 'String'>
    readonly name: FieldRef<"ProjectRole", 'String'>
    readonly description: FieldRef<"ProjectRole", 'String'>
    readonly createdAt: FieldRef<"ProjectRole", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectRole", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectRole findUnique
   */
  export type ProjectRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * Filter, which ProjectRole to fetch.
     */
    where: ProjectRoleWhereUniqueInput
  }

  /**
   * ProjectRole findUniqueOrThrow
   */
  export type ProjectRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * Filter, which ProjectRole to fetch.
     */
    where: ProjectRoleWhereUniqueInput
  }

  /**
   * ProjectRole findFirst
   */
  export type ProjectRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * Filter, which ProjectRole to fetch.
     */
    where?: ProjectRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectRoles to fetch.
     */
    orderBy?: ProjectRoleOrderByWithRelationInput | ProjectRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectRoles.
     */
    cursor?: ProjectRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectRoles.
     */
    distinct?: ProjectRoleScalarFieldEnum | ProjectRoleScalarFieldEnum[]
  }

  /**
   * ProjectRole findFirstOrThrow
   */
  export type ProjectRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * Filter, which ProjectRole to fetch.
     */
    where?: ProjectRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectRoles to fetch.
     */
    orderBy?: ProjectRoleOrderByWithRelationInput | ProjectRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectRoles.
     */
    cursor?: ProjectRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectRoles.
     */
    distinct?: ProjectRoleScalarFieldEnum | ProjectRoleScalarFieldEnum[]
  }

  /**
   * ProjectRole findMany
   */
  export type ProjectRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * Filter, which ProjectRoles to fetch.
     */
    where?: ProjectRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectRoles to fetch.
     */
    orderBy?: ProjectRoleOrderByWithRelationInput | ProjectRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectRoles.
     */
    cursor?: ProjectRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectRoles.
     */
    skip?: number
    distinct?: ProjectRoleScalarFieldEnum | ProjectRoleScalarFieldEnum[]
  }

  /**
   * ProjectRole create
   */
  export type ProjectRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectRole.
     */
    data: XOR<ProjectRoleCreateInput, ProjectRoleUncheckedCreateInput>
  }

  /**
   * ProjectRole createMany
   */
  export type ProjectRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectRoles.
     */
    data: ProjectRoleCreateManyInput | ProjectRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectRole createManyAndReturn
   */
  export type ProjectRoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectRoles.
     */
    data: ProjectRoleCreateManyInput | ProjectRoleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectRole update
   */
  export type ProjectRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectRole.
     */
    data: XOR<ProjectRoleUpdateInput, ProjectRoleUncheckedUpdateInput>
    /**
     * Choose, which ProjectRole to update.
     */
    where: ProjectRoleWhereUniqueInput
  }

  /**
   * ProjectRole updateMany
   */
  export type ProjectRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectRoles.
     */
    data: XOR<ProjectRoleUpdateManyMutationInput, ProjectRoleUncheckedUpdateManyInput>
    /**
     * Filter which ProjectRoles to update
     */
    where?: ProjectRoleWhereInput
    /**
     * Limit how many ProjectRoles to update.
     */
    limit?: number
  }

  /**
   * ProjectRole updateManyAndReturn
   */
  export type ProjectRoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * The data used to update ProjectRoles.
     */
    data: XOR<ProjectRoleUpdateManyMutationInput, ProjectRoleUncheckedUpdateManyInput>
    /**
     * Filter which ProjectRoles to update
     */
    where?: ProjectRoleWhereInput
    /**
     * Limit how many ProjectRoles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectRole upsert
   */
  export type ProjectRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectRole to update in case it exists.
     */
    where: ProjectRoleWhereUniqueInput
    /**
     * In case the ProjectRole found by the `where` argument doesn't exist, create a new ProjectRole with this data.
     */
    create: XOR<ProjectRoleCreateInput, ProjectRoleUncheckedCreateInput>
    /**
     * In case the ProjectRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectRoleUpdateInput, ProjectRoleUncheckedUpdateInput>
  }

  /**
   * ProjectRole delete
   */
  export type ProjectRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
    /**
     * Filter which ProjectRole to delete.
     */
    where: ProjectRoleWhereUniqueInput
  }

  /**
   * ProjectRole deleteMany
   */
  export type ProjectRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectRoles to delete
     */
    where?: ProjectRoleWhereInput
    /**
     * Limit how many ProjectRoles to delete.
     */
    limit?: number
  }

  /**
   * ProjectRole.workspace
   */
  export type ProjectRole$workspaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    where?: WorkspaceWhereInput
  }

  /**
   * ProjectRole.projectMembers
   */
  export type ProjectRole$projectMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMember
     */
    select?: ProjectMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMember
     */
    omit?: ProjectMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMemberInclude<ExtArgs> | null
    where?: ProjectMemberWhereInput
    orderBy?: ProjectMemberOrderByWithRelationInput | ProjectMemberOrderByWithRelationInput[]
    cursor?: ProjectMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectMemberScalarFieldEnum | ProjectMemberScalarFieldEnum[]
  }

  /**
   * ProjectRole without action
   */
  export type ProjectRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectRole
     */
    select?: ProjectRoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectRole
     */
    omit?: ProjectRoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectRoleInclude<ExtArgs> | null
  }


  /**
   * Model LeaveType
   */

  export type AggregateLeaveType = {
    _count: LeaveTypeCountAggregateOutputType | null
    _avg: LeaveTypeAvgAggregateOutputType | null
    _sum: LeaveTypeSumAggregateOutputType | null
    _min: LeaveTypeMinAggregateOutputType | null
    _max: LeaveTypeMaxAggregateOutputType | null
  }

  export type LeaveTypeAvgAggregateOutputType = {
    maxDaysPerYear: number | null
  }

  export type LeaveTypeSumAggregateOutputType = {
    maxDaysPerYear: number | null
  }

  export type LeaveTypeMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    code: string | null
    description: string | null
    color: string | null
    isPaid: boolean | null
    requiresApproval: boolean | null
    requiresAttachment: boolean | null
    maxDaysPerYear: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveTypeMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    code: string | null
    description: string | null
    color: string | null
    isPaid: boolean | null
    requiresApproval: boolean | null
    requiresAttachment: boolean | null
    maxDaysPerYear: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveTypeCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    code: number
    description: number
    color: number
    isPaid: number
    requiresApproval: number
    requiresAttachment: number
    maxDaysPerYear: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveTypeAvgAggregateInputType = {
    maxDaysPerYear?: true
  }

  export type LeaveTypeSumAggregateInputType = {
    maxDaysPerYear?: true
  }

  export type LeaveTypeMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    code?: true
    description?: true
    color?: true
    isPaid?: true
    requiresApproval?: true
    requiresAttachment?: true
    maxDaysPerYear?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveTypeMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    code?: true
    description?: true
    color?: true
    isPaid?: true
    requiresApproval?: true
    requiresAttachment?: true
    maxDaysPerYear?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveTypeCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    code?: true
    description?: true
    color?: true
    isPaid?: true
    requiresApproval?: true
    requiresAttachment?: true
    maxDaysPerYear?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveType to aggregate.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveTypes
    **/
    _count?: true | LeaveTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveTypeMaxAggregateInputType
  }

  export type GetLeaveTypeAggregateType<T extends LeaveTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveType[P]>
      : GetScalarType<T[P], AggregateLeaveType[P]>
  }




  export type LeaveTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveTypeWhereInput
    orderBy?: LeaveTypeOrderByWithAggregationInput | LeaveTypeOrderByWithAggregationInput[]
    by: LeaveTypeScalarFieldEnum[] | LeaveTypeScalarFieldEnum
    having?: LeaveTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveTypeCountAggregateInputType | true
    _avg?: LeaveTypeAvgAggregateInputType
    _sum?: LeaveTypeSumAggregateInputType
    _min?: LeaveTypeMinAggregateInputType
    _max?: LeaveTypeMaxAggregateInputType
  }

  export type LeaveTypeGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    code: string
    description: string | null
    color: string | null
    isPaid: boolean
    requiresApproval: boolean
    requiresAttachment: boolean
    maxDaysPerYear: number | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: LeaveTypeCountAggregateOutputType | null
    _avg: LeaveTypeAvgAggregateOutputType | null
    _sum: LeaveTypeSumAggregateOutputType | null
    _min: LeaveTypeMinAggregateOutputType | null
    _max: LeaveTypeMaxAggregateOutputType | null
  }

  type GetLeaveTypeGroupByPayload<T extends LeaveTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveTypeGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveTypeGroupByOutputType[P]>
        }
      >
    >


  export type LeaveTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    color?: boolean
    isPaid?: boolean
    requiresApproval?: boolean
    requiresAttachment?: boolean
    maxDaysPerYear?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    leaveQuotas?: boolean | LeaveType$leaveQuotasArgs<ExtArgs>
    leaves?: boolean | LeaveType$leavesArgs<ExtArgs>
    _count?: boolean | LeaveTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveType"]>

  export type LeaveTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    color?: boolean
    isPaid?: boolean
    requiresApproval?: boolean
    requiresAttachment?: boolean
    maxDaysPerYear?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveType"]>

  export type LeaveTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    color?: boolean
    isPaid?: boolean
    requiresApproval?: boolean
    requiresAttachment?: boolean
    maxDaysPerYear?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveType"]>

  export type LeaveTypeSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    color?: boolean
    isPaid?: boolean
    requiresApproval?: boolean
    requiresAttachment?: boolean
    maxDaysPerYear?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "code" | "description" | "color" | "isPaid" | "requiresApproval" | "requiresAttachment" | "maxDaysPerYear" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["leaveType"]>
  export type LeaveTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    leaveQuotas?: boolean | LeaveType$leaveQuotasArgs<ExtArgs>
    leaves?: boolean | LeaveType$leavesArgs<ExtArgs>
    _count?: boolean | LeaveTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeaveTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type LeaveTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $LeaveTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveType"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      leaveQuotas: Prisma.$LeaveQuotaPayload<ExtArgs>[]
      leaves: Prisma.$LeavePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      code: string
      description: string | null
      color: string | null
      isPaid: boolean
      requiresApproval: boolean
      requiresAttachment: boolean
      maxDaysPerYear: number | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leaveType"]>
    composites: {}
  }

  type LeaveTypeGetPayload<S extends boolean | null | undefined | LeaveTypeDefaultArgs> = $Result.GetResult<Prisma.$LeaveTypePayload, S>

  type LeaveTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveTypeCountAggregateInputType | true
    }

  export interface LeaveTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveType'], meta: { name: 'LeaveType' } }
    /**
     * Find zero or one LeaveType that matches the filter.
     * @param {LeaveTypeFindUniqueArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveTypeFindUniqueArgs>(args: SelectSubset<T, LeaveTypeFindUniqueArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeaveType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveTypeFindUniqueOrThrowArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeFindFirstArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveTypeFindFirstArgs>(args?: SelectSubset<T, LeaveTypeFindFirstArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeFindFirstOrThrowArgs} args - Arguments to find a LeaveType
     * @example
     * // Get one LeaveType
     * const leaveType = await prisma.leaveType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeaveTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveTypes
     * const leaveTypes = await prisma.leaveType.findMany()
     * 
     * // Get first 10 LeaveTypes
     * const leaveTypes = await prisma.leaveType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveTypeWithIdOnly = await prisma.leaveType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveTypeFindManyArgs>(args?: SelectSubset<T, LeaveTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeaveType.
     * @param {LeaveTypeCreateArgs} args - Arguments to create a LeaveType.
     * @example
     * // Create one LeaveType
     * const LeaveType = await prisma.leaveType.create({
     *   data: {
     *     // ... data to create a LeaveType
     *   }
     * })
     * 
     */
    create<T extends LeaveTypeCreateArgs>(args: SelectSubset<T, LeaveTypeCreateArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeaveTypes.
     * @param {LeaveTypeCreateManyArgs} args - Arguments to create many LeaveTypes.
     * @example
     * // Create many LeaveTypes
     * const leaveType = await prisma.leaveType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveTypeCreateManyArgs>(args?: SelectSubset<T, LeaveTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveTypes and returns the data saved in the database.
     * @param {LeaveTypeCreateManyAndReturnArgs} args - Arguments to create many LeaveTypes.
     * @example
     * // Create many LeaveTypes
     * const leaveType = await prisma.leaveType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveTypes and only return the `id`
     * const leaveTypeWithIdOnly = await prisma.leaveType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeaveType.
     * @param {LeaveTypeDeleteArgs} args - Arguments to delete one LeaveType.
     * @example
     * // Delete one LeaveType
     * const LeaveType = await prisma.leaveType.delete({
     *   where: {
     *     // ... filter to delete one LeaveType
     *   }
     * })
     * 
     */
    delete<T extends LeaveTypeDeleteArgs>(args: SelectSubset<T, LeaveTypeDeleteArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeaveType.
     * @param {LeaveTypeUpdateArgs} args - Arguments to update one LeaveType.
     * @example
     * // Update one LeaveType
     * const leaveType = await prisma.leaveType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveTypeUpdateArgs>(args: SelectSubset<T, LeaveTypeUpdateArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeaveTypes.
     * @param {LeaveTypeDeleteManyArgs} args - Arguments to filter LeaveTypes to delete.
     * @example
     * // Delete a few LeaveTypes
     * const { count } = await prisma.leaveType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveTypeDeleteManyArgs>(args?: SelectSubset<T, LeaveTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveTypes
     * const leaveType = await prisma.leaveType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveTypeUpdateManyArgs>(args: SelectSubset<T, LeaveTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveTypes and returns the data updated in the database.
     * @param {LeaveTypeUpdateManyAndReturnArgs} args - Arguments to update many LeaveTypes.
     * @example
     * // Update many LeaveTypes
     * const leaveType = await prisma.leaveType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeaveTypes and only return the `id`
     * const leaveTypeWithIdOnly = await prisma.leaveType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaveTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaveTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeaveType.
     * @param {LeaveTypeUpsertArgs} args - Arguments to update or create a LeaveType.
     * @example
     * // Update or create a LeaveType
     * const leaveType = await prisma.leaveType.upsert({
     *   create: {
     *     // ... data to create a LeaveType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveType we want to update
     *   }
     * })
     */
    upsert<T extends LeaveTypeUpsertArgs>(args: SelectSubset<T, LeaveTypeUpsertArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeaveTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeCountArgs} args - Arguments to filter LeaveTypes to count.
     * @example
     * // Count the number of LeaveTypes
     * const count = await prisma.leaveType.count({
     *   where: {
     *     // ... the filter for the LeaveTypes we want to count
     *   }
     * })
    **/
    count<T extends LeaveTypeCountArgs>(
      args?: Subset<T, LeaveTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveTypeAggregateArgs>(args: Subset<T, LeaveTypeAggregateArgs>): Prisma.PrismaPromise<GetLeaveTypeAggregateType<T>>

    /**
     * Group by LeaveType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveTypeGroupByArgs['orderBy'] }
        : { orderBy?: LeaveTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveType model
   */
  readonly fields: LeaveTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    leaveQuotas<T extends LeaveType$leaveQuotasArgs<ExtArgs> = {}>(args?: Subset<T, LeaveType$leaveQuotasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveQuotaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leaves<T extends LeaveType$leavesArgs<ExtArgs> = {}>(args?: Subset<T, LeaveType$leavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveType model
   */
  interface LeaveTypeFieldRefs {
    readonly id: FieldRef<"LeaveType", 'String'>
    readonly workspaceId: FieldRef<"LeaveType", 'String'>
    readonly name: FieldRef<"LeaveType", 'String'>
    readonly code: FieldRef<"LeaveType", 'String'>
    readonly description: FieldRef<"LeaveType", 'String'>
    readonly color: FieldRef<"LeaveType", 'String'>
    readonly isPaid: FieldRef<"LeaveType", 'Boolean'>
    readonly requiresApproval: FieldRef<"LeaveType", 'Boolean'>
    readonly requiresAttachment: FieldRef<"LeaveType", 'Boolean'>
    readonly maxDaysPerYear: FieldRef<"LeaveType", 'Int'>
    readonly status: FieldRef<"LeaveType", 'String'>
    readonly createdAt: FieldRef<"LeaveType", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaveType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveType findUnique
   */
  export type LeaveTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where: LeaveTypeWhereUniqueInput
  }

  /**
   * LeaveType findUniqueOrThrow
   */
  export type LeaveTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where: LeaveTypeWhereUniqueInput
  }

  /**
   * LeaveType findFirst
   */
  export type LeaveTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveTypes.
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveTypes.
     */
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }

  /**
   * LeaveType findFirstOrThrow
   */
  export type LeaveTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveType to fetch.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveTypes.
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveTypes.
     */
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }

  /**
   * LeaveType findMany
   */
  export type LeaveTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter, which LeaveTypes to fetch.
     */
    where?: LeaveTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveTypes to fetch.
     */
    orderBy?: LeaveTypeOrderByWithRelationInput | LeaveTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveTypes.
     */
    cursor?: LeaveTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveTypes.
     */
    skip?: number
    distinct?: LeaveTypeScalarFieldEnum | LeaveTypeScalarFieldEnum[]
  }

  /**
   * LeaveType create
   */
  export type LeaveTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveType.
     */
    data: XOR<LeaveTypeCreateInput, LeaveTypeUncheckedCreateInput>
  }

  /**
   * LeaveType createMany
   */
  export type LeaveTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveTypes.
     */
    data: LeaveTypeCreateManyInput | LeaveTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveType createManyAndReturn
   */
  export type LeaveTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * The data used to create many LeaveTypes.
     */
    data: LeaveTypeCreateManyInput | LeaveTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveType update
   */
  export type LeaveTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveType.
     */
    data: XOR<LeaveTypeUpdateInput, LeaveTypeUncheckedUpdateInput>
    /**
     * Choose, which LeaveType to update.
     */
    where: LeaveTypeWhereUniqueInput
  }

  /**
   * LeaveType updateMany
   */
  export type LeaveTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveTypes.
     */
    data: XOR<LeaveTypeUpdateManyMutationInput, LeaveTypeUncheckedUpdateManyInput>
    /**
     * Filter which LeaveTypes to update
     */
    where?: LeaveTypeWhereInput
    /**
     * Limit how many LeaveTypes to update.
     */
    limit?: number
  }

  /**
   * LeaveType updateManyAndReturn
   */
  export type LeaveTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * The data used to update LeaveTypes.
     */
    data: XOR<LeaveTypeUpdateManyMutationInput, LeaveTypeUncheckedUpdateManyInput>
    /**
     * Filter which LeaveTypes to update
     */
    where?: LeaveTypeWhereInput
    /**
     * Limit how many LeaveTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveType upsert
   */
  export type LeaveTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveType to update in case it exists.
     */
    where: LeaveTypeWhereUniqueInput
    /**
     * In case the LeaveType found by the `where` argument doesn't exist, create a new LeaveType with this data.
     */
    create: XOR<LeaveTypeCreateInput, LeaveTypeUncheckedCreateInput>
    /**
     * In case the LeaveType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveTypeUpdateInput, LeaveTypeUncheckedUpdateInput>
  }

  /**
   * LeaveType delete
   */
  export type LeaveTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
    /**
     * Filter which LeaveType to delete.
     */
    where: LeaveTypeWhereUniqueInput
  }

  /**
   * LeaveType deleteMany
   */
  export type LeaveTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveTypes to delete
     */
    where?: LeaveTypeWhereInput
    /**
     * Limit how many LeaveTypes to delete.
     */
    limit?: number
  }

  /**
   * LeaveType.leaveQuotas
   */
  export type LeaveType$leaveQuotasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveQuota
     */
    select?: LeaveQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveQuota
     */
    omit?: LeaveQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveQuotaInclude<ExtArgs> | null
    where?: LeaveQuotaWhereInput
    orderBy?: LeaveQuotaOrderByWithRelationInput | LeaveQuotaOrderByWithRelationInput[]
    cursor?: LeaveQuotaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveQuotaScalarFieldEnum | LeaveQuotaScalarFieldEnum[]
  }

  /**
   * LeaveType.leaves
   */
  export type LeaveType$leavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    cursor?: LeaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * LeaveType without action
   */
  export type LeaveTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveType
     */
    select?: LeaveTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveType
     */
    omit?: LeaveTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveTypeInclude<ExtArgs> | null
  }


  /**
   * Model LeaveQuota
   */

  export type AggregateLeaveQuota = {
    _count: LeaveQuotaCountAggregateOutputType | null
    _avg: LeaveQuotaAvgAggregateOutputType | null
    _sum: LeaveQuotaSumAggregateOutputType | null
    _min: LeaveQuotaMinAggregateOutputType | null
    _max: LeaveQuotaMaxAggregateOutputType | null
  }

  export type LeaveQuotaAvgAggregateOutputType = {
    year: number | null
    total: number | null
    used: number | null
    pending: number | null
    remaining: number | null
  }

  export type LeaveQuotaSumAggregateOutputType = {
    year: number | null
    total: number | null
    used: number | null
    pending: number | null
    remaining: number | null
  }

  export type LeaveQuotaMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    employeeId: string | null
    leaveTypeId: string | null
    year: number | null
    total: number | null
    used: number | null
    pending: number | null
    remaining: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveQuotaMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    employeeId: string | null
    leaveTypeId: string | null
    year: number | null
    total: number | null
    used: number | null
    pending: number | null
    remaining: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveQuotaCountAggregateOutputType = {
    id: number
    workspaceId: number
    employeeId: number
    leaveTypeId: number
    year: number
    total: number
    used: number
    pending: number
    remaining: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveQuotaAvgAggregateInputType = {
    year?: true
    total?: true
    used?: true
    pending?: true
    remaining?: true
  }

  export type LeaveQuotaSumAggregateInputType = {
    year?: true
    total?: true
    used?: true
    pending?: true
    remaining?: true
  }

  export type LeaveQuotaMinAggregateInputType = {
    id?: true
    workspaceId?: true
    employeeId?: true
    leaveTypeId?: true
    year?: true
    total?: true
    used?: true
    pending?: true
    remaining?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveQuotaMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    employeeId?: true
    leaveTypeId?: true
    year?: true
    total?: true
    used?: true
    pending?: true
    remaining?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveQuotaCountAggregateInputType = {
    id?: true
    workspaceId?: true
    employeeId?: true
    leaveTypeId?: true
    year?: true
    total?: true
    used?: true
    pending?: true
    remaining?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveQuotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveQuota to aggregate.
     */
    where?: LeaveQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveQuotas to fetch.
     */
    orderBy?: LeaveQuotaOrderByWithRelationInput | LeaveQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveQuotas
    **/
    _count?: true | LeaveQuotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveQuotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveQuotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveQuotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveQuotaMaxAggregateInputType
  }

  export type GetLeaveQuotaAggregateType<T extends LeaveQuotaAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveQuota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveQuota[P]>
      : GetScalarType<T[P], AggregateLeaveQuota[P]>
  }




  export type LeaveQuotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveQuotaWhereInput
    orderBy?: LeaveQuotaOrderByWithAggregationInput | LeaveQuotaOrderByWithAggregationInput[]
    by: LeaveQuotaScalarFieldEnum[] | LeaveQuotaScalarFieldEnum
    having?: LeaveQuotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveQuotaCountAggregateInputType | true
    _avg?: LeaveQuotaAvgAggregateInputType
    _sum?: LeaveQuotaSumAggregateInputType
    _min?: LeaveQuotaMinAggregateInputType
    _max?: LeaveQuotaMaxAggregateInputType
  }

  export type LeaveQuotaGroupByOutputType = {
    id: string
    workspaceId: string
    employeeId: string
    leaveTypeId: string
    year: number
    total: number
    used: number
    pending: number
    remaining: number
    createdAt: Date
    updatedAt: Date
    _count: LeaveQuotaCountAggregateOutputType | null
    _avg: LeaveQuotaAvgAggregateOutputType | null
    _sum: LeaveQuotaSumAggregateOutputType | null
    _min: LeaveQuotaMinAggregateOutputType | null
    _max: LeaveQuotaMaxAggregateOutputType | null
  }

  type GetLeaveQuotaGroupByPayload<T extends LeaveQuotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveQuotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveQuotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveQuotaGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveQuotaGroupByOutputType[P]>
        }
      >
    >


  export type LeaveQuotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    year?: boolean
    total?: boolean
    used?: boolean
    pending?: boolean
    remaining?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveQuota"]>

  export type LeaveQuotaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    year?: boolean
    total?: boolean
    used?: boolean
    pending?: boolean
    remaining?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveQuota"]>

  export type LeaveQuotaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    year?: boolean
    total?: boolean
    used?: boolean
    pending?: boolean
    remaining?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveQuota"]>

  export type LeaveQuotaSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    year?: boolean
    total?: boolean
    used?: boolean
    pending?: boolean
    remaining?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveQuotaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "employeeId" | "leaveTypeId" | "year" | "total" | "used" | "pending" | "remaining" | "createdAt" | "updatedAt", ExtArgs["result"]["leaveQuota"]>
  export type LeaveQuotaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }
  export type LeaveQuotaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }
  export type LeaveQuotaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }

  export type $LeaveQuotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveQuota"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
      leaveType: Prisma.$LeaveTypePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      employeeId: string
      leaveTypeId: string
      year: number
      total: number
      used: number
      pending: number
      remaining: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leaveQuota"]>
    composites: {}
  }

  type LeaveQuotaGetPayload<S extends boolean | null | undefined | LeaveQuotaDefaultArgs> = $Result.GetResult<Prisma.$LeaveQuotaPayload, S>

  type LeaveQuotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveQuotaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveQuotaCountAggregateInputType | true
    }

  export interface LeaveQuotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveQuota'], meta: { name: 'LeaveQuota' } }
    /**
     * Find zero or one LeaveQuota that matches the filter.
     * @param {LeaveQuotaFindUniqueArgs} args - Arguments to find a LeaveQuota
     * @example
     * // Get one LeaveQuota
     * const leaveQuota = await prisma.leaveQuota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveQuotaFindUniqueArgs>(args: SelectSubset<T, LeaveQuotaFindUniqueArgs<ExtArgs>>): Prisma__LeaveQuotaClient<$Result.GetResult<Prisma.$LeaveQuotaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LeaveQuota that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveQuotaFindUniqueOrThrowArgs} args - Arguments to find a LeaveQuota
     * @example
     * // Get one LeaveQuota
     * const leaveQuota = await prisma.leaveQuota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveQuotaFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveQuotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveQuotaClient<$Result.GetResult<Prisma.$LeaveQuotaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveQuota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveQuotaFindFirstArgs} args - Arguments to find a LeaveQuota
     * @example
     * // Get one LeaveQuota
     * const leaveQuota = await prisma.leaveQuota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveQuotaFindFirstArgs>(args?: SelectSubset<T, LeaveQuotaFindFirstArgs<ExtArgs>>): Prisma__LeaveQuotaClient<$Result.GetResult<Prisma.$LeaveQuotaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LeaveQuota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveQuotaFindFirstOrThrowArgs} args - Arguments to find a LeaveQuota
     * @example
     * // Get one LeaveQuota
     * const leaveQuota = await prisma.leaveQuota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveQuotaFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveQuotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveQuotaClient<$Result.GetResult<Prisma.$LeaveQuotaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LeaveQuotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveQuotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveQuotas
     * const leaveQuotas = await prisma.leaveQuota.findMany()
     * 
     * // Get first 10 LeaveQuotas
     * const leaveQuotas = await prisma.leaveQuota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveQuotaWithIdOnly = await prisma.leaveQuota.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveQuotaFindManyArgs>(args?: SelectSubset<T, LeaveQuotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveQuotaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LeaveQuota.
     * @param {LeaveQuotaCreateArgs} args - Arguments to create a LeaveQuota.
     * @example
     * // Create one LeaveQuota
     * const LeaveQuota = await prisma.leaveQuota.create({
     *   data: {
     *     // ... data to create a LeaveQuota
     *   }
     * })
     * 
     */
    create<T extends LeaveQuotaCreateArgs>(args: SelectSubset<T, LeaveQuotaCreateArgs<ExtArgs>>): Prisma__LeaveQuotaClient<$Result.GetResult<Prisma.$LeaveQuotaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LeaveQuotas.
     * @param {LeaveQuotaCreateManyArgs} args - Arguments to create many LeaveQuotas.
     * @example
     * // Create many LeaveQuotas
     * const leaveQuota = await prisma.leaveQuota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveQuotaCreateManyArgs>(args?: SelectSubset<T, LeaveQuotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveQuotas and returns the data saved in the database.
     * @param {LeaveQuotaCreateManyAndReturnArgs} args - Arguments to create many LeaveQuotas.
     * @example
     * // Create many LeaveQuotas
     * const leaveQuota = await prisma.leaveQuota.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveQuotas and only return the `id`
     * const leaveQuotaWithIdOnly = await prisma.leaveQuota.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveQuotaCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveQuotaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveQuotaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LeaveQuota.
     * @param {LeaveQuotaDeleteArgs} args - Arguments to delete one LeaveQuota.
     * @example
     * // Delete one LeaveQuota
     * const LeaveQuota = await prisma.leaveQuota.delete({
     *   where: {
     *     // ... filter to delete one LeaveQuota
     *   }
     * })
     * 
     */
    delete<T extends LeaveQuotaDeleteArgs>(args: SelectSubset<T, LeaveQuotaDeleteArgs<ExtArgs>>): Prisma__LeaveQuotaClient<$Result.GetResult<Prisma.$LeaveQuotaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LeaveQuota.
     * @param {LeaveQuotaUpdateArgs} args - Arguments to update one LeaveQuota.
     * @example
     * // Update one LeaveQuota
     * const leaveQuota = await prisma.leaveQuota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveQuotaUpdateArgs>(args: SelectSubset<T, LeaveQuotaUpdateArgs<ExtArgs>>): Prisma__LeaveQuotaClient<$Result.GetResult<Prisma.$LeaveQuotaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LeaveQuotas.
     * @param {LeaveQuotaDeleteManyArgs} args - Arguments to filter LeaveQuotas to delete.
     * @example
     * // Delete a few LeaveQuotas
     * const { count } = await prisma.leaveQuota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveQuotaDeleteManyArgs>(args?: SelectSubset<T, LeaveQuotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveQuotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveQuotas
     * const leaveQuota = await prisma.leaveQuota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveQuotaUpdateManyArgs>(args: SelectSubset<T, LeaveQuotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveQuotas and returns the data updated in the database.
     * @param {LeaveQuotaUpdateManyAndReturnArgs} args - Arguments to update many LeaveQuotas.
     * @example
     * // Update many LeaveQuotas
     * const leaveQuota = await prisma.leaveQuota.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LeaveQuotas and only return the `id`
     * const leaveQuotaWithIdOnly = await prisma.leaveQuota.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaveQuotaUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaveQuotaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveQuotaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LeaveQuota.
     * @param {LeaveQuotaUpsertArgs} args - Arguments to update or create a LeaveQuota.
     * @example
     * // Update or create a LeaveQuota
     * const leaveQuota = await prisma.leaveQuota.upsert({
     *   create: {
     *     // ... data to create a LeaveQuota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveQuota we want to update
     *   }
     * })
     */
    upsert<T extends LeaveQuotaUpsertArgs>(args: SelectSubset<T, LeaveQuotaUpsertArgs<ExtArgs>>): Prisma__LeaveQuotaClient<$Result.GetResult<Prisma.$LeaveQuotaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LeaveQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveQuotaCountArgs} args - Arguments to filter LeaveQuotas to count.
     * @example
     * // Count the number of LeaveQuotas
     * const count = await prisma.leaveQuota.count({
     *   where: {
     *     // ... the filter for the LeaveQuotas we want to count
     *   }
     * })
    **/
    count<T extends LeaveQuotaCountArgs>(
      args?: Subset<T, LeaveQuotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveQuotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveQuotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveQuotaAggregateArgs>(args: Subset<T, LeaveQuotaAggregateArgs>): Prisma.PrismaPromise<GetLeaveQuotaAggregateType<T>>

    /**
     * Group by LeaveQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveQuotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveQuotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveQuotaGroupByArgs['orderBy'] }
        : { orderBy?: LeaveQuotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveQuotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveQuotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveQuota model
   */
  readonly fields: LeaveQuotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveQuota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveQuotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    leaveType<T extends LeaveTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaveTypeDefaultArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveQuota model
   */
  interface LeaveQuotaFieldRefs {
    readonly id: FieldRef<"LeaveQuota", 'String'>
    readonly workspaceId: FieldRef<"LeaveQuota", 'String'>
    readonly employeeId: FieldRef<"LeaveQuota", 'String'>
    readonly leaveTypeId: FieldRef<"LeaveQuota", 'String'>
    readonly year: FieldRef<"LeaveQuota", 'Int'>
    readonly total: FieldRef<"LeaveQuota", 'Float'>
    readonly used: FieldRef<"LeaveQuota", 'Float'>
    readonly pending: FieldRef<"LeaveQuota", 'Float'>
    readonly remaining: FieldRef<"LeaveQuota", 'Float'>
    readonly createdAt: FieldRef<"LeaveQuota", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaveQuota", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveQuota findUnique
   */
  export type LeaveQuotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveQuota
     */
    select?: LeaveQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveQuota
     */
    omit?: LeaveQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveQuotaInclude<ExtArgs> | null
    /**
     * Filter, which LeaveQuota to fetch.
     */
    where: LeaveQuotaWhereUniqueInput
  }

  /**
   * LeaveQuota findUniqueOrThrow
   */
  export type LeaveQuotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveQuota
     */
    select?: LeaveQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveQuota
     */
    omit?: LeaveQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveQuotaInclude<ExtArgs> | null
    /**
     * Filter, which LeaveQuota to fetch.
     */
    where: LeaveQuotaWhereUniqueInput
  }

  /**
   * LeaveQuota findFirst
   */
  export type LeaveQuotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveQuota
     */
    select?: LeaveQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveQuota
     */
    omit?: LeaveQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveQuotaInclude<ExtArgs> | null
    /**
     * Filter, which LeaveQuota to fetch.
     */
    where?: LeaveQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveQuotas to fetch.
     */
    orderBy?: LeaveQuotaOrderByWithRelationInput | LeaveQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveQuotas.
     */
    cursor?: LeaveQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveQuotas.
     */
    distinct?: LeaveQuotaScalarFieldEnum | LeaveQuotaScalarFieldEnum[]
  }

  /**
   * LeaveQuota findFirstOrThrow
   */
  export type LeaveQuotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveQuota
     */
    select?: LeaveQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveQuota
     */
    omit?: LeaveQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveQuotaInclude<ExtArgs> | null
    /**
     * Filter, which LeaveQuota to fetch.
     */
    where?: LeaveQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveQuotas to fetch.
     */
    orderBy?: LeaveQuotaOrderByWithRelationInput | LeaveQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveQuotas.
     */
    cursor?: LeaveQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveQuotas.
     */
    distinct?: LeaveQuotaScalarFieldEnum | LeaveQuotaScalarFieldEnum[]
  }

  /**
   * LeaveQuota findMany
   */
  export type LeaveQuotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveQuota
     */
    select?: LeaveQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveQuota
     */
    omit?: LeaveQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveQuotaInclude<ExtArgs> | null
    /**
     * Filter, which LeaveQuotas to fetch.
     */
    where?: LeaveQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveQuotas to fetch.
     */
    orderBy?: LeaveQuotaOrderByWithRelationInput | LeaveQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveQuotas.
     */
    cursor?: LeaveQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveQuotas.
     */
    skip?: number
    distinct?: LeaveQuotaScalarFieldEnum | LeaveQuotaScalarFieldEnum[]
  }

  /**
   * LeaveQuota create
   */
  export type LeaveQuotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveQuota
     */
    select?: LeaveQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveQuota
     */
    omit?: LeaveQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveQuotaInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveQuota.
     */
    data: XOR<LeaveQuotaCreateInput, LeaveQuotaUncheckedCreateInput>
  }

  /**
   * LeaveQuota createMany
   */
  export type LeaveQuotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveQuotas.
     */
    data: LeaveQuotaCreateManyInput | LeaveQuotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveQuota createManyAndReturn
   */
  export type LeaveQuotaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveQuota
     */
    select?: LeaveQuotaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveQuota
     */
    omit?: LeaveQuotaOmit<ExtArgs> | null
    /**
     * The data used to create many LeaveQuotas.
     */
    data: LeaveQuotaCreateManyInput | LeaveQuotaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveQuotaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveQuota update
   */
  export type LeaveQuotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveQuota
     */
    select?: LeaveQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveQuota
     */
    omit?: LeaveQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveQuotaInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveQuota.
     */
    data: XOR<LeaveQuotaUpdateInput, LeaveQuotaUncheckedUpdateInput>
    /**
     * Choose, which LeaveQuota to update.
     */
    where: LeaveQuotaWhereUniqueInput
  }

  /**
   * LeaveQuota updateMany
   */
  export type LeaveQuotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveQuotas.
     */
    data: XOR<LeaveQuotaUpdateManyMutationInput, LeaveQuotaUncheckedUpdateManyInput>
    /**
     * Filter which LeaveQuotas to update
     */
    where?: LeaveQuotaWhereInput
    /**
     * Limit how many LeaveQuotas to update.
     */
    limit?: number
  }

  /**
   * LeaveQuota updateManyAndReturn
   */
  export type LeaveQuotaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveQuota
     */
    select?: LeaveQuotaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveQuota
     */
    omit?: LeaveQuotaOmit<ExtArgs> | null
    /**
     * The data used to update LeaveQuotas.
     */
    data: XOR<LeaveQuotaUpdateManyMutationInput, LeaveQuotaUncheckedUpdateManyInput>
    /**
     * Filter which LeaveQuotas to update
     */
    where?: LeaveQuotaWhereInput
    /**
     * Limit how many LeaveQuotas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveQuotaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveQuota upsert
   */
  export type LeaveQuotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveQuota
     */
    select?: LeaveQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveQuota
     */
    omit?: LeaveQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveQuotaInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveQuota to update in case it exists.
     */
    where: LeaveQuotaWhereUniqueInput
    /**
     * In case the LeaveQuota found by the `where` argument doesn't exist, create a new LeaveQuota with this data.
     */
    create: XOR<LeaveQuotaCreateInput, LeaveQuotaUncheckedCreateInput>
    /**
     * In case the LeaveQuota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveQuotaUpdateInput, LeaveQuotaUncheckedUpdateInput>
  }

  /**
   * LeaveQuota delete
   */
  export type LeaveQuotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveQuota
     */
    select?: LeaveQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveQuota
     */
    omit?: LeaveQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveQuotaInclude<ExtArgs> | null
    /**
     * Filter which LeaveQuota to delete.
     */
    where: LeaveQuotaWhereUniqueInput
  }

  /**
   * LeaveQuota deleteMany
   */
  export type LeaveQuotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveQuotas to delete
     */
    where?: LeaveQuotaWhereInput
    /**
     * Limit how many LeaveQuotas to delete.
     */
    limit?: number
  }

  /**
   * LeaveQuota without action
   */
  export type LeaveQuotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveQuota
     */
    select?: LeaveQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LeaveQuota
     */
    omit?: LeaveQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveQuotaInclude<ExtArgs> | null
  }


  /**
   * Model Leave
   */

  export type AggregateLeave = {
    _count: LeaveCountAggregateOutputType | null
    _avg: LeaveAvgAggregateOutputType | null
    _sum: LeaveSumAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  export type LeaveAvgAggregateOutputType = {
    duration: number | null
  }

  export type LeaveSumAggregateOutputType = {
    duration: number | null
  }

  export type LeaveMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    employeeId: string | null
    leaveTypeId: string | null
    startDate: Date | null
    endDate: Date | null
    halfDay: boolean | null
    duration: number | null
    reason: string | null
    attachment: string | null
    status: $Enums.LeaveStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    employeeId: string | null
    leaveTypeId: string | null
    startDate: Date | null
    endDate: Date | null
    halfDay: boolean | null
    duration: number | null
    reason: string | null
    attachment: string | null
    status: $Enums.LeaveStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveCountAggregateOutputType = {
    id: number
    workspaceId: number
    employeeId: number
    leaveTypeId: number
    startDate: number
    endDate: number
    halfDay: number
    duration: number
    reason: number
    attachment: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveAvgAggregateInputType = {
    duration?: true
  }

  export type LeaveSumAggregateInputType = {
    duration?: true
  }

  export type LeaveMinAggregateInputType = {
    id?: true
    workspaceId?: true
    employeeId?: true
    leaveTypeId?: true
    startDate?: true
    endDate?: true
    halfDay?: true
    duration?: true
    reason?: true
    attachment?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    employeeId?: true
    leaveTypeId?: true
    startDate?: true
    endDate?: true
    halfDay?: true
    duration?: true
    reason?: true
    attachment?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveCountAggregateInputType = {
    id?: true
    workspaceId?: true
    employeeId?: true
    leaveTypeId?: true
    startDate?: true
    endDate?: true
    halfDay?: true
    duration?: true
    reason?: true
    attachment?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave to aggregate.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leaves
    **/
    _count?: true | LeaveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveMaxAggregateInputType
  }

  export type GetLeaveAggregateType<T extends LeaveAggregateArgs> = {
        [P in keyof T & keyof AggregateLeave]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeave[P]>
      : GetScalarType<T[P], AggregateLeave[P]>
  }




  export type LeaveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithAggregationInput | LeaveOrderByWithAggregationInput[]
    by: LeaveScalarFieldEnum[] | LeaveScalarFieldEnum
    having?: LeaveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveCountAggregateInputType | true
    _avg?: LeaveAvgAggregateInputType
    _sum?: LeaveSumAggregateInputType
    _min?: LeaveMinAggregateInputType
    _max?: LeaveMaxAggregateInputType
  }

  export type LeaveGroupByOutputType = {
    id: string
    workspaceId: string
    employeeId: string
    leaveTypeId: string
    startDate: Date
    endDate: Date
    halfDay: boolean
    duration: number
    reason: string | null
    attachment: string | null
    status: $Enums.LeaveStatus
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: LeaveCountAggregateOutputType | null
    _avg: LeaveAvgAggregateOutputType | null
    _sum: LeaveSumAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  type GetLeaveGroupByPayload<T extends LeaveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveGroupByOutputType[P]>
        }
      >
    >


  export type LeaveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    startDate?: boolean
    endDate?: boolean
    halfDay?: boolean
    duration?: boolean
    reason?: boolean
    attachment?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
    approval?: boolean | Leave$approvalArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    startDate?: boolean
    endDate?: boolean
    halfDay?: boolean
    duration?: boolean
    reason?: boolean
    attachment?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    startDate?: boolean
    endDate?: boolean
    halfDay?: boolean
    duration?: boolean
    reason?: boolean
    attachment?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>

  export type LeaveSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    employeeId?: boolean
    leaveTypeId?: boolean
    startDate?: boolean
    endDate?: boolean
    halfDay?: boolean
    duration?: boolean
    reason?: boolean
    attachment?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "employeeId" | "leaveTypeId" | "startDate" | "endDate" | "halfDay" | "duration" | "reason" | "attachment" | "status" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["leave"]>
  export type LeaveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
    approval?: boolean | Leave$approvalArgs<ExtArgs>
  }
  export type LeaveIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }
  export type LeaveIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    leaveType?: boolean | LeaveTypeDefaultArgs<ExtArgs>
  }

  export type $LeavePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leave"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
      leaveType: Prisma.$LeaveTypePayload<ExtArgs>
      approval: Prisma.$ApprovalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      employeeId: string
      leaveTypeId: string
      startDate: Date
      endDate: Date
      halfDay: boolean
      duration: number
      reason: string | null
      attachment: string | null
      status: $Enums.LeaveStatus
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leave"]>
    composites: {}
  }

  type LeaveGetPayload<S extends boolean | null | undefined | LeaveDefaultArgs> = $Result.GetResult<Prisma.$LeavePayload, S>

  type LeaveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeaveFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeaveCountAggregateInputType | true
    }

  export interface LeaveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leave'], meta: { name: 'Leave' } }
    /**
     * Find zero or one Leave that matches the filter.
     * @param {LeaveFindUniqueArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveFindUniqueArgs>(args: SelectSubset<T, LeaveFindUniqueArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Leave that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeaveFindUniqueOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveFindFirstArgs>(args?: SelectSubset<T, LeaveFindFirstArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Leave that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaves
     * const leaves = await prisma.leave.findMany()
     * 
     * // Get first 10 Leaves
     * const leaves = await prisma.leave.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveWithIdOnly = await prisma.leave.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveFindManyArgs>(args?: SelectSubset<T, LeaveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Leave.
     * @param {LeaveCreateArgs} args - Arguments to create a Leave.
     * @example
     * // Create one Leave
     * const Leave = await prisma.leave.create({
     *   data: {
     *     // ... data to create a Leave
     *   }
     * })
     * 
     */
    create<T extends LeaveCreateArgs>(args: SelectSubset<T, LeaveCreateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leaves.
     * @param {LeaveCreateManyArgs} args - Arguments to create many Leaves.
     * @example
     * // Create many Leaves
     * const leave = await prisma.leave.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveCreateManyArgs>(args?: SelectSubset<T, LeaveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leaves and returns the data saved in the database.
     * @param {LeaveCreateManyAndReturnArgs} args - Arguments to create many Leaves.
     * @example
     * // Create many Leaves
     * const leave = await prisma.leave.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leaves and only return the `id`
     * const leaveWithIdOnly = await prisma.leave.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Leave.
     * @param {LeaveDeleteArgs} args - Arguments to delete one Leave.
     * @example
     * // Delete one Leave
     * const Leave = await prisma.leave.delete({
     *   where: {
     *     // ... filter to delete one Leave
     *   }
     * })
     * 
     */
    delete<T extends LeaveDeleteArgs>(args: SelectSubset<T, LeaveDeleteArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Leave.
     * @param {LeaveUpdateArgs} args - Arguments to update one Leave.
     * @example
     * // Update one Leave
     * const leave = await prisma.leave.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveUpdateArgs>(args: SelectSubset<T, LeaveUpdateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leaves.
     * @param {LeaveDeleteManyArgs} args - Arguments to filter Leaves to delete.
     * @example
     * // Delete a few Leaves
     * const { count } = await prisma.leave.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveDeleteManyArgs>(args?: SelectSubset<T, LeaveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaves
     * const leave = await prisma.leave.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveUpdateManyArgs>(args: SelectSubset<T, LeaveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaves and returns the data updated in the database.
     * @param {LeaveUpdateManyAndReturnArgs} args - Arguments to update many Leaves.
     * @example
     * // Update many Leaves
     * const leave = await prisma.leave.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leaves and only return the `id`
     * const leaveWithIdOnly = await prisma.leave.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeaveUpdateManyAndReturnArgs>(args: SelectSubset<T, LeaveUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Leave.
     * @param {LeaveUpsertArgs} args - Arguments to update or create a Leave.
     * @example
     * // Update or create a Leave
     * const leave = await prisma.leave.upsert({
     *   create: {
     *     // ... data to create a Leave
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leave we want to update
     *   }
     * })
     */
    upsert<T extends LeaveUpsertArgs>(args: SelectSubset<T, LeaveUpsertArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveCountArgs} args - Arguments to filter Leaves to count.
     * @example
     * // Count the number of Leaves
     * const count = await prisma.leave.count({
     *   where: {
     *     // ... the filter for the Leaves we want to count
     *   }
     * })
    **/
    count<T extends LeaveCountArgs>(
      args?: Subset<T, LeaveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveAggregateArgs>(args: Subset<T, LeaveAggregateArgs>): Prisma.PrismaPromise<GetLeaveAggregateType<T>>

    /**
     * Group by Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveGroupByArgs['orderBy'] }
        : { orderBy?: LeaveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leave model
   */
  readonly fields: LeaveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leave.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    leaveType<T extends LeaveTypeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeaveTypeDefaultArgs<ExtArgs>>): Prisma__LeaveTypeClient<$Result.GetResult<Prisma.$LeaveTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approval<T extends Leave$approvalArgs<ExtArgs> = {}>(args?: Subset<T, Leave$approvalArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leave model
   */
  interface LeaveFieldRefs {
    readonly id: FieldRef<"Leave", 'String'>
    readonly workspaceId: FieldRef<"Leave", 'String'>
    readonly employeeId: FieldRef<"Leave", 'String'>
    readonly leaveTypeId: FieldRef<"Leave", 'String'>
    readonly startDate: FieldRef<"Leave", 'DateTime'>
    readonly endDate: FieldRef<"Leave", 'DateTime'>
    readonly halfDay: FieldRef<"Leave", 'Boolean'>
    readonly duration: FieldRef<"Leave", 'Float'>
    readonly reason: FieldRef<"Leave", 'String'>
    readonly attachment: FieldRef<"Leave", 'String'>
    readonly status: FieldRef<"Leave", 'LeaveStatus'>
    readonly notes: FieldRef<"Leave", 'String'>
    readonly createdAt: FieldRef<"Leave", 'DateTime'>
    readonly updatedAt: FieldRef<"Leave", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Leave findUnique
   */
  export type LeaveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findUniqueOrThrow
   */
  export type LeaveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findFirst
   */
  export type LeaveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findFirstOrThrow
   */
  export type LeaveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findMany
   */
  export type LeaveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leaves to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave create
   */
  export type LeaveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to create a Leave.
     */
    data: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
  }

  /**
   * Leave createMany
   */
  export type LeaveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leaves.
     */
    data: LeaveCreateManyInput | LeaveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leave createManyAndReturn
   */
  export type LeaveCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * The data used to create many Leaves.
     */
    data: LeaveCreateManyInput | LeaveCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leave update
   */
  export type LeaveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to update a Leave.
     */
    data: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
    /**
     * Choose, which Leave to update.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave updateMany
   */
  export type LeaveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leaves.
     */
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyInput>
    /**
     * Filter which Leaves to update
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to update.
     */
    limit?: number
  }

  /**
   * Leave updateManyAndReturn
   */
  export type LeaveUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * The data used to update Leaves.
     */
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyInput>
    /**
     * Filter which Leaves to update
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Leave upsert
   */
  export type LeaveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The filter to search for the Leave to update in case it exists.
     */
    where: LeaveWhereUniqueInput
    /**
     * In case the Leave found by the `where` argument doesn't exist, create a new Leave with this data.
     */
    create: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
    /**
     * In case the Leave was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
  }

  /**
   * Leave delete
   */
  export type LeaveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter which Leave to delete.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave deleteMany
   */
  export type LeaveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaves to delete
     */
    where?: LeaveWhereInput
    /**
     * Limit how many Leaves to delete.
     */
    limit?: number
  }

  /**
   * Leave.approval
   */
  export type Leave$approvalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    where?: ApprovalWhereInput
  }

  /**
   * Leave without action
   */
  export type LeaveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
  }


  /**
   * Model OvertimePolicy
   */

  export type AggregateOvertimePolicy = {
    _count: OvertimePolicyCountAggregateOutputType | null
    _avg: OvertimePolicyAvgAggregateOutputType | null
    _sum: OvertimePolicySumAggregateOutputType | null
    _min: OvertimePolicyMinAggregateOutputType | null
    _max: OvertimePolicyMaxAggregateOutputType | null
  }

  export type OvertimePolicyAvgAggregateOutputType = {
    rate: number | null
    minimumHours: number | null
    maximumHours: number | null
  }

  export type OvertimePolicySumAggregateOutputType = {
    rate: number | null
    minimumHours: number | null
    maximumHours: number | null
  }

  export type OvertimePolicyMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    rate: number | null
    minimumHours: number | null
    maximumHours: number | null
    requiresApproval: boolean | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OvertimePolicyMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    rate: number | null
    minimumHours: number | null
    maximumHours: number | null
    requiresApproval: boolean | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OvertimePolicyCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    description: number
    rate: number
    minimumHours: number
    maximumHours: number
    requiresApproval: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OvertimePolicyAvgAggregateInputType = {
    rate?: true
    minimumHours?: true
    maximumHours?: true
  }

  export type OvertimePolicySumAggregateInputType = {
    rate?: true
    minimumHours?: true
    maximumHours?: true
  }

  export type OvertimePolicyMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    rate?: true
    minimumHours?: true
    maximumHours?: true
    requiresApproval?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OvertimePolicyMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    rate?: true
    minimumHours?: true
    maximumHours?: true
    requiresApproval?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OvertimePolicyCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    rate?: true
    minimumHours?: true
    maximumHours?: true
    requiresApproval?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OvertimePolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OvertimePolicy to aggregate.
     */
    where?: OvertimePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OvertimePolicies to fetch.
     */
    orderBy?: OvertimePolicyOrderByWithRelationInput | OvertimePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OvertimePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OvertimePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OvertimePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OvertimePolicies
    **/
    _count?: true | OvertimePolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OvertimePolicyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OvertimePolicySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OvertimePolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OvertimePolicyMaxAggregateInputType
  }

  export type GetOvertimePolicyAggregateType<T extends OvertimePolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateOvertimePolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOvertimePolicy[P]>
      : GetScalarType<T[P], AggregateOvertimePolicy[P]>
  }




  export type OvertimePolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OvertimePolicyWhereInput
    orderBy?: OvertimePolicyOrderByWithAggregationInput | OvertimePolicyOrderByWithAggregationInput[]
    by: OvertimePolicyScalarFieldEnum[] | OvertimePolicyScalarFieldEnum
    having?: OvertimePolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OvertimePolicyCountAggregateInputType | true
    _avg?: OvertimePolicyAvgAggregateInputType
    _sum?: OvertimePolicySumAggregateInputType
    _min?: OvertimePolicyMinAggregateInputType
    _max?: OvertimePolicyMaxAggregateInputType
  }

  export type OvertimePolicyGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    description: string | null
    rate: number
    minimumHours: number
    maximumHours: number | null
    requiresApproval: boolean
    status: string
    createdAt: Date
    updatedAt: Date
    _count: OvertimePolicyCountAggregateOutputType | null
    _avg: OvertimePolicyAvgAggregateOutputType | null
    _sum: OvertimePolicySumAggregateOutputType | null
    _min: OvertimePolicyMinAggregateOutputType | null
    _max: OvertimePolicyMaxAggregateOutputType | null
  }

  type GetOvertimePolicyGroupByPayload<T extends OvertimePolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OvertimePolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OvertimePolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OvertimePolicyGroupByOutputType[P]>
            : GetScalarType<T[P], OvertimePolicyGroupByOutputType[P]>
        }
      >
    >


  export type OvertimePolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    rate?: boolean
    minimumHours?: boolean
    maximumHours?: boolean
    requiresApproval?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    overtimes?: boolean | OvertimePolicy$overtimesArgs<ExtArgs>
    _count?: boolean | OvertimePolicyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["overtimePolicy"]>

  export type OvertimePolicySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    rate?: boolean
    minimumHours?: boolean
    maximumHours?: boolean
    requiresApproval?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["overtimePolicy"]>

  export type OvertimePolicySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    rate?: boolean
    minimumHours?: boolean
    maximumHours?: boolean
    requiresApproval?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["overtimePolicy"]>

  export type OvertimePolicySelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    rate?: boolean
    minimumHours?: boolean
    maximumHours?: boolean
    requiresApproval?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OvertimePolicyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "description" | "rate" | "minimumHours" | "maximumHours" | "requiresApproval" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["overtimePolicy"]>
  export type OvertimePolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    overtimes?: boolean | OvertimePolicy$overtimesArgs<ExtArgs>
    _count?: boolean | OvertimePolicyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OvertimePolicyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type OvertimePolicyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $OvertimePolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OvertimePolicy"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      overtimes: Prisma.$OvertimePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      description: string | null
      rate: number
      minimumHours: number
      maximumHours: number | null
      requiresApproval: boolean
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["overtimePolicy"]>
    composites: {}
  }

  type OvertimePolicyGetPayload<S extends boolean | null | undefined | OvertimePolicyDefaultArgs> = $Result.GetResult<Prisma.$OvertimePolicyPayload, S>

  type OvertimePolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OvertimePolicyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OvertimePolicyCountAggregateInputType | true
    }

  export interface OvertimePolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OvertimePolicy'], meta: { name: 'OvertimePolicy' } }
    /**
     * Find zero or one OvertimePolicy that matches the filter.
     * @param {OvertimePolicyFindUniqueArgs} args - Arguments to find a OvertimePolicy
     * @example
     * // Get one OvertimePolicy
     * const overtimePolicy = await prisma.overtimePolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OvertimePolicyFindUniqueArgs>(args: SelectSubset<T, OvertimePolicyFindUniqueArgs<ExtArgs>>): Prisma__OvertimePolicyClient<$Result.GetResult<Prisma.$OvertimePolicyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OvertimePolicy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OvertimePolicyFindUniqueOrThrowArgs} args - Arguments to find a OvertimePolicy
     * @example
     * // Get one OvertimePolicy
     * const overtimePolicy = await prisma.overtimePolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OvertimePolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, OvertimePolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OvertimePolicyClient<$Result.GetResult<Prisma.$OvertimePolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OvertimePolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimePolicyFindFirstArgs} args - Arguments to find a OvertimePolicy
     * @example
     * // Get one OvertimePolicy
     * const overtimePolicy = await prisma.overtimePolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OvertimePolicyFindFirstArgs>(args?: SelectSubset<T, OvertimePolicyFindFirstArgs<ExtArgs>>): Prisma__OvertimePolicyClient<$Result.GetResult<Prisma.$OvertimePolicyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OvertimePolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimePolicyFindFirstOrThrowArgs} args - Arguments to find a OvertimePolicy
     * @example
     * // Get one OvertimePolicy
     * const overtimePolicy = await prisma.overtimePolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OvertimePolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, OvertimePolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__OvertimePolicyClient<$Result.GetResult<Prisma.$OvertimePolicyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OvertimePolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimePolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OvertimePolicies
     * const overtimePolicies = await prisma.overtimePolicy.findMany()
     * 
     * // Get first 10 OvertimePolicies
     * const overtimePolicies = await prisma.overtimePolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const overtimePolicyWithIdOnly = await prisma.overtimePolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OvertimePolicyFindManyArgs>(args?: SelectSubset<T, OvertimePolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePolicyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OvertimePolicy.
     * @param {OvertimePolicyCreateArgs} args - Arguments to create a OvertimePolicy.
     * @example
     * // Create one OvertimePolicy
     * const OvertimePolicy = await prisma.overtimePolicy.create({
     *   data: {
     *     // ... data to create a OvertimePolicy
     *   }
     * })
     * 
     */
    create<T extends OvertimePolicyCreateArgs>(args: SelectSubset<T, OvertimePolicyCreateArgs<ExtArgs>>): Prisma__OvertimePolicyClient<$Result.GetResult<Prisma.$OvertimePolicyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OvertimePolicies.
     * @param {OvertimePolicyCreateManyArgs} args - Arguments to create many OvertimePolicies.
     * @example
     * // Create many OvertimePolicies
     * const overtimePolicy = await prisma.overtimePolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OvertimePolicyCreateManyArgs>(args?: SelectSubset<T, OvertimePolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OvertimePolicies and returns the data saved in the database.
     * @param {OvertimePolicyCreateManyAndReturnArgs} args - Arguments to create many OvertimePolicies.
     * @example
     * // Create many OvertimePolicies
     * const overtimePolicy = await prisma.overtimePolicy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OvertimePolicies and only return the `id`
     * const overtimePolicyWithIdOnly = await prisma.overtimePolicy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OvertimePolicyCreateManyAndReturnArgs>(args?: SelectSubset<T, OvertimePolicyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePolicyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OvertimePolicy.
     * @param {OvertimePolicyDeleteArgs} args - Arguments to delete one OvertimePolicy.
     * @example
     * // Delete one OvertimePolicy
     * const OvertimePolicy = await prisma.overtimePolicy.delete({
     *   where: {
     *     // ... filter to delete one OvertimePolicy
     *   }
     * })
     * 
     */
    delete<T extends OvertimePolicyDeleteArgs>(args: SelectSubset<T, OvertimePolicyDeleteArgs<ExtArgs>>): Prisma__OvertimePolicyClient<$Result.GetResult<Prisma.$OvertimePolicyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OvertimePolicy.
     * @param {OvertimePolicyUpdateArgs} args - Arguments to update one OvertimePolicy.
     * @example
     * // Update one OvertimePolicy
     * const overtimePolicy = await prisma.overtimePolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OvertimePolicyUpdateArgs>(args: SelectSubset<T, OvertimePolicyUpdateArgs<ExtArgs>>): Prisma__OvertimePolicyClient<$Result.GetResult<Prisma.$OvertimePolicyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OvertimePolicies.
     * @param {OvertimePolicyDeleteManyArgs} args - Arguments to filter OvertimePolicies to delete.
     * @example
     * // Delete a few OvertimePolicies
     * const { count } = await prisma.overtimePolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OvertimePolicyDeleteManyArgs>(args?: SelectSubset<T, OvertimePolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OvertimePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimePolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OvertimePolicies
     * const overtimePolicy = await prisma.overtimePolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OvertimePolicyUpdateManyArgs>(args: SelectSubset<T, OvertimePolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OvertimePolicies and returns the data updated in the database.
     * @param {OvertimePolicyUpdateManyAndReturnArgs} args - Arguments to update many OvertimePolicies.
     * @example
     * // Update many OvertimePolicies
     * const overtimePolicy = await prisma.overtimePolicy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OvertimePolicies and only return the `id`
     * const overtimePolicyWithIdOnly = await prisma.overtimePolicy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OvertimePolicyUpdateManyAndReturnArgs>(args: SelectSubset<T, OvertimePolicyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePolicyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OvertimePolicy.
     * @param {OvertimePolicyUpsertArgs} args - Arguments to update or create a OvertimePolicy.
     * @example
     * // Update or create a OvertimePolicy
     * const overtimePolicy = await prisma.overtimePolicy.upsert({
     *   create: {
     *     // ... data to create a OvertimePolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OvertimePolicy we want to update
     *   }
     * })
     */
    upsert<T extends OvertimePolicyUpsertArgs>(args: SelectSubset<T, OvertimePolicyUpsertArgs<ExtArgs>>): Prisma__OvertimePolicyClient<$Result.GetResult<Prisma.$OvertimePolicyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OvertimePolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimePolicyCountArgs} args - Arguments to filter OvertimePolicies to count.
     * @example
     * // Count the number of OvertimePolicies
     * const count = await prisma.overtimePolicy.count({
     *   where: {
     *     // ... the filter for the OvertimePolicies we want to count
     *   }
     * })
    **/
    count<T extends OvertimePolicyCountArgs>(
      args?: Subset<T, OvertimePolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OvertimePolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OvertimePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimePolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OvertimePolicyAggregateArgs>(args: Subset<T, OvertimePolicyAggregateArgs>): Prisma.PrismaPromise<GetOvertimePolicyAggregateType<T>>

    /**
     * Group by OvertimePolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimePolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OvertimePolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OvertimePolicyGroupByArgs['orderBy'] }
        : { orderBy?: OvertimePolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OvertimePolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOvertimePolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OvertimePolicy model
   */
  readonly fields: OvertimePolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OvertimePolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OvertimePolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    overtimes<T extends OvertimePolicy$overtimesArgs<ExtArgs> = {}>(args?: Subset<T, OvertimePolicy$overtimesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OvertimePolicy model
   */
  interface OvertimePolicyFieldRefs {
    readonly id: FieldRef<"OvertimePolicy", 'String'>
    readonly workspaceId: FieldRef<"OvertimePolicy", 'String'>
    readonly name: FieldRef<"OvertimePolicy", 'String'>
    readonly description: FieldRef<"OvertimePolicy", 'String'>
    readonly rate: FieldRef<"OvertimePolicy", 'Float'>
    readonly minimumHours: FieldRef<"OvertimePolicy", 'Float'>
    readonly maximumHours: FieldRef<"OvertimePolicy", 'Float'>
    readonly requiresApproval: FieldRef<"OvertimePolicy", 'Boolean'>
    readonly status: FieldRef<"OvertimePolicy", 'String'>
    readonly createdAt: FieldRef<"OvertimePolicy", 'DateTime'>
    readonly updatedAt: FieldRef<"OvertimePolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OvertimePolicy findUnique
   */
  export type OvertimePolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimePolicy
     */
    select?: OvertimePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimePolicy
     */
    omit?: OvertimePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimePolicyInclude<ExtArgs> | null
    /**
     * Filter, which OvertimePolicy to fetch.
     */
    where: OvertimePolicyWhereUniqueInput
  }

  /**
   * OvertimePolicy findUniqueOrThrow
   */
  export type OvertimePolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimePolicy
     */
    select?: OvertimePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimePolicy
     */
    omit?: OvertimePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimePolicyInclude<ExtArgs> | null
    /**
     * Filter, which OvertimePolicy to fetch.
     */
    where: OvertimePolicyWhereUniqueInput
  }

  /**
   * OvertimePolicy findFirst
   */
  export type OvertimePolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimePolicy
     */
    select?: OvertimePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimePolicy
     */
    omit?: OvertimePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimePolicyInclude<ExtArgs> | null
    /**
     * Filter, which OvertimePolicy to fetch.
     */
    where?: OvertimePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OvertimePolicies to fetch.
     */
    orderBy?: OvertimePolicyOrderByWithRelationInput | OvertimePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OvertimePolicies.
     */
    cursor?: OvertimePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OvertimePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OvertimePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OvertimePolicies.
     */
    distinct?: OvertimePolicyScalarFieldEnum | OvertimePolicyScalarFieldEnum[]
  }

  /**
   * OvertimePolicy findFirstOrThrow
   */
  export type OvertimePolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimePolicy
     */
    select?: OvertimePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimePolicy
     */
    omit?: OvertimePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimePolicyInclude<ExtArgs> | null
    /**
     * Filter, which OvertimePolicy to fetch.
     */
    where?: OvertimePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OvertimePolicies to fetch.
     */
    orderBy?: OvertimePolicyOrderByWithRelationInput | OvertimePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OvertimePolicies.
     */
    cursor?: OvertimePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OvertimePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OvertimePolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OvertimePolicies.
     */
    distinct?: OvertimePolicyScalarFieldEnum | OvertimePolicyScalarFieldEnum[]
  }

  /**
   * OvertimePolicy findMany
   */
  export type OvertimePolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimePolicy
     */
    select?: OvertimePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimePolicy
     */
    omit?: OvertimePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimePolicyInclude<ExtArgs> | null
    /**
     * Filter, which OvertimePolicies to fetch.
     */
    where?: OvertimePolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OvertimePolicies to fetch.
     */
    orderBy?: OvertimePolicyOrderByWithRelationInput | OvertimePolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OvertimePolicies.
     */
    cursor?: OvertimePolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OvertimePolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OvertimePolicies.
     */
    skip?: number
    distinct?: OvertimePolicyScalarFieldEnum | OvertimePolicyScalarFieldEnum[]
  }

  /**
   * OvertimePolicy create
   */
  export type OvertimePolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimePolicy
     */
    select?: OvertimePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimePolicy
     */
    omit?: OvertimePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimePolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a OvertimePolicy.
     */
    data: XOR<OvertimePolicyCreateInput, OvertimePolicyUncheckedCreateInput>
  }

  /**
   * OvertimePolicy createMany
   */
  export type OvertimePolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OvertimePolicies.
     */
    data: OvertimePolicyCreateManyInput | OvertimePolicyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OvertimePolicy createManyAndReturn
   */
  export type OvertimePolicyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimePolicy
     */
    select?: OvertimePolicySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimePolicy
     */
    omit?: OvertimePolicyOmit<ExtArgs> | null
    /**
     * The data used to create many OvertimePolicies.
     */
    data: OvertimePolicyCreateManyInput | OvertimePolicyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimePolicyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OvertimePolicy update
   */
  export type OvertimePolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimePolicy
     */
    select?: OvertimePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimePolicy
     */
    omit?: OvertimePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimePolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a OvertimePolicy.
     */
    data: XOR<OvertimePolicyUpdateInput, OvertimePolicyUncheckedUpdateInput>
    /**
     * Choose, which OvertimePolicy to update.
     */
    where: OvertimePolicyWhereUniqueInput
  }

  /**
   * OvertimePolicy updateMany
   */
  export type OvertimePolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OvertimePolicies.
     */
    data: XOR<OvertimePolicyUpdateManyMutationInput, OvertimePolicyUncheckedUpdateManyInput>
    /**
     * Filter which OvertimePolicies to update
     */
    where?: OvertimePolicyWhereInput
    /**
     * Limit how many OvertimePolicies to update.
     */
    limit?: number
  }

  /**
   * OvertimePolicy updateManyAndReturn
   */
  export type OvertimePolicyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimePolicy
     */
    select?: OvertimePolicySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimePolicy
     */
    omit?: OvertimePolicyOmit<ExtArgs> | null
    /**
     * The data used to update OvertimePolicies.
     */
    data: XOR<OvertimePolicyUpdateManyMutationInput, OvertimePolicyUncheckedUpdateManyInput>
    /**
     * Filter which OvertimePolicies to update
     */
    where?: OvertimePolicyWhereInput
    /**
     * Limit how many OvertimePolicies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimePolicyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OvertimePolicy upsert
   */
  export type OvertimePolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimePolicy
     */
    select?: OvertimePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimePolicy
     */
    omit?: OvertimePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimePolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the OvertimePolicy to update in case it exists.
     */
    where: OvertimePolicyWhereUniqueInput
    /**
     * In case the OvertimePolicy found by the `where` argument doesn't exist, create a new OvertimePolicy with this data.
     */
    create: XOR<OvertimePolicyCreateInput, OvertimePolicyUncheckedCreateInput>
    /**
     * In case the OvertimePolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OvertimePolicyUpdateInput, OvertimePolicyUncheckedUpdateInput>
  }

  /**
   * OvertimePolicy delete
   */
  export type OvertimePolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimePolicy
     */
    select?: OvertimePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimePolicy
     */
    omit?: OvertimePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimePolicyInclude<ExtArgs> | null
    /**
     * Filter which OvertimePolicy to delete.
     */
    where: OvertimePolicyWhereUniqueInput
  }

  /**
   * OvertimePolicy deleteMany
   */
  export type OvertimePolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OvertimePolicies to delete
     */
    where?: OvertimePolicyWhereInput
    /**
     * Limit how many OvertimePolicies to delete.
     */
    limit?: number
  }

  /**
   * OvertimePolicy.overtimes
   */
  export type OvertimePolicy$overtimesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    where?: OvertimeWhereInput
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    cursor?: OvertimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OvertimeScalarFieldEnum | OvertimeScalarFieldEnum[]
  }

  /**
   * OvertimePolicy without action
   */
  export type OvertimePolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OvertimePolicy
     */
    select?: OvertimePolicySelect<ExtArgs> | null
    /**
     * Omit specific fields from the OvertimePolicy
     */
    omit?: OvertimePolicyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimePolicyInclude<ExtArgs> | null
  }


  /**
   * Model Overtime
   */

  export type AggregateOvertime = {
    _count: OvertimeCountAggregateOutputType | null
    _avg: OvertimeAvgAggregateOutputType | null
    _sum: OvertimeSumAggregateOutputType | null
    _min: OvertimeMinAggregateOutputType | null
    _max: OvertimeMaxAggregateOutputType | null
  }

  export type OvertimeAvgAggregateOutputType = {
    hours: number | null
  }

  export type OvertimeSumAggregateOutputType = {
    hours: number | null
  }

  export type OvertimeMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    employeeId: string | null
    policyId: string | null
    date: Date | null
    startTime: Date | null
    endTime: Date | null
    hours: number | null
    reason: string | null
    status: $Enums.OvertimeStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OvertimeMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    employeeId: string | null
    policyId: string | null
    date: Date | null
    startTime: Date | null
    endTime: Date | null
    hours: number | null
    reason: string | null
    status: $Enums.OvertimeStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OvertimeCountAggregateOutputType = {
    id: number
    workspaceId: number
    employeeId: number
    policyId: number
    date: number
    startTime: number
    endTime: number
    hours: number
    reason: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OvertimeAvgAggregateInputType = {
    hours?: true
  }

  export type OvertimeSumAggregateInputType = {
    hours?: true
  }

  export type OvertimeMinAggregateInputType = {
    id?: true
    workspaceId?: true
    employeeId?: true
    policyId?: true
    date?: true
    startTime?: true
    endTime?: true
    hours?: true
    reason?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OvertimeMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    employeeId?: true
    policyId?: true
    date?: true
    startTime?: true
    endTime?: true
    hours?: true
    reason?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OvertimeCountAggregateInputType = {
    id?: true
    workspaceId?: true
    employeeId?: true
    policyId?: true
    date?: true
    startTime?: true
    endTime?: true
    hours?: true
    reason?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OvertimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Overtime to aggregate.
     */
    where?: OvertimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Overtimes to fetch.
     */
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OvertimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Overtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Overtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Overtimes
    **/
    _count?: true | OvertimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OvertimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OvertimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OvertimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OvertimeMaxAggregateInputType
  }

  export type GetOvertimeAggregateType<T extends OvertimeAggregateArgs> = {
        [P in keyof T & keyof AggregateOvertime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOvertime[P]>
      : GetScalarType<T[P], AggregateOvertime[P]>
  }




  export type OvertimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OvertimeWhereInput
    orderBy?: OvertimeOrderByWithAggregationInput | OvertimeOrderByWithAggregationInput[]
    by: OvertimeScalarFieldEnum[] | OvertimeScalarFieldEnum
    having?: OvertimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OvertimeCountAggregateInputType | true
    _avg?: OvertimeAvgAggregateInputType
    _sum?: OvertimeSumAggregateInputType
    _min?: OvertimeMinAggregateInputType
    _max?: OvertimeMaxAggregateInputType
  }

  export type OvertimeGroupByOutputType = {
    id: string
    workspaceId: string
    employeeId: string
    policyId: string
    date: Date
    startTime: Date
    endTime: Date
    hours: number
    reason: string
    status: $Enums.OvertimeStatus
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: OvertimeCountAggregateOutputType | null
    _avg: OvertimeAvgAggregateOutputType | null
    _sum: OvertimeSumAggregateOutputType | null
    _min: OvertimeMinAggregateOutputType | null
    _max: OvertimeMaxAggregateOutputType | null
  }

  type GetOvertimeGroupByPayload<T extends OvertimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OvertimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OvertimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OvertimeGroupByOutputType[P]>
            : GetScalarType<T[P], OvertimeGroupByOutputType[P]>
        }
      >
    >


  export type OvertimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    employeeId?: boolean
    policyId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    hours?: boolean
    reason?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    overtimePolicy?: boolean | OvertimePolicyDefaultArgs<ExtArgs>
    approval?: boolean | Overtime$approvalArgs<ExtArgs>
  }, ExtArgs["result"]["overtime"]>

  export type OvertimeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    employeeId?: boolean
    policyId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    hours?: boolean
    reason?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    overtimePolicy?: boolean | OvertimePolicyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["overtime"]>

  export type OvertimeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    employeeId?: boolean
    policyId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    hours?: boolean
    reason?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    overtimePolicy?: boolean | OvertimePolicyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["overtime"]>

  export type OvertimeSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    employeeId?: boolean
    policyId?: boolean
    date?: boolean
    startTime?: boolean
    endTime?: boolean
    hours?: boolean
    reason?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OvertimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "employeeId" | "policyId" | "date" | "startTime" | "endTime" | "hours" | "reason" | "status" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["overtime"]>
  export type OvertimeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    overtimePolicy?: boolean | OvertimePolicyDefaultArgs<ExtArgs>
    approval?: boolean | Overtime$approvalArgs<ExtArgs>
  }
  export type OvertimeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    overtimePolicy?: boolean | OvertimePolicyDefaultArgs<ExtArgs>
  }
  export type OvertimeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    overtimePolicy?: boolean | OvertimePolicyDefaultArgs<ExtArgs>
  }

  export type $OvertimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Overtime"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
      overtimePolicy: Prisma.$OvertimePolicyPayload<ExtArgs>
      approval: Prisma.$ApprovalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      employeeId: string
      policyId: string
      date: Date
      startTime: Date
      endTime: Date
      hours: number
      reason: string
      status: $Enums.OvertimeStatus
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["overtime"]>
    composites: {}
  }

  type OvertimeGetPayload<S extends boolean | null | undefined | OvertimeDefaultArgs> = $Result.GetResult<Prisma.$OvertimePayload, S>

  type OvertimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OvertimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OvertimeCountAggregateInputType | true
    }

  export interface OvertimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Overtime'], meta: { name: 'Overtime' } }
    /**
     * Find zero or one Overtime that matches the filter.
     * @param {OvertimeFindUniqueArgs} args - Arguments to find a Overtime
     * @example
     * // Get one Overtime
     * const overtime = await prisma.overtime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OvertimeFindUniqueArgs>(args: SelectSubset<T, OvertimeFindUniqueArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Overtime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OvertimeFindUniqueOrThrowArgs} args - Arguments to find a Overtime
     * @example
     * // Get one Overtime
     * const overtime = await prisma.overtime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OvertimeFindUniqueOrThrowArgs>(args: SelectSubset<T, OvertimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Overtime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeFindFirstArgs} args - Arguments to find a Overtime
     * @example
     * // Get one Overtime
     * const overtime = await prisma.overtime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OvertimeFindFirstArgs>(args?: SelectSubset<T, OvertimeFindFirstArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Overtime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeFindFirstOrThrowArgs} args - Arguments to find a Overtime
     * @example
     * // Get one Overtime
     * const overtime = await prisma.overtime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OvertimeFindFirstOrThrowArgs>(args?: SelectSubset<T, OvertimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Overtimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Overtimes
     * const overtimes = await prisma.overtime.findMany()
     * 
     * // Get first 10 Overtimes
     * const overtimes = await prisma.overtime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const overtimeWithIdOnly = await prisma.overtime.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OvertimeFindManyArgs>(args?: SelectSubset<T, OvertimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Overtime.
     * @param {OvertimeCreateArgs} args - Arguments to create a Overtime.
     * @example
     * // Create one Overtime
     * const Overtime = await prisma.overtime.create({
     *   data: {
     *     // ... data to create a Overtime
     *   }
     * })
     * 
     */
    create<T extends OvertimeCreateArgs>(args: SelectSubset<T, OvertimeCreateArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Overtimes.
     * @param {OvertimeCreateManyArgs} args - Arguments to create many Overtimes.
     * @example
     * // Create many Overtimes
     * const overtime = await prisma.overtime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OvertimeCreateManyArgs>(args?: SelectSubset<T, OvertimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Overtimes and returns the data saved in the database.
     * @param {OvertimeCreateManyAndReturnArgs} args - Arguments to create many Overtimes.
     * @example
     * // Create many Overtimes
     * const overtime = await prisma.overtime.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Overtimes and only return the `id`
     * const overtimeWithIdOnly = await prisma.overtime.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OvertimeCreateManyAndReturnArgs>(args?: SelectSubset<T, OvertimeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Overtime.
     * @param {OvertimeDeleteArgs} args - Arguments to delete one Overtime.
     * @example
     * // Delete one Overtime
     * const Overtime = await prisma.overtime.delete({
     *   where: {
     *     // ... filter to delete one Overtime
     *   }
     * })
     * 
     */
    delete<T extends OvertimeDeleteArgs>(args: SelectSubset<T, OvertimeDeleteArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Overtime.
     * @param {OvertimeUpdateArgs} args - Arguments to update one Overtime.
     * @example
     * // Update one Overtime
     * const overtime = await prisma.overtime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OvertimeUpdateArgs>(args: SelectSubset<T, OvertimeUpdateArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Overtimes.
     * @param {OvertimeDeleteManyArgs} args - Arguments to filter Overtimes to delete.
     * @example
     * // Delete a few Overtimes
     * const { count } = await prisma.overtime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OvertimeDeleteManyArgs>(args?: SelectSubset<T, OvertimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Overtimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Overtimes
     * const overtime = await prisma.overtime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OvertimeUpdateManyArgs>(args: SelectSubset<T, OvertimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Overtimes and returns the data updated in the database.
     * @param {OvertimeUpdateManyAndReturnArgs} args - Arguments to update many Overtimes.
     * @example
     * // Update many Overtimes
     * const overtime = await prisma.overtime.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Overtimes and only return the `id`
     * const overtimeWithIdOnly = await prisma.overtime.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OvertimeUpdateManyAndReturnArgs>(args: SelectSubset<T, OvertimeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Overtime.
     * @param {OvertimeUpsertArgs} args - Arguments to update or create a Overtime.
     * @example
     * // Update or create a Overtime
     * const overtime = await prisma.overtime.upsert({
     *   create: {
     *     // ... data to create a Overtime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Overtime we want to update
     *   }
     * })
     */
    upsert<T extends OvertimeUpsertArgs>(args: SelectSubset<T, OvertimeUpsertArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Overtimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeCountArgs} args - Arguments to filter Overtimes to count.
     * @example
     * // Count the number of Overtimes
     * const count = await prisma.overtime.count({
     *   where: {
     *     // ... the filter for the Overtimes we want to count
     *   }
     * })
    **/
    count<T extends OvertimeCountArgs>(
      args?: Subset<T, OvertimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OvertimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Overtime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OvertimeAggregateArgs>(args: Subset<T, OvertimeAggregateArgs>): Prisma.PrismaPromise<GetOvertimeAggregateType<T>>

    /**
     * Group by Overtime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OvertimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OvertimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OvertimeGroupByArgs['orderBy'] }
        : { orderBy?: OvertimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OvertimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOvertimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Overtime model
   */
  readonly fields: OvertimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Overtime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OvertimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    overtimePolicy<T extends OvertimePolicyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OvertimePolicyDefaultArgs<ExtArgs>>): Prisma__OvertimePolicyClient<$Result.GetResult<Prisma.$OvertimePolicyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approval<T extends Overtime$approvalArgs<ExtArgs> = {}>(args?: Subset<T, Overtime$approvalArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Overtime model
   */
  interface OvertimeFieldRefs {
    readonly id: FieldRef<"Overtime", 'String'>
    readonly workspaceId: FieldRef<"Overtime", 'String'>
    readonly employeeId: FieldRef<"Overtime", 'String'>
    readonly policyId: FieldRef<"Overtime", 'String'>
    readonly date: FieldRef<"Overtime", 'DateTime'>
    readonly startTime: FieldRef<"Overtime", 'DateTime'>
    readonly endTime: FieldRef<"Overtime", 'DateTime'>
    readonly hours: FieldRef<"Overtime", 'Float'>
    readonly reason: FieldRef<"Overtime", 'String'>
    readonly status: FieldRef<"Overtime", 'OvertimeStatus'>
    readonly notes: FieldRef<"Overtime", 'String'>
    readonly createdAt: FieldRef<"Overtime", 'DateTime'>
    readonly updatedAt: FieldRef<"Overtime", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Overtime findUnique
   */
  export type OvertimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter, which Overtime to fetch.
     */
    where: OvertimeWhereUniqueInput
  }

  /**
   * Overtime findUniqueOrThrow
   */
  export type OvertimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter, which Overtime to fetch.
     */
    where: OvertimeWhereUniqueInput
  }

  /**
   * Overtime findFirst
   */
  export type OvertimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter, which Overtime to fetch.
     */
    where?: OvertimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Overtimes to fetch.
     */
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Overtimes.
     */
    cursor?: OvertimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Overtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Overtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Overtimes.
     */
    distinct?: OvertimeScalarFieldEnum | OvertimeScalarFieldEnum[]
  }

  /**
   * Overtime findFirstOrThrow
   */
  export type OvertimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter, which Overtime to fetch.
     */
    where?: OvertimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Overtimes to fetch.
     */
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Overtimes.
     */
    cursor?: OvertimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Overtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Overtimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Overtimes.
     */
    distinct?: OvertimeScalarFieldEnum | OvertimeScalarFieldEnum[]
  }

  /**
   * Overtime findMany
   */
  export type OvertimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter, which Overtimes to fetch.
     */
    where?: OvertimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Overtimes to fetch.
     */
    orderBy?: OvertimeOrderByWithRelationInput | OvertimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Overtimes.
     */
    cursor?: OvertimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Overtimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Overtimes.
     */
    skip?: number
    distinct?: OvertimeScalarFieldEnum | OvertimeScalarFieldEnum[]
  }

  /**
   * Overtime create
   */
  export type OvertimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * The data needed to create a Overtime.
     */
    data: XOR<OvertimeCreateInput, OvertimeUncheckedCreateInput>
  }

  /**
   * Overtime createMany
   */
  export type OvertimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Overtimes.
     */
    data: OvertimeCreateManyInput | OvertimeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Overtime createManyAndReturn
   */
  export type OvertimeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * The data used to create many Overtimes.
     */
    data: OvertimeCreateManyInput | OvertimeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Overtime update
   */
  export type OvertimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * The data needed to update a Overtime.
     */
    data: XOR<OvertimeUpdateInput, OvertimeUncheckedUpdateInput>
    /**
     * Choose, which Overtime to update.
     */
    where: OvertimeWhereUniqueInput
  }

  /**
   * Overtime updateMany
   */
  export type OvertimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Overtimes.
     */
    data: XOR<OvertimeUpdateManyMutationInput, OvertimeUncheckedUpdateManyInput>
    /**
     * Filter which Overtimes to update
     */
    where?: OvertimeWhereInput
    /**
     * Limit how many Overtimes to update.
     */
    limit?: number
  }

  /**
   * Overtime updateManyAndReturn
   */
  export type OvertimeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * The data used to update Overtimes.
     */
    data: XOR<OvertimeUpdateManyMutationInput, OvertimeUncheckedUpdateManyInput>
    /**
     * Filter which Overtimes to update
     */
    where?: OvertimeWhereInput
    /**
     * Limit how many Overtimes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Overtime upsert
   */
  export type OvertimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * The filter to search for the Overtime to update in case it exists.
     */
    where: OvertimeWhereUniqueInput
    /**
     * In case the Overtime found by the `where` argument doesn't exist, create a new Overtime with this data.
     */
    create: XOR<OvertimeCreateInput, OvertimeUncheckedCreateInput>
    /**
     * In case the Overtime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OvertimeUpdateInput, OvertimeUncheckedUpdateInput>
  }

  /**
   * Overtime delete
   */
  export type OvertimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    /**
     * Filter which Overtime to delete.
     */
    where: OvertimeWhereUniqueInput
  }

  /**
   * Overtime deleteMany
   */
  export type OvertimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Overtimes to delete
     */
    where?: OvertimeWhereInput
    /**
     * Limit how many Overtimes to delete.
     */
    limit?: number
  }

  /**
   * Overtime.approval
   */
  export type Overtime$approvalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    where?: ApprovalWhereInput
  }

  /**
   * Overtime without action
   */
  export type OvertimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
  }


  /**
   * Model ApprovalTemplate
   */

  export type AggregateApprovalTemplate = {
    _count: ApprovalTemplateCountAggregateOutputType | null
    _min: ApprovalTemplateMinAggregateOutputType | null
    _max: ApprovalTemplateMaxAggregateOutputType | null
  }

  export type ApprovalTemplateMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    entityType: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalTemplateMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    name: string | null
    description: string | null
    entityType: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalTemplateCountAggregateOutputType = {
    id: number
    workspaceId: number
    name: number
    description: number
    entityType: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApprovalTemplateMinAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    entityType?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalTemplateMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    entityType?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalTemplateCountAggregateInputType = {
    id?: true
    workspaceId?: true
    name?: true
    description?: true
    entityType?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApprovalTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalTemplate to aggregate.
     */
    where?: ApprovalTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalTemplates to fetch.
     */
    orderBy?: ApprovalTemplateOrderByWithRelationInput | ApprovalTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApprovalTemplates
    **/
    _count?: true | ApprovalTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalTemplateMaxAggregateInputType
  }

  export type GetApprovalTemplateAggregateType<T extends ApprovalTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateApprovalTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApprovalTemplate[P]>
      : GetScalarType<T[P], AggregateApprovalTemplate[P]>
  }




  export type ApprovalTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalTemplateWhereInput
    orderBy?: ApprovalTemplateOrderByWithAggregationInput | ApprovalTemplateOrderByWithAggregationInput[]
    by: ApprovalTemplateScalarFieldEnum[] | ApprovalTemplateScalarFieldEnum
    having?: ApprovalTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalTemplateCountAggregateInputType | true
    _min?: ApprovalTemplateMinAggregateInputType
    _max?: ApprovalTemplateMaxAggregateInputType
  }

  export type ApprovalTemplateGroupByOutputType = {
    id: string
    workspaceId: string
    name: string
    description: string | null
    entityType: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: ApprovalTemplateCountAggregateOutputType | null
    _min: ApprovalTemplateMinAggregateOutputType | null
    _max: ApprovalTemplateMaxAggregateOutputType | null
  }

  type GetApprovalTemplateGroupByPayload<T extends ApprovalTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalTemplateGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    entityType?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    steps?: boolean | ApprovalTemplate$stepsArgs<ExtArgs>
    approvals?: boolean | ApprovalTemplate$approvalsArgs<ExtArgs>
    _count?: boolean | ApprovalTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalTemplate"]>

  export type ApprovalTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    entityType?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalTemplate"]>

  export type ApprovalTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    entityType?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalTemplate"]>

  export type ApprovalTemplateSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    name?: boolean
    description?: boolean
    entityType?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApprovalTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "name" | "description" | "entityType" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["approvalTemplate"]>
  export type ApprovalTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    steps?: boolean | ApprovalTemplate$stepsArgs<ExtArgs>
    approvals?: boolean | ApprovalTemplate$approvalsArgs<ExtArgs>
    _count?: boolean | ApprovalTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApprovalTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ApprovalTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $ApprovalTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApprovalTemplate"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      steps: Prisma.$ApprovalStepPayload<ExtArgs>[]
      approvals: Prisma.$ApprovalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      name: string
      description: string | null
      entityType: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["approvalTemplate"]>
    composites: {}
  }

  type ApprovalTemplateGetPayload<S extends boolean | null | undefined | ApprovalTemplateDefaultArgs> = $Result.GetResult<Prisma.$ApprovalTemplatePayload, S>

  type ApprovalTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApprovalTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApprovalTemplateCountAggregateInputType | true
    }

  export interface ApprovalTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApprovalTemplate'], meta: { name: 'ApprovalTemplate' } }
    /**
     * Find zero or one ApprovalTemplate that matches the filter.
     * @param {ApprovalTemplateFindUniqueArgs} args - Arguments to find a ApprovalTemplate
     * @example
     * // Get one ApprovalTemplate
     * const approvalTemplate = await prisma.approvalTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalTemplateFindUniqueArgs>(args: SelectSubset<T, ApprovalTemplateFindUniqueArgs<ExtArgs>>): Prisma__ApprovalTemplateClient<$Result.GetResult<Prisma.$ApprovalTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApprovalTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApprovalTemplateFindUniqueOrThrowArgs} args - Arguments to find a ApprovalTemplate
     * @example
     * // Get one ApprovalTemplate
     * const approvalTemplate = await prisma.approvalTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalTemplateClient<$Result.GetResult<Prisma.$ApprovalTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApprovalTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTemplateFindFirstArgs} args - Arguments to find a ApprovalTemplate
     * @example
     * // Get one ApprovalTemplate
     * const approvalTemplate = await prisma.approvalTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalTemplateFindFirstArgs>(args?: SelectSubset<T, ApprovalTemplateFindFirstArgs<ExtArgs>>): Prisma__ApprovalTemplateClient<$Result.GetResult<Prisma.$ApprovalTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApprovalTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTemplateFindFirstOrThrowArgs} args - Arguments to find a ApprovalTemplate
     * @example
     * // Get one ApprovalTemplate
     * const approvalTemplate = await prisma.approvalTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalTemplateClient<$Result.GetResult<Prisma.$ApprovalTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApprovalTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApprovalTemplates
     * const approvalTemplates = await prisma.approvalTemplate.findMany()
     * 
     * // Get first 10 ApprovalTemplates
     * const approvalTemplates = await prisma.approvalTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalTemplateWithIdOnly = await prisma.approvalTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalTemplateFindManyArgs>(args?: SelectSubset<T, ApprovalTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApprovalTemplate.
     * @param {ApprovalTemplateCreateArgs} args - Arguments to create a ApprovalTemplate.
     * @example
     * // Create one ApprovalTemplate
     * const ApprovalTemplate = await prisma.approvalTemplate.create({
     *   data: {
     *     // ... data to create a ApprovalTemplate
     *   }
     * })
     * 
     */
    create<T extends ApprovalTemplateCreateArgs>(args: SelectSubset<T, ApprovalTemplateCreateArgs<ExtArgs>>): Prisma__ApprovalTemplateClient<$Result.GetResult<Prisma.$ApprovalTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApprovalTemplates.
     * @param {ApprovalTemplateCreateManyArgs} args - Arguments to create many ApprovalTemplates.
     * @example
     * // Create many ApprovalTemplates
     * const approvalTemplate = await prisma.approvalTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalTemplateCreateManyArgs>(args?: SelectSubset<T, ApprovalTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApprovalTemplates and returns the data saved in the database.
     * @param {ApprovalTemplateCreateManyAndReturnArgs} args - Arguments to create many ApprovalTemplates.
     * @example
     * // Create many ApprovalTemplates
     * const approvalTemplate = await prisma.approvalTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApprovalTemplates and only return the `id`
     * const approvalTemplateWithIdOnly = await prisma.approvalTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApprovalTemplate.
     * @param {ApprovalTemplateDeleteArgs} args - Arguments to delete one ApprovalTemplate.
     * @example
     * // Delete one ApprovalTemplate
     * const ApprovalTemplate = await prisma.approvalTemplate.delete({
     *   where: {
     *     // ... filter to delete one ApprovalTemplate
     *   }
     * })
     * 
     */
    delete<T extends ApprovalTemplateDeleteArgs>(args: SelectSubset<T, ApprovalTemplateDeleteArgs<ExtArgs>>): Prisma__ApprovalTemplateClient<$Result.GetResult<Prisma.$ApprovalTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApprovalTemplate.
     * @param {ApprovalTemplateUpdateArgs} args - Arguments to update one ApprovalTemplate.
     * @example
     * // Update one ApprovalTemplate
     * const approvalTemplate = await prisma.approvalTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalTemplateUpdateArgs>(args: SelectSubset<T, ApprovalTemplateUpdateArgs<ExtArgs>>): Prisma__ApprovalTemplateClient<$Result.GetResult<Prisma.$ApprovalTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApprovalTemplates.
     * @param {ApprovalTemplateDeleteManyArgs} args - Arguments to filter ApprovalTemplates to delete.
     * @example
     * // Delete a few ApprovalTemplates
     * const { count } = await prisma.approvalTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalTemplateDeleteManyArgs>(args?: SelectSubset<T, ApprovalTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApprovalTemplates
     * const approvalTemplate = await prisma.approvalTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalTemplateUpdateManyArgs>(args: SelectSubset<T, ApprovalTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalTemplates and returns the data updated in the database.
     * @param {ApprovalTemplateUpdateManyAndReturnArgs} args - Arguments to update many ApprovalTemplates.
     * @example
     * // Update many ApprovalTemplates
     * const approvalTemplate = await prisma.approvalTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApprovalTemplates and only return the `id`
     * const approvalTemplateWithIdOnly = await prisma.approvalTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApprovalTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, ApprovalTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApprovalTemplate.
     * @param {ApprovalTemplateUpsertArgs} args - Arguments to update or create a ApprovalTemplate.
     * @example
     * // Update or create a ApprovalTemplate
     * const approvalTemplate = await prisma.approvalTemplate.upsert({
     *   create: {
     *     // ... data to create a ApprovalTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApprovalTemplate we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalTemplateUpsertArgs>(args: SelectSubset<T, ApprovalTemplateUpsertArgs<ExtArgs>>): Prisma__ApprovalTemplateClient<$Result.GetResult<Prisma.$ApprovalTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApprovalTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTemplateCountArgs} args - Arguments to filter ApprovalTemplates to count.
     * @example
     * // Count the number of ApprovalTemplates
     * const count = await prisma.approvalTemplate.count({
     *   where: {
     *     // ... the filter for the ApprovalTemplates we want to count
     *   }
     * })
    **/
    count<T extends ApprovalTemplateCountArgs>(
      args?: Subset<T, ApprovalTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApprovalTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalTemplateAggregateArgs>(args: Subset<T, ApprovalTemplateAggregateArgs>): Prisma.PrismaPromise<GetApprovalTemplateAggregateType<T>>

    /**
     * Group by ApprovalTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalTemplateGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApprovalTemplate model
   */
  readonly fields: ApprovalTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApprovalTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    steps<T extends ApprovalTemplate$stepsArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalTemplate$stepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approvals<T extends ApprovalTemplate$approvalsArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalTemplate$approvalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApprovalTemplate model
   */
  interface ApprovalTemplateFieldRefs {
    readonly id: FieldRef<"ApprovalTemplate", 'String'>
    readonly workspaceId: FieldRef<"ApprovalTemplate", 'String'>
    readonly name: FieldRef<"ApprovalTemplate", 'String'>
    readonly description: FieldRef<"ApprovalTemplate", 'String'>
    readonly entityType: FieldRef<"ApprovalTemplate", 'String'>
    readonly active: FieldRef<"ApprovalTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"ApprovalTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"ApprovalTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApprovalTemplate findUnique
   */
  export type ApprovalTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTemplate
     */
    select?: ApprovalTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTemplate
     */
    omit?: ApprovalTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalTemplate to fetch.
     */
    where: ApprovalTemplateWhereUniqueInput
  }

  /**
   * ApprovalTemplate findUniqueOrThrow
   */
  export type ApprovalTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTemplate
     */
    select?: ApprovalTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTemplate
     */
    omit?: ApprovalTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalTemplate to fetch.
     */
    where: ApprovalTemplateWhereUniqueInput
  }

  /**
   * ApprovalTemplate findFirst
   */
  export type ApprovalTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTemplate
     */
    select?: ApprovalTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTemplate
     */
    omit?: ApprovalTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalTemplate to fetch.
     */
    where?: ApprovalTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalTemplates to fetch.
     */
    orderBy?: ApprovalTemplateOrderByWithRelationInput | ApprovalTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalTemplates.
     */
    cursor?: ApprovalTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalTemplates.
     */
    distinct?: ApprovalTemplateScalarFieldEnum | ApprovalTemplateScalarFieldEnum[]
  }

  /**
   * ApprovalTemplate findFirstOrThrow
   */
  export type ApprovalTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTemplate
     */
    select?: ApprovalTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTemplate
     */
    omit?: ApprovalTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalTemplate to fetch.
     */
    where?: ApprovalTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalTemplates to fetch.
     */
    orderBy?: ApprovalTemplateOrderByWithRelationInput | ApprovalTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalTemplates.
     */
    cursor?: ApprovalTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalTemplates.
     */
    distinct?: ApprovalTemplateScalarFieldEnum | ApprovalTemplateScalarFieldEnum[]
  }

  /**
   * ApprovalTemplate findMany
   */
  export type ApprovalTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTemplate
     */
    select?: ApprovalTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTemplate
     */
    omit?: ApprovalTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTemplateInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalTemplates to fetch.
     */
    where?: ApprovalTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalTemplates to fetch.
     */
    orderBy?: ApprovalTemplateOrderByWithRelationInput | ApprovalTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApprovalTemplates.
     */
    cursor?: ApprovalTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalTemplates.
     */
    skip?: number
    distinct?: ApprovalTemplateScalarFieldEnum | ApprovalTemplateScalarFieldEnum[]
  }

  /**
   * ApprovalTemplate create
   */
  export type ApprovalTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTemplate
     */
    select?: ApprovalTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTemplate
     */
    omit?: ApprovalTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a ApprovalTemplate.
     */
    data: XOR<ApprovalTemplateCreateInput, ApprovalTemplateUncheckedCreateInput>
  }

  /**
   * ApprovalTemplate createMany
   */
  export type ApprovalTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApprovalTemplates.
     */
    data: ApprovalTemplateCreateManyInput | ApprovalTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApprovalTemplate createManyAndReturn
   */
  export type ApprovalTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTemplate
     */
    select?: ApprovalTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTemplate
     */
    omit?: ApprovalTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many ApprovalTemplates.
     */
    data: ApprovalTemplateCreateManyInput | ApprovalTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApprovalTemplate update
   */
  export type ApprovalTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTemplate
     */
    select?: ApprovalTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTemplate
     */
    omit?: ApprovalTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a ApprovalTemplate.
     */
    data: XOR<ApprovalTemplateUpdateInput, ApprovalTemplateUncheckedUpdateInput>
    /**
     * Choose, which ApprovalTemplate to update.
     */
    where: ApprovalTemplateWhereUniqueInput
  }

  /**
   * ApprovalTemplate updateMany
   */
  export type ApprovalTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApprovalTemplates.
     */
    data: XOR<ApprovalTemplateUpdateManyMutationInput, ApprovalTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalTemplates to update
     */
    where?: ApprovalTemplateWhereInput
    /**
     * Limit how many ApprovalTemplates to update.
     */
    limit?: number
  }

  /**
   * ApprovalTemplate updateManyAndReturn
   */
  export type ApprovalTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTemplate
     */
    select?: ApprovalTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTemplate
     */
    omit?: ApprovalTemplateOmit<ExtArgs> | null
    /**
     * The data used to update ApprovalTemplates.
     */
    data: XOR<ApprovalTemplateUpdateManyMutationInput, ApprovalTemplateUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalTemplates to update
     */
    where?: ApprovalTemplateWhereInput
    /**
     * Limit how many ApprovalTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApprovalTemplate upsert
   */
  export type ApprovalTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTemplate
     */
    select?: ApprovalTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTemplate
     */
    omit?: ApprovalTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the ApprovalTemplate to update in case it exists.
     */
    where: ApprovalTemplateWhereUniqueInput
    /**
     * In case the ApprovalTemplate found by the `where` argument doesn't exist, create a new ApprovalTemplate with this data.
     */
    create: XOR<ApprovalTemplateCreateInput, ApprovalTemplateUncheckedCreateInput>
    /**
     * In case the ApprovalTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalTemplateUpdateInput, ApprovalTemplateUncheckedUpdateInput>
  }

  /**
   * ApprovalTemplate delete
   */
  export type ApprovalTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTemplate
     */
    select?: ApprovalTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTemplate
     */
    omit?: ApprovalTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTemplateInclude<ExtArgs> | null
    /**
     * Filter which ApprovalTemplate to delete.
     */
    where: ApprovalTemplateWhereUniqueInput
  }

  /**
   * ApprovalTemplate deleteMany
   */
  export type ApprovalTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalTemplates to delete
     */
    where?: ApprovalTemplateWhereInput
    /**
     * Limit how many ApprovalTemplates to delete.
     */
    limit?: number
  }

  /**
   * ApprovalTemplate.steps
   */
  export type ApprovalTemplate$stepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalStep
     */
    omit?: ApprovalStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    where?: ApprovalStepWhereInput
    orderBy?: ApprovalStepOrderByWithRelationInput | ApprovalStepOrderByWithRelationInput[]
    cursor?: ApprovalStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalStepScalarFieldEnum | ApprovalStepScalarFieldEnum[]
  }

  /**
   * ApprovalTemplate.approvals
   */
  export type ApprovalTemplate$approvalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    where?: ApprovalWhereInput
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    cursor?: ApprovalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * ApprovalTemplate without action
   */
  export type ApprovalTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalTemplate
     */
    select?: ApprovalTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalTemplate
     */
    omit?: ApprovalTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalTemplateInclude<ExtArgs> | null
  }


  /**
   * Model ApprovalStep
   */

  export type AggregateApprovalStep = {
    _count: ApprovalStepCountAggregateOutputType | null
    _avg: ApprovalStepAvgAggregateOutputType | null
    _sum: ApprovalStepSumAggregateOutputType | null
    _min: ApprovalStepMinAggregateOutputType | null
    _max: ApprovalStepMaxAggregateOutputType | null
  }

  export type ApprovalStepAvgAggregateOutputType = {
    stepNumber: number | null
    timeLimit: number | null
  }

  export type ApprovalStepSumAggregateOutputType = {
    stepNumber: number | null
    timeLimit: number | null
  }

  export type ApprovalStepMinAggregateOutputType = {
    id: string | null
    approvalTemplateId: string | null
    stepNumber: number | null
    approverType: $Enums.ApproverType | null
    approverId: string | null
    backup1Id: string | null
    backup2Id: string | null
    timeLimit: number | null
  }

  export type ApprovalStepMaxAggregateOutputType = {
    id: string | null
    approvalTemplateId: string | null
    stepNumber: number | null
    approverType: $Enums.ApproverType | null
    approverId: string | null
    backup1Id: string | null
    backup2Id: string | null
    timeLimit: number | null
  }

  export type ApprovalStepCountAggregateOutputType = {
    id: number
    approvalTemplateId: number
    stepNumber: number
    approverType: number
    approverId: number
    backup1Id: number
    backup2Id: number
    timeLimit: number
    _all: number
  }


  export type ApprovalStepAvgAggregateInputType = {
    stepNumber?: true
    timeLimit?: true
  }

  export type ApprovalStepSumAggregateInputType = {
    stepNumber?: true
    timeLimit?: true
  }

  export type ApprovalStepMinAggregateInputType = {
    id?: true
    approvalTemplateId?: true
    stepNumber?: true
    approverType?: true
    approverId?: true
    backup1Id?: true
    backup2Id?: true
    timeLimit?: true
  }

  export type ApprovalStepMaxAggregateInputType = {
    id?: true
    approvalTemplateId?: true
    stepNumber?: true
    approverType?: true
    approverId?: true
    backup1Id?: true
    backup2Id?: true
    timeLimit?: true
  }

  export type ApprovalStepCountAggregateInputType = {
    id?: true
    approvalTemplateId?: true
    stepNumber?: true
    approverType?: true
    approverId?: true
    backup1Id?: true
    backup2Id?: true
    timeLimit?: true
    _all?: true
  }

  export type ApprovalStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalStep to aggregate.
     */
    where?: ApprovalStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalSteps to fetch.
     */
    orderBy?: ApprovalStepOrderByWithRelationInput | ApprovalStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApprovalSteps
    **/
    _count?: true | ApprovalStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApprovalStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApprovalStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalStepMaxAggregateInputType
  }

  export type GetApprovalStepAggregateType<T extends ApprovalStepAggregateArgs> = {
        [P in keyof T & keyof AggregateApprovalStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApprovalStep[P]>
      : GetScalarType<T[P], AggregateApprovalStep[P]>
  }




  export type ApprovalStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalStepWhereInput
    orderBy?: ApprovalStepOrderByWithAggregationInput | ApprovalStepOrderByWithAggregationInput[]
    by: ApprovalStepScalarFieldEnum[] | ApprovalStepScalarFieldEnum
    having?: ApprovalStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalStepCountAggregateInputType | true
    _avg?: ApprovalStepAvgAggregateInputType
    _sum?: ApprovalStepSumAggregateInputType
    _min?: ApprovalStepMinAggregateInputType
    _max?: ApprovalStepMaxAggregateInputType
  }

  export type ApprovalStepGroupByOutputType = {
    id: string
    approvalTemplateId: string
    stepNumber: number
    approverType: $Enums.ApproverType
    approverId: string | null
    backup1Id: string | null
    backup2Id: string | null
    timeLimit: number | null
    _count: ApprovalStepCountAggregateOutputType | null
    _avg: ApprovalStepAvgAggregateOutputType | null
    _sum: ApprovalStepSumAggregateOutputType | null
    _min: ApprovalStepMinAggregateOutputType | null
    _max: ApprovalStepMaxAggregateOutputType | null
  }

  type GetApprovalStepGroupByPayload<T extends ApprovalStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalStepGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalStepGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    approvalTemplateId?: boolean
    stepNumber?: boolean
    approverType?: boolean
    approverId?: boolean
    backup1Id?: boolean
    backup2Id?: boolean
    timeLimit?: boolean
    approvalTemplate?: boolean | ApprovalTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalStep"]>

  export type ApprovalStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    approvalTemplateId?: boolean
    stepNumber?: boolean
    approverType?: boolean
    approverId?: boolean
    backup1Id?: boolean
    backup2Id?: boolean
    timeLimit?: boolean
    approvalTemplate?: boolean | ApprovalTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalStep"]>

  export type ApprovalStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    approvalTemplateId?: boolean
    stepNumber?: boolean
    approverType?: boolean
    approverId?: boolean
    backup1Id?: boolean
    backup2Id?: boolean
    timeLimit?: boolean
    approvalTemplate?: boolean | ApprovalTemplateDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalStep"]>

  export type ApprovalStepSelectScalar = {
    id?: boolean
    approvalTemplateId?: boolean
    stepNumber?: boolean
    approverType?: boolean
    approverId?: boolean
    backup1Id?: boolean
    backup2Id?: boolean
    timeLimit?: boolean
  }

  export type ApprovalStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "approvalTemplateId" | "stepNumber" | "approverType" | "approverId" | "backup1Id" | "backup2Id" | "timeLimit", ExtArgs["result"]["approvalStep"]>
  export type ApprovalStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvalTemplate?: boolean | ApprovalTemplateDefaultArgs<ExtArgs>
  }
  export type ApprovalStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvalTemplate?: boolean | ApprovalTemplateDefaultArgs<ExtArgs>
  }
  export type ApprovalStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approvalTemplate?: boolean | ApprovalTemplateDefaultArgs<ExtArgs>
  }

  export type $ApprovalStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApprovalStep"
    objects: {
      approvalTemplate: Prisma.$ApprovalTemplatePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      approvalTemplateId: string
      stepNumber: number
      approverType: $Enums.ApproverType
      approverId: string | null
      backup1Id: string | null
      backup2Id: string | null
      timeLimit: number | null
    }, ExtArgs["result"]["approvalStep"]>
    composites: {}
  }

  type ApprovalStepGetPayload<S extends boolean | null | undefined | ApprovalStepDefaultArgs> = $Result.GetResult<Prisma.$ApprovalStepPayload, S>

  type ApprovalStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApprovalStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApprovalStepCountAggregateInputType | true
    }

  export interface ApprovalStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApprovalStep'], meta: { name: 'ApprovalStep' } }
    /**
     * Find zero or one ApprovalStep that matches the filter.
     * @param {ApprovalStepFindUniqueArgs} args - Arguments to find a ApprovalStep
     * @example
     * // Get one ApprovalStep
     * const approvalStep = await prisma.approvalStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalStepFindUniqueArgs>(args: SelectSubset<T, ApprovalStepFindUniqueArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApprovalStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApprovalStepFindUniqueOrThrowArgs} args - Arguments to find a ApprovalStep
     * @example
     * // Get one ApprovalStep
     * const approvalStep = await prisma.approvalStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalStepFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApprovalStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalStepFindFirstArgs} args - Arguments to find a ApprovalStep
     * @example
     * // Get one ApprovalStep
     * const approvalStep = await prisma.approvalStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalStepFindFirstArgs>(args?: SelectSubset<T, ApprovalStepFindFirstArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApprovalStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalStepFindFirstOrThrowArgs} args - Arguments to find a ApprovalStep
     * @example
     * // Get one ApprovalStep
     * const approvalStep = await prisma.approvalStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalStepFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApprovalSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApprovalSteps
     * const approvalSteps = await prisma.approvalStep.findMany()
     * 
     * // Get first 10 ApprovalSteps
     * const approvalSteps = await prisma.approvalStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalStepWithIdOnly = await prisma.approvalStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalStepFindManyArgs>(args?: SelectSubset<T, ApprovalStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApprovalStep.
     * @param {ApprovalStepCreateArgs} args - Arguments to create a ApprovalStep.
     * @example
     * // Create one ApprovalStep
     * const ApprovalStep = await prisma.approvalStep.create({
     *   data: {
     *     // ... data to create a ApprovalStep
     *   }
     * })
     * 
     */
    create<T extends ApprovalStepCreateArgs>(args: SelectSubset<T, ApprovalStepCreateArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApprovalSteps.
     * @param {ApprovalStepCreateManyArgs} args - Arguments to create many ApprovalSteps.
     * @example
     * // Create many ApprovalSteps
     * const approvalStep = await prisma.approvalStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalStepCreateManyArgs>(args?: SelectSubset<T, ApprovalStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApprovalSteps and returns the data saved in the database.
     * @param {ApprovalStepCreateManyAndReturnArgs} args - Arguments to create many ApprovalSteps.
     * @example
     * // Create many ApprovalSteps
     * const approvalStep = await prisma.approvalStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApprovalSteps and only return the `id`
     * const approvalStepWithIdOnly = await prisma.approvalStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalStepCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApprovalStep.
     * @param {ApprovalStepDeleteArgs} args - Arguments to delete one ApprovalStep.
     * @example
     * // Delete one ApprovalStep
     * const ApprovalStep = await prisma.approvalStep.delete({
     *   where: {
     *     // ... filter to delete one ApprovalStep
     *   }
     * })
     * 
     */
    delete<T extends ApprovalStepDeleteArgs>(args: SelectSubset<T, ApprovalStepDeleteArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApprovalStep.
     * @param {ApprovalStepUpdateArgs} args - Arguments to update one ApprovalStep.
     * @example
     * // Update one ApprovalStep
     * const approvalStep = await prisma.approvalStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalStepUpdateArgs>(args: SelectSubset<T, ApprovalStepUpdateArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApprovalSteps.
     * @param {ApprovalStepDeleteManyArgs} args - Arguments to filter ApprovalSteps to delete.
     * @example
     * // Delete a few ApprovalSteps
     * const { count } = await prisma.approvalStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalStepDeleteManyArgs>(args?: SelectSubset<T, ApprovalStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApprovalSteps
     * const approvalStep = await prisma.approvalStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalStepUpdateManyArgs>(args: SelectSubset<T, ApprovalStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalSteps and returns the data updated in the database.
     * @param {ApprovalStepUpdateManyAndReturnArgs} args - Arguments to update many ApprovalSteps.
     * @example
     * // Update many ApprovalSteps
     * const approvalStep = await prisma.approvalStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApprovalSteps and only return the `id`
     * const approvalStepWithIdOnly = await prisma.approvalStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApprovalStepUpdateManyAndReturnArgs>(args: SelectSubset<T, ApprovalStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApprovalStep.
     * @param {ApprovalStepUpsertArgs} args - Arguments to update or create a ApprovalStep.
     * @example
     * // Update or create a ApprovalStep
     * const approvalStep = await prisma.approvalStep.upsert({
     *   create: {
     *     // ... data to create a ApprovalStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApprovalStep we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalStepUpsertArgs>(args: SelectSubset<T, ApprovalStepUpsertArgs<ExtArgs>>): Prisma__ApprovalStepClient<$Result.GetResult<Prisma.$ApprovalStepPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApprovalSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalStepCountArgs} args - Arguments to filter ApprovalSteps to count.
     * @example
     * // Count the number of ApprovalSteps
     * const count = await prisma.approvalStep.count({
     *   where: {
     *     // ... the filter for the ApprovalSteps we want to count
     *   }
     * })
    **/
    count<T extends ApprovalStepCountArgs>(
      args?: Subset<T, ApprovalStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApprovalStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalStepAggregateArgs>(args: Subset<T, ApprovalStepAggregateArgs>): Prisma.PrismaPromise<GetApprovalStepAggregateType<T>>

    /**
     * Group by ApprovalStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalStepGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApprovalStep model
   */
  readonly fields: ApprovalStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApprovalStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    approvalTemplate<T extends ApprovalTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalTemplateDefaultArgs<ExtArgs>>): Prisma__ApprovalTemplateClient<$Result.GetResult<Prisma.$ApprovalTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApprovalStep model
   */
  interface ApprovalStepFieldRefs {
    readonly id: FieldRef<"ApprovalStep", 'String'>
    readonly approvalTemplateId: FieldRef<"ApprovalStep", 'String'>
    readonly stepNumber: FieldRef<"ApprovalStep", 'Int'>
    readonly approverType: FieldRef<"ApprovalStep", 'ApproverType'>
    readonly approverId: FieldRef<"ApprovalStep", 'String'>
    readonly backup1Id: FieldRef<"ApprovalStep", 'String'>
    readonly backup2Id: FieldRef<"ApprovalStep", 'String'>
    readonly timeLimit: FieldRef<"ApprovalStep", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ApprovalStep findUnique
   */
  export type ApprovalStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalStep
     */
    omit?: ApprovalStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalStep to fetch.
     */
    where: ApprovalStepWhereUniqueInput
  }

  /**
   * ApprovalStep findUniqueOrThrow
   */
  export type ApprovalStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalStep
     */
    omit?: ApprovalStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalStep to fetch.
     */
    where: ApprovalStepWhereUniqueInput
  }

  /**
   * ApprovalStep findFirst
   */
  export type ApprovalStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalStep
     */
    omit?: ApprovalStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalStep to fetch.
     */
    where?: ApprovalStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalSteps to fetch.
     */
    orderBy?: ApprovalStepOrderByWithRelationInput | ApprovalStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalSteps.
     */
    cursor?: ApprovalStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalSteps.
     */
    distinct?: ApprovalStepScalarFieldEnum | ApprovalStepScalarFieldEnum[]
  }

  /**
   * ApprovalStep findFirstOrThrow
   */
  export type ApprovalStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalStep
     */
    omit?: ApprovalStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalStep to fetch.
     */
    where?: ApprovalStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalSteps to fetch.
     */
    orderBy?: ApprovalStepOrderByWithRelationInput | ApprovalStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalSteps.
     */
    cursor?: ApprovalStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalSteps.
     */
    distinct?: ApprovalStepScalarFieldEnum | ApprovalStepScalarFieldEnum[]
  }

  /**
   * ApprovalStep findMany
   */
  export type ApprovalStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalStep
     */
    omit?: ApprovalStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalSteps to fetch.
     */
    where?: ApprovalStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalSteps to fetch.
     */
    orderBy?: ApprovalStepOrderByWithRelationInput | ApprovalStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApprovalSteps.
     */
    cursor?: ApprovalStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalSteps.
     */
    skip?: number
    distinct?: ApprovalStepScalarFieldEnum | ApprovalStepScalarFieldEnum[]
  }

  /**
   * ApprovalStep create
   */
  export type ApprovalStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalStep
     */
    omit?: ApprovalStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * The data needed to create a ApprovalStep.
     */
    data: XOR<ApprovalStepCreateInput, ApprovalStepUncheckedCreateInput>
  }

  /**
   * ApprovalStep createMany
   */
  export type ApprovalStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApprovalSteps.
     */
    data: ApprovalStepCreateManyInput | ApprovalStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApprovalStep createManyAndReturn
   */
  export type ApprovalStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalStep
     */
    omit?: ApprovalStepOmit<ExtArgs> | null
    /**
     * The data used to create many ApprovalSteps.
     */
    data: ApprovalStepCreateManyInput | ApprovalStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApprovalStep update
   */
  export type ApprovalStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalStep
     */
    omit?: ApprovalStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * The data needed to update a ApprovalStep.
     */
    data: XOR<ApprovalStepUpdateInput, ApprovalStepUncheckedUpdateInput>
    /**
     * Choose, which ApprovalStep to update.
     */
    where: ApprovalStepWhereUniqueInput
  }

  /**
   * ApprovalStep updateMany
   */
  export type ApprovalStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApprovalSteps.
     */
    data: XOR<ApprovalStepUpdateManyMutationInput, ApprovalStepUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalSteps to update
     */
    where?: ApprovalStepWhereInput
    /**
     * Limit how many ApprovalSteps to update.
     */
    limit?: number
  }

  /**
   * ApprovalStep updateManyAndReturn
   */
  export type ApprovalStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalStep
     */
    omit?: ApprovalStepOmit<ExtArgs> | null
    /**
     * The data used to update ApprovalSteps.
     */
    data: XOR<ApprovalStepUpdateManyMutationInput, ApprovalStepUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalSteps to update
     */
    where?: ApprovalStepWhereInput
    /**
     * Limit how many ApprovalSteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApprovalStep upsert
   */
  export type ApprovalStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalStep
     */
    omit?: ApprovalStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * The filter to search for the ApprovalStep to update in case it exists.
     */
    where: ApprovalStepWhereUniqueInput
    /**
     * In case the ApprovalStep found by the `where` argument doesn't exist, create a new ApprovalStep with this data.
     */
    create: XOR<ApprovalStepCreateInput, ApprovalStepUncheckedCreateInput>
    /**
     * In case the ApprovalStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalStepUpdateInput, ApprovalStepUncheckedUpdateInput>
  }

  /**
   * ApprovalStep delete
   */
  export type ApprovalStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalStep
     */
    omit?: ApprovalStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
    /**
     * Filter which ApprovalStep to delete.
     */
    where: ApprovalStepWhereUniqueInput
  }

  /**
   * ApprovalStep deleteMany
   */
  export type ApprovalStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalSteps to delete
     */
    where?: ApprovalStepWhereInput
    /**
     * Limit how many ApprovalSteps to delete.
     */
    limit?: number
  }

  /**
   * ApprovalStep without action
   */
  export type ApprovalStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalStep
     */
    select?: ApprovalStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalStep
     */
    omit?: ApprovalStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalStepInclude<ExtArgs> | null
  }


  /**
   * Model Approval
   */

  export type AggregateApproval = {
    _count: ApprovalCountAggregateOutputType | null
    _avg: ApprovalAvgAggregateOutputType | null
    _sum: ApprovalSumAggregateOutputType | null
    _min: ApprovalMinAggregateOutputType | null
    _max: ApprovalMaxAggregateOutputType | null
  }

  export type ApprovalAvgAggregateOutputType = {
    currentStep: number | null
  }

  export type ApprovalSumAggregateOutputType = {
    currentStep: number | null
  }

  export type ApprovalMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    templateId: string | null
    entityType: string | null
    entityId: string | null
    requesterId: string | null
    currentStep: number | null
    status: $Enums.ApprovalStatus | null
    leaveId: string | null
    overtimeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    templateId: string | null
    entityType: string | null
    entityId: string | null
    requesterId: string | null
    currentStep: number | null
    status: $Enums.ApprovalStatus | null
    leaveId: string | null
    overtimeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApprovalCountAggregateOutputType = {
    id: number
    workspaceId: number
    templateId: number
    entityType: number
    entityId: number
    requesterId: number
    currentStep: number
    status: number
    leaveId: number
    overtimeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApprovalAvgAggregateInputType = {
    currentStep?: true
  }

  export type ApprovalSumAggregateInputType = {
    currentStep?: true
  }

  export type ApprovalMinAggregateInputType = {
    id?: true
    workspaceId?: true
    templateId?: true
    entityType?: true
    entityId?: true
    requesterId?: true
    currentStep?: true
    status?: true
    leaveId?: true
    overtimeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    templateId?: true
    entityType?: true
    entityId?: true
    requesterId?: true
    currentStep?: true
    status?: true
    leaveId?: true
    overtimeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApprovalCountAggregateInputType = {
    id?: true
    workspaceId?: true
    templateId?: true
    entityType?: true
    entityId?: true
    requesterId?: true
    currentStep?: true
    status?: true
    leaveId?: true
    overtimeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApprovalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Approval to aggregate.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Approvals
    **/
    _count?: true | ApprovalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApprovalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApprovalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalMaxAggregateInputType
  }

  export type GetApprovalAggregateType<T extends ApprovalAggregateArgs> = {
        [P in keyof T & keyof AggregateApproval]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApproval[P]>
      : GetScalarType<T[P], AggregateApproval[P]>
  }




  export type ApprovalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalWhereInput
    orderBy?: ApprovalOrderByWithAggregationInput | ApprovalOrderByWithAggregationInput[]
    by: ApprovalScalarFieldEnum[] | ApprovalScalarFieldEnum
    having?: ApprovalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalCountAggregateInputType | true
    _avg?: ApprovalAvgAggregateInputType
    _sum?: ApprovalSumAggregateInputType
    _min?: ApprovalMinAggregateInputType
    _max?: ApprovalMaxAggregateInputType
  }

  export type ApprovalGroupByOutputType = {
    id: string
    workspaceId: string
    templateId: string
    entityType: string
    entityId: string
    requesterId: string
    currentStep: number
    status: $Enums.ApprovalStatus
    leaveId: string | null
    overtimeId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ApprovalCountAggregateOutputType | null
    _avg: ApprovalAvgAggregateOutputType | null
    _sum: ApprovalSumAggregateOutputType | null
    _min: ApprovalMinAggregateOutputType | null
    _max: ApprovalMaxAggregateOutputType | null
  }

  type GetApprovalGroupByPayload<T extends ApprovalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    templateId?: boolean
    entityType?: boolean
    entityId?: boolean
    requesterId?: boolean
    currentStep?: boolean
    status?: boolean
    leaveId?: boolean
    overtimeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    template?: boolean | ApprovalTemplateDefaultArgs<ExtArgs>
    leave?: boolean | Approval$leaveArgs<ExtArgs>
    overtime?: boolean | Approval$overtimeArgs<ExtArgs>
    actions?: boolean | Approval$actionsArgs<ExtArgs>
    _count?: boolean | ApprovalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approval"]>

  export type ApprovalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    templateId?: boolean
    entityType?: boolean
    entityId?: boolean
    requesterId?: boolean
    currentStep?: boolean
    status?: boolean
    leaveId?: boolean
    overtimeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    template?: boolean | ApprovalTemplateDefaultArgs<ExtArgs>
    leave?: boolean | Approval$leaveArgs<ExtArgs>
    overtime?: boolean | Approval$overtimeArgs<ExtArgs>
  }, ExtArgs["result"]["approval"]>

  export type ApprovalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    templateId?: boolean
    entityType?: boolean
    entityId?: boolean
    requesterId?: boolean
    currentStep?: boolean
    status?: boolean
    leaveId?: boolean
    overtimeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    template?: boolean | ApprovalTemplateDefaultArgs<ExtArgs>
    leave?: boolean | Approval$leaveArgs<ExtArgs>
    overtime?: boolean | Approval$overtimeArgs<ExtArgs>
  }, ExtArgs["result"]["approval"]>

  export type ApprovalSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    templateId?: boolean
    entityType?: boolean
    entityId?: boolean
    requesterId?: boolean
    currentStep?: boolean
    status?: boolean
    leaveId?: boolean
    overtimeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApprovalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "templateId" | "entityType" | "entityId" | "requesterId" | "currentStep" | "status" | "leaveId" | "overtimeId" | "createdAt" | "updatedAt", ExtArgs["result"]["approval"]>
  export type ApprovalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    template?: boolean | ApprovalTemplateDefaultArgs<ExtArgs>
    leave?: boolean | Approval$leaveArgs<ExtArgs>
    overtime?: boolean | Approval$overtimeArgs<ExtArgs>
    actions?: boolean | Approval$actionsArgs<ExtArgs>
    _count?: boolean | ApprovalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ApprovalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    template?: boolean | ApprovalTemplateDefaultArgs<ExtArgs>
    leave?: boolean | Approval$leaveArgs<ExtArgs>
    overtime?: boolean | Approval$overtimeArgs<ExtArgs>
  }
  export type ApprovalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    template?: boolean | ApprovalTemplateDefaultArgs<ExtArgs>
    leave?: boolean | Approval$leaveArgs<ExtArgs>
    overtime?: boolean | Approval$overtimeArgs<ExtArgs>
  }

  export type $ApprovalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Approval"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      template: Prisma.$ApprovalTemplatePayload<ExtArgs>
      leave: Prisma.$LeavePayload<ExtArgs> | null
      overtime: Prisma.$OvertimePayload<ExtArgs> | null
      actions: Prisma.$ApprovalActionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      templateId: string
      entityType: string
      entityId: string
      requesterId: string
      currentStep: number
      status: $Enums.ApprovalStatus
      leaveId: string | null
      overtimeId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["approval"]>
    composites: {}
  }

  type ApprovalGetPayload<S extends boolean | null | undefined | ApprovalDefaultArgs> = $Result.GetResult<Prisma.$ApprovalPayload, S>

  type ApprovalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApprovalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApprovalCountAggregateInputType | true
    }

  export interface ApprovalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Approval'], meta: { name: 'Approval' } }
    /**
     * Find zero or one Approval that matches the filter.
     * @param {ApprovalFindUniqueArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalFindUniqueArgs>(args: SelectSubset<T, ApprovalFindUniqueArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Approval that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApprovalFindUniqueOrThrowArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Approval that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindFirstArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalFindFirstArgs>(args?: SelectSubset<T, ApprovalFindFirstArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Approval that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindFirstOrThrowArgs} args - Arguments to find a Approval
     * @example
     * // Get one Approval
     * const approval = await prisma.approval.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Approvals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Approvals
     * const approvals = await prisma.approval.findMany()
     * 
     * // Get first 10 Approvals
     * const approvals = await prisma.approval.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalWithIdOnly = await prisma.approval.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalFindManyArgs>(args?: SelectSubset<T, ApprovalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Approval.
     * @param {ApprovalCreateArgs} args - Arguments to create a Approval.
     * @example
     * // Create one Approval
     * const Approval = await prisma.approval.create({
     *   data: {
     *     // ... data to create a Approval
     *   }
     * })
     * 
     */
    create<T extends ApprovalCreateArgs>(args: SelectSubset<T, ApprovalCreateArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Approvals.
     * @param {ApprovalCreateManyArgs} args - Arguments to create many Approvals.
     * @example
     * // Create many Approvals
     * const approval = await prisma.approval.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalCreateManyArgs>(args?: SelectSubset<T, ApprovalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Approvals and returns the data saved in the database.
     * @param {ApprovalCreateManyAndReturnArgs} args - Arguments to create many Approvals.
     * @example
     * // Create many Approvals
     * const approval = await prisma.approval.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Approvals and only return the `id`
     * const approvalWithIdOnly = await prisma.approval.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Approval.
     * @param {ApprovalDeleteArgs} args - Arguments to delete one Approval.
     * @example
     * // Delete one Approval
     * const Approval = await prisma.approval.delete({
     *   where: {
     *     // ... filter to delete one Approval
     *   }
     * })
     * 
     */
    delete<T extends ApprovalDeleteArgs>(args: SelectSubset<T, ApprovalDeleteArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Approval.
     * @param {ApprovalUpdateArgs} args - Arguments to update one Approval.
     * @example
     * // Update one Approval
     * const approval = await prisma.approval.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalUpdateArgs>(args: SelectSubset<T, ApprovalUpdateArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Approvals.
     * @param {ApprovalDeleteManyArgs} args - Arguments to filter Approvals to delete.
     * @example
     * // Delete a few Approvals
     * const { count } = await prisma.approval.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalDeleteManyArgs>(args?: SelectSubset<T, ApprovalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Approvals
     * const approval = await prisma.approval.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalUpdateManyArgs>(args: SelectSubset<T, ApprovalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Approvals and returns the data updated in the database.
     * @param {ApprovalUpdateManyAndReturnArgs} args - Arguments to update many Approvals.
     * @example
     * // Update many Approvals
     * const approval = await prisma.approval.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Approvals and only return the `id`
     * const approvalWithIdOnly = await prisma.approval.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApprovalUpdateManyAndReturnArgs>(args: SelectSubset<T, ApprovalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Approval.
     * @param {ApprovalUpsertArgs} args - Arguments to update or create a Approval.
     * @example
     * // Update or create a Approval
     * const approval = await prisma.approval.upsert({
     *   create: {
     *     // ... data to create a Approval
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Approval we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalUpsertArgs>(args: SelectSubset<T, ApprovalUpsertArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Approvals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalCountArgs} args - Arguments to filter Approvals to count.
     * @example
     * // Count the number of Approvals
     * const count = await prisma.approval.count({
     *   where: {
     *     // ... the filter for the Approvals we want to count
     *   }
     * })
    **/
    count<T extends ApprovalCountArgs>(
      args?: Subset<T, ApprovalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Approval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalAggregateArgs>(args: Subset<T, ApprovalAggregateArgs>): Prisma.PrismaPromise<GetApprovalAggregateType<T>>

    /**
     * Group by Approval.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Approval model
   */
  readonly fields: ApprovalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Approval.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    template<T extends ApprovalTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalTemplateDefaultArgs<ExtArgs>>): Prisma__ApprovalTemplateClient<$Result.GetResult<Prisma.$ApprovalTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    leave<T extends Approval$leaveArgs<ExtArgs> = {}>(args?: Subset<T, Approval$leaveArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    overtime<T extends Approval$overtimeArgs<ExtArgs> = {}>(args?: Subset<T, Approval$overtimeArgs<ExtArgs>>): Prisma__OvertimeClient<$Result.GetResult<Prisma.$OvertimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    actions<T extends Approval$actionsArgs<ExtArgs> = {}>(args?: Subset<T, Approval$actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Approval model
   */
  interface ApprovalFieldRefs {
    readonly id: FieldRef<"Approval", 'String'>
    readonly workspaceId: FieldRef<"Approval", 'String'>
    readonly templateId: FieldRef<"Approval", 'String'>
    readonly entityType: FieldRef<"Approval", 'String'>
    readonly entityId: FieldRef<"Approval", 'String'>
    readonly requesterId: FieldRef<"Approval", 'String'>
    readonly currentStep: FieldRef<"Approval", 'Int'>
    readonly status: FieldRef<"Approval", 'ApprovalStatus'>
    readonly leaveId: FieldRef<"Approval", 'String'>
    readonly overtimeId: FieldRef<"Approval", 'String'>
    readonly createdAt: FieldRef<"Approval", 'DateTime'>
    readonly updatedAt: FieldRef<"Approval", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Approval findUnique
   */
  export type ApprovalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval findUniqueOrThrow
   */
  export type ApprovalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval findFirst
   */
  export type ApprovalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Approvals.
     */
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Approval findFirstOrThrow
   */
  export type ApprovalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approval to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Approvals.
     */
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Approval findMany
   */
  export type ApprovalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter, which Approvals to fetch.
     */
    where?: ApprovalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Approvals to fetch.
     */
    orderBy?: ApprovalOrderByWithRelationInput | ApprovalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Approvals.
     */
    cursor?: ApprovalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Approvals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Approvals.
     */
    skip?: number
    distinct?: ApprovalScalarFieldEnum | ApprovalScalarFieldEnum[]
  }

  /**
   * Approval create
   */
  export type ApprovalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The data needed to create a Approval.
     */
    data: XOR<ApprovalCreateInput, ApprovalUncheckedCreateInput>
  }

  /**
   * Approval createMany
   */
  export type ApprovalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Approvals.
     */
    data: ApprovalCreateManyInput | ApprovalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Approval createManyAndReturn
   */
  export type ApprovalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * The data used to create many Approvals.
     */
    data: ApprovalCreateManyInput | ApprovalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Approval update
   */
  export type ApprovalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The data needed to update a Approval.
     */
    data: XOR<ApprovalUpdateInput, ApprovalUncheckedUpdateInput>
    /**
     * Choose, which Approval to update.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval updateMany
   */
  export type ApprovalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Approvals.
     */
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyInput>
    /**
     * Filter which Approvals to update
     */
    where?: ApprovalWhereInput
    /**
     * Limit how many Approvals to update.
     */
    limit?: number
  }

  /**
   * Approval updateManyAndReturn
   */
  export type ApprovalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * The data used to update Approvals.
     */
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyInput>
    /**
     * Filter which Approvals to update
     */
    where?: ApprovalWhereInput
    /**
     * Limit how many Approvals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Approval upsert
   */
  export type ApprovalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * The filter to search for the Approval to update in case it exists.
     */
    where: ApprovalWhereUniqueInput
    /**
     * In case the Approval found by the `where` argument doesn't exist, create a new Approval with this data.
     */
    create: XOR<ApprovalCreateInput, ApprovalUncheckedCreateInput>
    /**
     * In case the Approval was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalUpdateInput, ApprovalUncheckedUpdateInput>
  }

  /**
   * Approval delete
   */
  export type ApprovalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
    /**
     * Filter which Approval to delete.
     */
    where: ApprovalWhereUniqueInput
  }

  /**
   * Approval deleteMany
   */
  export type ApprovalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Approvals to delete
     */
    where?: ApprovalWhereInput
    /**
     * Limit how many Approvals to delete.
     */
    limit?: number
  }

  /**
   * Approval.leave
   */
  export type Approval$leaveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Leave
     */
    omit?: LeaveOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    where?: LeaveWhereInput
  }

  /**
   * Approval.overtime
   */
  export type Approval$overtimeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Overtime
     */
    select?: OvertimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Overtime
     */
    omit?: OvertimeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OvertimeInclude<ExtArgs> | null
    where?: OvertimeWhereInput
  }

  /**
   * Approval.actions
   */
  export type Approval$actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalAction
     */
    omit?: ApprovalActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    where?: ApprovalActionWhereInput
    orderBy?: ApprovalActionOrderByWithRelationInput | ApprovalActionOrderByWithRelationInput[]
    cursor?: ApprovalActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApprovalActionScalarFieldEnum | ApprovalActionScalarFieldEnum[]
  }

  /**
   * Approval without action
   */
  export type ApprovalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Approval
     */
    select?: ApprovalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Approval
     */
    omit?: ApprovalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalInclude<ExtArgs> | null
  }


  /**
   * Model ApprovalAction
   */

  export type AggregateApprovalAction = {
    _count: ApprovalActionCountAggregateOutputType | null
    _avg: ApprovalActionAvgAggregateOutputType | null
    _sum: ApprovalActionSumAggregateOutputType | null
    _min: ApprovalActionMinAggregateOutputType | null
    _max: ApprovalActionMaxAggregateOutputType | null
  }

  export type ApprovalActionAvgAggregateOutputType = {
    step: number | null
  }

  export type ApprovalActionSumAggregateOutputType = {
    step: number | null
  }

  export type ApprovalActionMinAggregateOutputType = {
    id: string | null
    approvalId: string | null
    userId: string | null
    step: number | null
    action: string | null
    comment: string | null
    createdAt: Date | null
  }

  export type ApprovalActionMaxAggregateOutputType = {
    id: string | null
    approvalId: string | null
    userId: string | null
    step: number | null
    action: string | null
    comment: string | null
    createdAt: Date | null
  }

  export type ApprovalActionCountAggregateOutputType = {
    id: number
    approvalId: number
    userId: number
    step: number
    action: number
    comment: number
    createdAt: number
    _all: number
  }


  export type ApprovalActionAvgAggregateInputType = {
    step?: true
  }

  export type ApprovalActionSumAggregateInputType = {
    step?: true
  }

  export type ApprovalActionMinAggregateInputType = {
    id?: true
    approvalId?: true
    userId?: true
    step?: true
    action?: true
    comment?: true
    createdAt?: true
  }

  export type ApprovalActionMaxAggregateInputType = {
    id?: true
    approvalId?: true
    userId?: true
    step?: true
    action?: true
    comment?: true
    createdAt?: true
  }

  export type ApprovalActionCountAggregateInputType = {
    id?: true
    approvalId?: true
    userId?: true
    step?: true
    action?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type ApprovalActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalAction to aggregate.
     */
    where?: ApprovalActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalActions to fetch.
     */
    orderBy?: ApprovalActionOrderByWithRelationInput | ApprovalActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApprovalActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApprovalActions
    **/
    _count?: true | ApprovalActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApprovalActionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApprovalActionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApprovalActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApprovalActionMaxAggregateInputType
  }

  export type GetApprovalActionAggregateType<T extends ApprovalActionAggregateArgs> = {
        [P in keyof T & keyof AggregateApprovalAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApprovalAction[P]>
      : GetScalarType<T[P], AggregateApprovalAction[P]>
  }




  export type ApprovalActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApprovalActionWhereInput
    orderBy?: ApprovalActionOrderByWithAggregationInput | ApprovalActionOrderByWithAggregationInput[]
    by: ApprovalActionScalarFieldEnum[] | ApprovalActionScalarFieldEnum
    having?: ApprovalActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApprovalActionCountAggregateInputType | true
    _avg?: ApprovalActionAvgAggregateInputType
    _sum?: ApprovalActionSumAggregateInputType
    _min?: ApprovalActionMinAggregateInputType
    _max?: ApprovalActionMaxAggregateInputType
  }

  export type ApprovalActionGroupByOutputType = {
    id: string
    approvalId: string
    userId: string
    step: number
    action: string
    comment: string | null
    createdAt: Date
    _count: ApprovalActionCountAggregateOutputType | null
    _avg: ApprovalActionAvgAggregateOutputType | null
    _sum: ApprovalActionSumAggregateOutputType | null
    _min: ApprovalActionMinAggregateOutputType | null
    _max: ApprovalActionMaxAggregateOutputType | null
  }

  type GetApprovalActionGroupByPayload<T extends ApprovalActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApprovalActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApprovalActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApprovalActionGroupByOutputType[P]>
            : GetScalarType<T[P], ApprovalActionGroupByOutputType[P]>
        }
      >
    >


  export type ApprovalActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    approvalId?: boolean
    userId?: boolean
    step?: boolean
    action?: boolean
    comment?: boolean
    createdAt?: boolean
    approval?: boolean | ApprovalDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalAction"]>

  export type ApprovalActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    approvalId?: boolean
    userId?: boolean
    step?: boolean
    action?: boolean
    comment?: boolean
    createdAt?: boolean
    approval?: boolean | ApprovalDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalAction"]>

  export type ApprovalActionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    approvalId?: boolean
    userId?: boolean
    step?: boolean
    action?: boolean
    comment?: boolean
    createdAt?: boolean
    approval?: boolean | ApprovalDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["approvalAction"]>

  export type ApprovalActionSelectScalar = {
    id?: boolean
    approvalId?: boolean
    userId?: boolean
    step?: boolean
    action?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type ApprovalActionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "approvalId" | "userId" | "step" | "action" | "comment" | "createdAt", ExtArgs["result"]["approvalAction"]>
  export type ApprovalActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approval?: boolean | ApprovalDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApprovalActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approval?: boolean | ApprovalDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApprovalActionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approval?: boolean | ApprovalDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ApprovalActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApprovalAction"
    objects: {
      approval: Prisma.$ApprovalPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      approvalId: string
      userId: string
      step: number
      action: string
      comment: string | null
      createdAt: Date
    }, ExtArgs["result"]["approvalAction"]>
    composites: {}
  }

  type ApprovalActionGetPayload<S extends boolean | null | undefined | ApprovalActionDefaultArgs> = $Result.GetResult<Prisma.$ApprovalActionPayload, S>

  type ApprovalActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApprovalActionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApprovalActionCountAggregateInputType | true
    }

  export interface ApprovalActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApprovalAction'], meta: { name: 'ApprovalAction' } }
    /**
     * Find zero or one ApprovalAction that matches the filter.
     * @param {ApprovalActionFindUniqueArgs} args - Arguments to find a ApprovalAction
     * @example
     * // Get one ApprovalAction
     * const approvalAction = await prisma.approvalAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApprovalActionFindUniqueArgs>(args: SelectSubset<T, ApprovalActionFindUniqueArgs<ExtArgs>>): Prisma__ApprovalActionClient<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ApprovalAction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApprovalActionFindUniqueOrThrowArgs} args - Arguments to find a ApprovalAction
     * @example
     * // Get one ApprovalAction
     * const approvalAction = await prisma.approvalAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApprovalActionFindUniqueOrThrowArgs>(args: SelectSubset<T, ApprovalActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApprovalActionClient<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApprovalAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalActionFindFirstArgs} args - Arguments to find a ApprovalAction
     * @example
     * // Get one ApprovalAction
     * const approvalAction = await prisma.approvalAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApprovalActionFindFirstArgs>(args?: SelectSubset<T, ApprovalActionFindFirstArgs<ExtArgs>>): Prisma__ApprovalActionClient<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ApprovalAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalActionFindFirstOrThrowArgs} args - Arguments to find a ApprovalAction
     * @example
     * // Get one ApprovalAction
     * const approvalAction = await prisma.approvalAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApprovalActionFindFirstOrThrowArgs>(args?: SelectSubset<T, ApprovalActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApprovalActionClient<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ApprovalActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApprovalActions
     * const approvalActions = await prisma.approvalAction.findMany()
     * 
     * // Get first 10 ApprovalActions
     * const approvalActions = await prisma.approvalAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const approvalActionWithIdOnly = await prisma.approvalAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApprovalActionFindManyArgs>(args?: SelectSubset<T, ApprovalActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ApprovalAction.
     * @param {ApprovalActionCreateArgs} args - Arguments to create a ApprovalAction.
     * @example
     * // Create one ApprovalAction
     * const ApprovalAction = await prisma.approvalAction.create({
     *   data: {
     *     // ... data to create a ApprovalAction
     *   }
     * })
     * 
     */
    create<T extends ApprovalActionCreateArgs>(args: SelectSubset<T, ApprovalActionCreateArgs<ExtArgs>>): Prisma__ApprovalActionClient<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ApprovalActions.
     * @param {ApprovalActionCreateManyArgs} args - Arguments to create many ApprovalActions.
     * @example
     * // Create many ApprovalActions
     * const approvalAction = await prisma.approvalAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApprovalActionCreateManyArgs>(args?: SelectSubset<T, ApprovalActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApprovalActions and returns the data saved in the database.
     * @param {ApprovalActionCreateManyAndReturnArgs} args - Arguments to create many ApprovalActions.
     * @example
     * // Create many ApprovalActions
     * const approvalAction = await prisma.approvalAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApprovalActions and only return the `id`
     * const approvalActionWithIdOnly = await prisma.approvalAction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApprovalActionCreateManyAndReturnArgs>(args?: SelectSubset<T, ApprovalActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ApprovalAction.
     * @param {ApprovalActionDeleteArgs} args - Arguments to delete one ApprovalAction.
     * @example
     * // Delete one ApprovalAction
     * const ApprovalAction = await prisma.approvalAction.delete({
     *   where: {
     *     // ... filter to delete one ApprovalAction
     *   }
     * })
     * 
     */
    delete<T extends ApprovalActionDeleteArgs>(args: SelectSubset<T, ApprovalActionDeleteArgs<ExtArgs>>): Prisma__ApprovalActionClient<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ApprovalAction.
     * @param {ApprovalActionUpdateArgs} args - Arguments to update one ApprovalAction.
     * @example
     * // Update one ApprovalAction
     * const approvalAction = await prisma.approvalAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApprovalActionUpdateArgs>(args: SelectSubset<T, ApprovalActionUpdateArgs<ExtArgs>>): Prisma__ApprovalActionClient<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ApprovalActions.
     * @param {ApprovalActionDeleteManyArgs} args - Arguments to filter ApprovalActions to delete.
     * @example
     * // Delete a few ApprovalActions
     * const { count } = await prisma.approvalAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApprovalActionDeleteManyArgs>(args?: SelectSubset<T, ApprovalActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApprovalActions
     * const approvalAction = await prisma.approvalAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApprovalActionUpdateManyArgs>(args: SelectSubset<T, ApprovalActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApprovalActions and returns the data updated in the database.
     * @param {ApprovalActionUpdateManyAndReturnArgs} args - Arguments to update many ApprovalActions.
     * @example
     * // Update many ApprovalActions
     * const approvalAction = await prisma.approvalAction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApprovalActions and only return the `id`
     * const approvalActionWithIdOnly = await prisma.approvalAction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApprovalActionUpdateManyAndReturnArgs>(args: SelectSubset<T, ApprovalActionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ApprovalAction.
     * @param {ApprovalActionUpsertArgs} args - Arguments to update or create a ApprovalAction.
     * @example
     * // Update or create a ApprovalAction
     * const approvalAction = await prisma.approvalAction.upsert({
     *   create: {
     *     // ... data to create a ApprovalAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApprovalAction we want to update
     *   }
     * })
     */
    upsert<T extends ApprovalActionUpsertArgs>(args: SelectSubset<T, ApprovalActionUpsertArgs<ExtArgs>>): Prisma__ApprovalActionClient<$Result.GetResult<Prisma.$ApprovalActionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ApprovalActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalActionCountArgs} args - Arguments to filter ApprovalActions to count.
     * @example
     * // Count the number of ApprovalActions
     * const count = await prisma.approvalAction.count({
     *   where: {
     *     // ... the filter for the ApprovalActions we want to count
     *   }
     * })
    **/
    count<T extends ApprovalActionCountArgs>(
      args?: Subset<T, ApprovalActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApprovalActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApprovalAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApprovalActionAggregateArgs>(args: Subset<T, ApprovalActionAggregateArgs>): Prisma.PrismaPromise<GetApprovalActionAggregateType<T>>

    /**
     * Group by ApprovalAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApprovalActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApprovalActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApprovalActionGroupByArgs['orderBy'] }
        : { orderBy?: ApprovalActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApprovalActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApprovalActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApprovalAction model
   */
  readonly fields: ApprovalActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApprovalAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApprovalActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    approval<T extends ApprovalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ApprovalDefaultArgs<ExtArgs>>): Prisma__ApprovalClient<$Result.GetResult<Prisma.$ApprovalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApprovalAction model
   */
  interface ApprovalActionFieldRefs {
    readonly id: FieldRef<"ApprovalAction", 'String'>
    readonly approvalId: FieldRef<"ApprovalAction", 'String'>
    readonly userId: FieldRef<"ApprovalAction", 'String'>
    readonly step: FieldRef<"ApprovalAction", 'Int'>
    readonly action: FieldRef<"ApprovalAction", 'String'>
    readonly comment: FieldRef<"ApprovalAction", 'String'>
    readonly createdAt: FieldRef<"ApprovalAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApprovalAction findUnique
   */
  export type ApprovalActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalAction
     */
    omit?: ApprovalActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalAction to fetch.
     */
    where: ApprovalActionWhereUniqueInput
  }

  /**
   * ApprovalAction findUniqueOrThrow
   */
  export type ApprovalActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalAction
     */
    omit?: ApprovalActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalAction to fetch.
     */
    where: ApprovalActionWhereUniqueInput
  }

  /**
   * ApprovalAction findFirst
   */
  export type ApprovalActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalAction
     */
    omit?: ApprovalActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalAction to fetch.
     */
    where?: ApprovalActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalActions to fetch.
     */
    orderBy?: ApprovalActionOrderByWithRelationInput | ApprovalActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalActions.
     */
    cursor?: ApprovalActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalActions.
     */
    distinct?: ApprovalActionScalarFieldEnum | ApprovalActionScalarFieldEnum[]
  }

  /**
   * ApprovalAction findFirstOrThrow
   */
  export type ApprovalActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalAction
     */
    omit?: ApprovalActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalAction to fetch.
     */
    where?: ApprovalActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalActions to fetch.
     */
    orderBy?: ApprovalActionOrderByWithRelationInput | ApprovalActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApprovalActions.
     */
    cursor?: ApprovalActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApprovalActions.
     */
    distinct?: ApprovalActionScalarFieldEnum | ApprovalActionScalarFieldEnum[]
  }

  /**
   * ApprovalAction findMany
   */
  export type ApprovalActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalAction
     */
    omit?: ApprovalActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * Filter, which ApprovalActions to fetch.
     */
    where?: ApprovalActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApprovalActions to fetch.
     */
    orderBy?: ApprovalActionOrderByWithRelationInput | ApprovalActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApprovalActions.
     */
    cursor?: ApprovalActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApprovalActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApprovalActions.
     */
    skip?: number
    distinct?: ApprovalActionScalarFieldEnum | ApprovalActionScalarFieldEnum[]
  }

  /**
   * ApprovalAction create
   */
  export type ApprovalActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalAction
     */
    omit?: ApprovalActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * The data needed to create a ApprovalAction.
     */
    data: XOR<ApprovalActionCreateInput, ApprovalActionUncheckedCreateInput>
  }

  /**
   * ApprovalAction createMany
   */
  export type ApprovalActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApprovalActions.
     */
    data: ApprovalActionCreateManyInput | ApprovalActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApprovalAction createManyAndReturn
   */
  export type ApprovalActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalAction
     */
    omit?: ApprovalActionOmit<ExtArgs> | null
    /**
     * The data used to create many ApprovalActions.
     */
    data: ApprovalActionCreateManyInput | ApprovalActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApprovalAction update
   */
  export type ApprovalActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalAction
     */
    omit?: ApprovalActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * The data needed to update a ApprovalAction.
     */
    data: XOR<ApprovalActionUpdateInput, ApprovalActionUncheckedUpdateInput>
    /**
     * Choose, which ApprovalAction to update.
     */
    where: ApprovalActionWhereUniqueInput
  }

  /**
   * ApprovalAction updateMany
   */
  export type ApprovalActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApprovalActions.
     */
    data: XOR<ApprovalActionUpdateManyMutationInput, ApprovalActionUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalActions to update
     */
    where?: ApprovalActionWhereInput
    /**
     * Limit how many ApprovalActions to update.
     */
    limit?: number
  }

  /**
   * ApprovalAction updateManyAndReturn
   */
  export type ApprovalActionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalAction
     */
    omit?: ApprovalActionOmit<ExtArgs> | null
    /**
     * The data used to update ApprovalActions.
     */
    data: XOR<ApprovalActionUpdateManyMutationInput, ApprovalActionUncheckedUpdateManyInput>
    /**
     * Filter which ApprovalActions to update
     */
    where?: ApprovalActionWhereInput
    /**
     * Limit how many ApprovalActions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApprovalAction upsert
   */
  export type ApprovalActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalAction
     */
    omit?: ApprovalActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * The filter to search for the ApprovalAction to update in case it exists.
     */
    where: ApprovalActionWhereUniqueInput
    /**
     * In case the ApprovalAction found by the `where` argument doesn't exist, create a new ApprovalAction with this data.
     */
    create: XOR<ApprovalActionCreateInput, ApprovalActionUncheckedCreateInput>
    /**
     * In case the ApprovalAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApprovalActionUpdateInput, ApprovalActionUncheckedUpdateInput>
  }

  /**
   * ApprovalAction delete
   */
  export type ApprovalActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalAction
     */
    omit?: ApprovalActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
    /**
     * Filter which ApprovalAction to delete.
     */
    where: ApprovalActionWhereUniqueInput
  }

  /**
   * ApprovalAction deleteMany
   */
  export type ApprovalActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApprovalActions to delete
     */
    where?: ApprovalActionWhereInput
    /**
     * Limit how many ApprovalActions to delete.
     */
    limit?: number
  }

  /**
   * ApprovalAction without action
   */
  export type ApprovalActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApprovalAction
     */
    select?: ApprovalActionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApprovalAction
     */
    omit?: ApprovalActionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApprovalActionInclude<ExtArgs> | null
  }


  /**
   * Model Settings
   */

  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    category: string | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    category: string | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    workspaceId: number
    category: number
    key: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingsMinAggregateInputType = {
    id?: true
    workspaceId?: true
    category?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    category?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    workspaceId?: true
    category?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to aggregate.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingsWhereInput
    orderBy?: SettingsOrderByWithAggregationInput | SettingsOrderByWithAggregationInput[]
    by: SettingsScalarFieldEnum[] | SettingsScalarFieldEnum
    having?: SettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }

  export type SettingsGroupByOutputType = {
    id: string
    workspaceId: string
    category: string
    key: string
    value: string
    createdAt: Date
    updatedAt: Date
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type SettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    category?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    category?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    category?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["settings"]>

  export type SettingsSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    category?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "category" | "key" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["settings"]>
  export type SettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type SettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type SettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $SettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Settings"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      category: string
      key: string
      value: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["settings"]>
    composites: {}
  }

  type SettingsGetPayload<S extends boolean | null | undefined | SettingsDefaultArgs> = $Result.GetResult<Prisma.$SettingsPayload, S>

  type SettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface SettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Settings'], meta: { name: 'Settings' } }
    /**
     * Find zero or one Settings that matches the filter.
     * @param {SettingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingsFindUniqueArgs>(args: SelectSubset<T, SettingsFindUniqueArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingsFindFirstArgs>(args?: SelectSubset<T, SettingsFindFirstArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingsFindManyArgs>(args?: SelectSubset<T, SettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Settings.
     * @param {SettingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
     */
    create<T extends SettingsCreateArgs>(args: SelectSubset<T, SettingsCreateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingsCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingsCreateManyArgs>(args?: SelectSubset<T, SettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingsCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const settings = await prisma.settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Settings.
     * @param {SettingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
     */
    delete<T extends SettingsDeleteArgs>(args: SelectSubset<T, SettingsDeleteArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Settings.
     * @param {SettingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingsUpdateArgs>(args: SelectSubset<T, SettingsUpdateArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingsDeleteManyArgs>(args?: SelectSubset<T, SettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingsUpdateManyArgs>(args: SelectSubset<T, SettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingsUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingsWithIdOnly = await prisma.settings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Settings.
     * @param {SettingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
     */
    upsert<T extends SettingsUpsertArgs>(args: SelectSubset<T, SettingsUpsertArgs<ExtArgs>>): Prisma__SettingsClient<$Result.GetResult<Prisma.$SettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingsCountArgs>(
      args?: Subset<T, SettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Settings model
   */
  readonly fields: SettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Settings model
   */
  interface SettingsFieldRefs {
    readonly id: FieldRef<"Settings", 'String'>
    readonly workspaceId: FieldRef<"Settings", 'String'>
    readonly category: FieldRef<"Settings", 'String'>
    readonly key: FieldRef<"Settings", 'String'>
    readonly value: FieldRef<"Settings", 'String'>
    readonly createdAt: FieldRef<"Settings", 'DateTime'>
    readonly updatedAt: FieldRef<"Settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Settings findUnique
   */
  export type SettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findUniqueOrThrow
   */
  export type SettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings findFirst
   */
  export type SettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findFirstOrThrow
   */
  export type SettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings findMany
   */
  export type SettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingsOrderByWithRelationInput | SettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingsScalarFieldEnum | SettingsScalarFieldEnum[]
  }

  /**
   * Settings create
   */
  export type SettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a Settings.
     */
    data: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
  }

  /**
   * Settings createMany
   */
  export type SettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Settings createManyAndReturn
   */
  export type SettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingsCreateManyInput | SettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Settings update
   */
  export type SettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a Settings.
     */
    data: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
    /**
     * Choose, which Settings to update.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings updateMany
   */
  export type SettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Settings updateManyAndReturn
   */
  export type SettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Settings upsert
   */
  export type SettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the Settings to update in case it exists.
     */
    where: SettingsWhereUniqueInput
    /**
     * In case the Settings found by the `where` argument doesn't exist, create a new Settings with this data.
     */
    create: XOR<SettingsCreateInput, SettingsUncheckedCreateInput>
    /**
     * In case the Settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingsUpdateInput, SettingsUncheckedUpdateInput>
  }

  /**
   * Settings delete
   */
  export type SettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
    /**
     * Filter which Settings to delete.
     */
    where: SettingsWhereUniqueInput
  }

  /**
   * Settings deleteMany
   */
  export type SettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingsWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Settings without action
   */
  export type SettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Settings
     */
    select?: SettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Settings
     */
    omit?: SettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SettingsInclude<ExtArgs> | null
  }


  /**
   * Model UserConsent
   */

  export type AggregateUserConsent = {
    _count: UserConsentCountAggregateOutputType | null
    _min: UserConsentMinAggregateOutputType | null
    _max: UserConsentMaxAggregateOutputType | null
  }

  export type UserConsentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    purpose: string | null
    consentGiven: boolean | null
    timestamp: Date | null
    ipAddress: string | null
  }

  export type UserConsentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    purpose: string | null
    consentGiven: boolean | null
    timestamp: Date | null
    ipAddress: string | null
  }

  export type UserConsentCountAggregateOutputType = {
    id: number
    userId: number
    purpose: number
    consentGiven: number
    timestamp: number
    ipAddress: number
    _all: number
  }


  export type UserConsentMinAggregateInputType = {
    id?: true
    userId?: true
    purpose?: true
    consentGiven?: true
    timestamp?: true
    ipAddress?: true
  }

  export type UserConsentMaxAggregateInputType = {
    id?: true
    userId?: true
    purpose?: true
    consentGiven?: true
    timestamp?: true
    ipAddress?: true
  }

  export type UserConsentCountAggregateInputType = {
    id?: true
    userId?: true
    purpose?: true
    consentGiven?: true
    timestamp?: true
    ipAddress?: true
    _all?: true
  }

  export type UserConsentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserConsent to aggregate.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserConsents
    **/
    _count?: true | UserConsentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserConsentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserConsentMaxAggregateInputType
  }

  export type GetUserConsentAggregateType<T extends UserConsentAggregateArgs> = {
        [P in keyof T & keyof AggregateUserConsent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserConsent[P]>
      : GetScalarType<T[P], AggregateUserConsent[P]>
  }




  export type UserConsentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserConsentWhereInput
    orderBy?: UserConsentOrderByWithAggregationInput | UserConsentOrderByWithAggregationInput[]
    by: UserConsentScalarFieldEnum[] | UserConsentScalarFieldEnum
    having?: UserConsentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserConsentCountAggregateInputType | true
    _min?: UserConsentMinAggregateInputType
    _max?: UserConsentMaxAggregateInputType
  }

  export type UserConsentGroupByOutputType = {
    id: string
    userId: string
    purpose: string
    consentGiven: boolean
    timestamp: Date
    ipAddress: string | null
    _count: UserConsentCountAggregateOutputType | null
    _min: UserConsentMinAggregateOutputType | null
    _max: UserConsentMaxAggregateOutputType | null
  }

  type GetUserConsentGroupByPayload<T extends UserConsentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserConsentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserConsentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserConsentGroupByOutputType[P]>
            : GetScalarType<T[P], UserConsentGroupByOutputType[P]>
        }
      >
    >


  export type UserConsentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    purpose?: boolean
    consentGiven?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConsent"]>

  export type UserConsentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    purpose?: boolean
    consentGiven?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConsent"]>

  export type UserConsentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    purpose?: boolean
    consentGiven?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userConsent"]>

  export type UserConsentSelectScalar = {
    id?: boolean
    userId?: boolean
    purpose?: boolean
    consentGiven?: boolean
    timestamp?: boolean
    ipAddress?: boolean
  }

  export type UserConsentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "purpose" | "consentGiven" | "timestamp" | "ipAddress", ExtArgs["result"]["userConsent"]>
  export type UserConsentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserConsentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserConsentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserConsentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserConsent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      purpose: string
      consentGiven: boolean
      timestamp: Date
      ipAddress: string | null
    }, ExtArgs["result"]["userConsent"]>
    composites: {}
  }

  type UserConsentGetPayload<S extends boolean | null | undefined | UserConsentDefaultArgs> = $Result.GetResult<Prisma.$UserConsentPayload, S>

  type UserConsentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserConsentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserConsentCountAggregateInputType | true
    }

  export interface UserConsentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserConsent'], meta: { name: 'UserConsent' } }
    /**
     * Find zero or one UserConsent that matches the filter.
     * @param {UserConsentFindUniqueArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserConsentFindUniqueArgs>(args: SelectSubset<T, UserConsentFindUniqueArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserConsent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserConsentFindUniqueOrThrowArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserConsentFindUniqueOrThrowArgs>(args: SelectSubset<T, UserConsentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserConsent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentFindFirstArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserConsentFindFirstArgs>(args?: SelectSubset<T, UserConsentFindFirstArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserConsent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentFindFirstOrThrowArgs} args - Arguments to find a UserConsent
     * @example
     * // Get one UserConsent
     * const userConsent = await prisma.userConsent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserConsentFindFirstOrThrowArgs>(args?: SelectSubset<T, UserConsentFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserConsents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserConsents
     * const userConsents = await prisma.userConsent.findMany()
     * 
     * // Get first 10 UserConsents
     * const userConsents = await prisma.userConsent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userConsentWithIdOnly = await prisma.userConsent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserConsentFindManyArgs>(args?: SelectSubset<T, UserConsentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserConsent.
     * @param {UserConsentCreateArgs} args - Arguments to create a UserConsent.
     * @example
     * // Create one UserConsent
     * const UserConsent = await prisma.userConsent.create({
     *   data: {
     *     // ... data to create a UserConsent
     *   }
     * })
     * 
     */
    create<T extends UserConsentCreateArgs>(args: SelectSubset<T, UserConsentCreateArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserConsents.
     * @param {UserConsentCreateManyArgs} args - Arguments to create many UserConsents.
     * @example
     * // Create many UserConsents
     * const userConsent = await prisma.userConsent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserConsentCreateManyArgs>(args?: SelectSubset<T, UserConsentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserConsents and returns the data saved in the database.
     * @param {UserConsentCreateManyAndReturnArgs} args - Arguments to create many UserConsents.
     * @example
     * // Create many UserConsents
     * const userConsent = await prisma.userConsent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserConsents and only return the `id`
     * const userConsentWithIdOnly = await prisma.userConsent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserConsentCreateManyAndReturnArgs>(args?: SelectSubset<T, UserConsentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserConsent.
     * @param {UserConsentDeleteArgs} args - Arguments to delete one UserConsent.
     * @example
     * // Delete one UserConsent
     * const UserConsent = await prisma.userConsent.delete({
     *   where: {
     *     // ... filter to delete one UserConsent
     *   }
     * })
     * 
     */
    delete<T extends UserConsentDeleteArgs>(args: SelectSubset<T, UserConsentDeleteArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserConsent.
     * @param {UserConsentUpdateArgs} args - Arguments to update one UserConsent.
     * @example
     * // Update one UserConsent
     * const userConsent = await prisma.userConsent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserConsentUpdateArgs>(args: SelectSubset<T, UserConsentUpdateArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserConsents.
     * @param {UserConsentDeleteManyArgs} args - Arguments to filter UserConsents to delete.
     * @example
     * // Delete a few UserConsents
     * const { count } = await prisma.userConsent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserConsentDeleteManyArgs>(args?: SelectSubset<T, UserConsentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserConsents
     * const userConsent = await prisma.userConsent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserConsentUpdateManyArgs>(args: SelectSubset<T, UserConsentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserConsents and returns the data updated in the database.
     * @param {UserConsentUpdateManyAndReturnArgs} args - Arguments to update many UserConsents.
     * @example
     * // Update many UserConsents
     * const userConsent = await prisma.userConsent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserConsents and only return the `id`
     * const userConsentWithIdOnly = await prisma.userConsent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserConsentUpdateManyAndReturnArgs>(args: SelectSubset<T, UserConsentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserConsent.
     * @param {UserConsentUpsertArgs} args - Arguments to update or create a UserConsent.
     * @example
     * // Update or create a UserConsent
     * const userConsent = await prisma.userConsent.upsert({
     *   create: {
     *     // ... data to create a UserConsent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserConsent we want to update
     *   }
     * })
     */
    upsert<T extends UserConsentUpsertArgs>(args: SelectSubset<T, UserConsentUpsertArgs<ExtArgs>>): Prisma__UserConsentClient<$Result.GetResult<Prisma.$UserConsentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserConsents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentCountArgs} args - Arguments to filter UserConsents to count.
     * @example
     * // Count the number of UserConsents
     * const count = await prisma.userConsent.count({
     *   where: {
     *     // ... the filter for the UserConsents we want to count
     *   }
     * })
    **/
    count<T extends UserConsentCountArgs>(
      args?: Subset<T, UserConsentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserConsentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserConsentAggregateArgs>(args: Subset<T, UserConsentAggregateArgs>): Prisma.PrismaPromise<GetUserConsentAggregateType<T>>

    /**
     * Group by UserConsent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserConsentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserConsentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserConsentGroupByArgs['orderBy'] }
        : { orderBy?: UserConsentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserConsentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserConsentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserConsent model
   */
  readonly fields: UserConsentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserConsent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserConsentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserConsent model
   */
  interface UserConsentFieldRefs {
    readonly id: FieldRef<"UserConsent", 'String'>
    readonly userId: FieldRef<"UserConsent", 'String'>
    readonly purpose: FieldRef<"UserConsent", 'String'>
    readonly consentGiven: FieldRef<"UserConsent", 'Boolean'>
    readonly timestamp: FieldRef<"UserConsent", 'DateTime'>
    readonly ipAddress: FieldRef<"UserConsent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserConsent findUnique
   */
  export type UserConsentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent findUniqueOrThrow
   */
  export type UserConsentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent findFirst
   */
  export type UserConsentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserConsents.
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserConsents.
     */
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * UserConsent findFirstOrThrow
   */
  export type UserConsentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsent to fetch.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserConsents.
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserConsents.
     */
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * UserConsent findMany
   */
  export type UserConsentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter, which UserConsents to fetch.
     */
    where?: UserConsentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserConsents to fetch.
     */
    orderBy?: UserConsentOrderByWithRelationInput | UserConsentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserConsents.
     */
    cursor?: UserConsentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserConsents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserConsents.
     */
    skip?: number
    distinct?: UserConsentScalarFieldEnum | UserConsentScalarFieldEnum[]
  }

  /**
   * UserConsent create
   */
  export type UserConsentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * The data needed to create a UserConsent.
     */
    data: XOR<UserConsentCreateInput, UserConsentUncheckedCreateInput>
  }

  /**
   * UserConsent createMany
   */
  export type UserConsentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserConsents.
     */
    data: UserConsentCreateManyInput | UserConsentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserConsent createManyAndReturn
   */
  export type UserConsentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * The data used to create many UserConsents.
     */
    data: UserConsentCreateManyInput | UserConsentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserConsent update
   */
  export type UserConsentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * The data needed to update a UserConsent.
     */
    data: XOR<UserConsentUpdateInput, UserConsentUncheckedUpdateInput>
    /**
     * Choose, which UserConsent to update.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent updateMany
   */
  export type UserConsentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserConsents.
     */
    data: XOR<UserConsentUpdateManyMutationInput, UserConsentUncheckedUpdateManyInput>
    /**
     * Filter which UserConsents to update
     */
    where?: UserConsentWhereInput
    /**
     * Limit how many UserConsents to update.
     */
    limit?: number
  }

  /**
   * UserConsent updateManyAndReturn
   */
  export type UserConsentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * The data used to update UserConsents.
     */
    data: XOR<UserConsentUpdateManyMutationInput, UserConsentUncheckedUpdateManyInput>
    /**
     * Filter which UserConsents to update
     */
    where?: UserConsentWhereInput
    /**
     * Limit how many UserConsents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserConsent upsert
   */
  export type UserConsentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * The filter to search for the UserConsent to update in case it exists.
     */
    where: UserConsentWhereUniqueInput
    /**
     * In case the UserConsent found by the `where` argument doesn't exist, create a new UserConsent with this data.
     */
    create: XOR<UserConsentCreateInput, UserConsentUncheckedCreateInput>
    /**
     * In case the UserConsent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserConsentUpdateInput, UserConsentUncheckedUpdateInput>
  }

  /**
   * UserConsent delete
   */
  export type UserConsentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
    /**
     * Filter which UserConsent to delete.
     */
    where: UserConsentWhereUniqueInput
  }

  /**
   * UserConsent deleteMany
   */
  export type UserConsentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserConsents to delete
     */
    where?: UserConsentWhereInput
    /**
     * Limit how many UserConsents to delete.
     */
    limit?: number
  }

  /**
   * UserConsent without action
   */
  export type UserConsentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserConsent
     */
    select?: UserConsentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserConsent
     */
    omit?: UserConsentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserConsentInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    details: string | null
    createdAt: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    details: string | null
    createdAt: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entity: number
    entityId: number
    details: number
    createdAt: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    details?: true
    createdAt?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    details?: true
    createdAt?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    entity: string
    entityId: string
    details: string | null
    createdAt: Date
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entity" | "entityId" | "details" | "createdAt", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entity: string
      entityId: string
      details: string | null
      createdAt: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly userId: FieldRef<"ActivityLog", 'String'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly entity: FieldRef<"ActivityLog", 'String'>
    readonly entityId: FieldRef<"ActivityLog", 'String'>
    readonly details: FieldRef<"ActivityLog", 'String'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    userId: string | null
    action: string | null
    resource: string | null
    resourceId: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    workspaceId: number
    userId: number
    action: number
    resource: number
    resourceId: number
    details: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    workspaceId?: true
    userId?: true
    action?: true
    resource?: true
    resourceId?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    workspaceId: string
    userId: string
    action: string
    resource: string
    resourceId: string | null
    details: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    resourceId?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "userId" | "action" | "resource" | "resourceId" | "details" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      userId: string
      action: string
      resource: string
      resourceId: string | null
      details: string | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly workspaceId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly resourceId: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Invitation
   */

  export type AggregateInvitation = {
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  export type InvitationMinAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    email: string | null
    code: string | null
    type: $Enums.InvitationType | null
    status: $Enums.InvitationStatus | null
    data: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvitationMaxAggregateOutputType = {
    id: string | null
    workspaceId: string | null
    email: string | null
    code: string | null
    type: $Enums.InvitationType | null
    status: $Enums.InvitationStatus | null
    data: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvitationCountAggregateOutputType = {
    id: number
    workspaceId: number
    email: number
    code: number
    type: number
    status: number
    data: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvitationMinAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    code?: true
    type?: true
    status?: true
    data?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvitationMaxAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    code?: true
    type?: true
    status?: true
    data?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvitationCountAggregateInputType = {
    id?: true
    workspaceId?: true
    email?: true
    code?: true
    type?: true
    status?: true
    data?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitation to aggregate.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invitations
    **/
    _count?: true | InvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationMaxAggregateInputType
  }

  export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitation[P]>
      : GetScalarType<T[P], AggregateInvitation[P]>
  }




  export type InvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithAggregationInput | InvitationOrderByWithAggregationInput[]
    by: InvitationScalarFieldEnum[] | InvitationScalarFieldEnum
    having?: InvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationCountAggregateInputType | true
    _min?: InvitationMinAggregateInputType
    _max?: InvitationMaxAggregateInputType
  }

  export type InvitationGroupByOutputType = {
    id: string
    workspaceId: string
    email: string
    code: string
    type: $Enums.InvitationType
    status: $Enums.InvitationStatus
    data: string | null
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: InvitationCountAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  type GetInvitationGroupByPayload<T extends InvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationGroupByOutputType[P]>
        }
      >
    >


  export type InvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    code?: boolean
    type?: boolean
    status?: boolean
    data?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    code?: boolean
    type?: boolean
    status?: boolean
    data?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    code?: boolean
    type?: boolean
    status?: boolean
    data?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectScalar = {
    id?: boolean
    workspaceId?: boolean
    email?: boolean
    code?: boolean
    type?: boolean
    status?: boolean
    data?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "workspaceId" | "email" | "code" | "type" | "status" | "data" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["invitation"]>
  export type InvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type InvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type InvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $InvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invitation"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      workspaceId: string
      email: string
      code: string
      type: $Enums.InvitationType
      status: $Enums.InvitationStatus
      data: string | null
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invitation"]>
    composites: {}
  }

  type InvitationGetPayload<S extends boolean | null | undefined | InvitationDefaultArgs> = $Result.GetResult<Prisma.$InvitationPayload, S>

  type InvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationCountAggregateInputType | true
    }

  export interface InvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invitation'], meta: { name: 'Invitation' } }
    /**
     * Find zero or one Invitation that matches the filter.
     * @param {InvitationFindUniqueArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationFindUniqueArgs>(args: SelectSubset<T, InvitationFindUniqueArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvitationFindUniqueOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationFindFirstArgs>(args?: SelectSubset<T, InvitationFindFirstArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitation.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invitationWithIdOnly = await prisma.invitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvitationFindManyArgs>(args?: SelectSubset<T, InvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invitation.
     * @param {InvitationCreateArgs} args - Arguments to create a Invitation.
     * @example
     * // Create one Invitation
     * const Invitation = await prisma.invitation.create({
     *   data: {
     *     // ... data to create a Invitation
     *   }
     * })
     * 
     */
    create<T extends InvitationCreateArgs>(args: SelectSubset<T, InvitationCreateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invitations.
     * @param {InvitationCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationCreateManyArgs>(args?: SelectSubset<T, InvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {InvitationCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invitation.
     * @param {InvitationDeleteArgs} args - Arguments to delete one Invitation.
     * @example
     * // Delete one Invitation
     * const Invitation = await prisma.invitation.delete({
     *   where: {
     *     // ... filter to delete one Invitation
     *   }
     * })
     * 
     */
    delete<T extends InvitationDeleteArgs>(args: SelectSubset<T, InvitationDeleteArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invitation.
     * @param {InvitationUpdateArgs} args - Arguments to update one Invitation.
     * @example
     * // Update one Invitation
     * const invitation = await prisma.invitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationUpdateArgs>(args: SelectSubset<T, InvitationUpdateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invitations.
     * @param {InvitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationDeleteManyArgs>(args?: SelectSubset<T, InvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationUpdateManyArgs>(args: SelectSubset<T, InvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations and returns the data updated in the database.
     * @param {InvitationUpdateManyAndReturnArgs} args - Arguments to update many Invitations.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invitations and only return the `id`
     * const invitationWithIdOnly = await prisma.invitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, InvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invitation.
     * @param {InvitationUpsertArgs} args - Arguments to update or create a Invitation.
     * @example
     * // Update or create a Invitation
     * const invitation = await prisma.invitation.upsert({
     *   create: {
     *     // ... data to create a Invitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitation we want to update
     *   }
     * })
     */
    upsert<T extends InvitationUpsertArgs>(args: SelectSubset<T, InvitationUpsertArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitation.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends InvitationCountArgs>(
      args?: Subset<T, InvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationAggregateArgs>(args: Subset<T, InvitationAggregateArgs>): Prisma.PrismaPromise<GetInvitationAggregateType<T>>

    /**
     * Group by Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationGroupByArgs['orderBy'] }
        : { orderBy?: InvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invitation model
   */
  readonly fields: InvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invitation model
   */
  interface InvitationFieldRefs {
    readonly id: FieldRef<"Invitation", 'String'>
    readonly workspaceId: FieldRef<"Invitation", 'String'>
    readonly email: FieldRef<"Invitation", 'String'>
    readonly code: FieldRef<"Invitation", 'String'>
    readonly type: FieldRef<"Invitation", 'InvitationType'>
    readonly status: FieldRef<"Invitation", 'InvitationStatus'>
    readonly data: FieldRef<"Invitation", 'String'>
    readonly expiresAt: FieldRef<"Invitation", 'DateTime'>
    readonly createdAt: FieldRef<"Invitation", 'DateTime'>
    readonly updatedAt: FieldRef<"Invitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invitation findUnique
   */
  export type InvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findUniqueOrThrow
   */
  export type InvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findFirst
   */
  export type InvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findFirstOrThrow
   */
  export type InvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findMany
   */
  export type InvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation create
   */
  export type InvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a Invitation.
     */
    data: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
  }

  /**
   * Invitation createMany
   */
  export type InvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invitation createManyAndReturn
   */
  export type InvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation update
   */
  export type InvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a Invitation.
     */
    data: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
    /**
     * Choose, which Invitation to update.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation updateMany
   */
  export type InvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
  }

  /**
   * Invitation updateManyAndReturn
   */
  export type InvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation upsert
   */
  export type InvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the Invitation to update in case it exists.
     */
    where: InvitationWhereUniqueInput
    /**
     * In case the Invitation found by the `where` argument doesn't exist, create a new Invitation with this data.
     */
    create: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
    /**
     * In case the Invitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
  }

  /**
   * Invitation delete
   */
  export type InvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter which Invitation to delete.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation deleteMany
   */
  export type InvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitations to delete
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to delete.
     */
    limit?: number
  }

  /**
   * Invitation without action
   */
  export type InvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    password: 'password',
    image: 'image',
    role: 'role',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLogin: 'lastLogin'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WorkspaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    logo: 'logo',
    address: 'address',
    taxId: 'taxId',
    phone: 'phone',
    email: 'email',
    contactPerson: 'contactPerson',
    status: 'status',
    planType: 'planType',
    subscriptionStart: 'subscriptionStart',
    subscriptionEnd: 'subscriptionEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceScalarFieldEnum = (typeof WorkspaceScalarFieldEnum)[keyof typeof WorkspaceScalarFieldEnum]


  export const WorkspaceMemberScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    userId: 'userId',
    role: 'role',
    joinedAt: 'joinedAt',
    invitedBy: 'invitedBy',
    status: 'status'
  };

  export type WorkspaceMemberScalarFieldEnum = (typeof WorkspaceMemberScalarFieldEnum)[keyof typeof WorkspaceMemberScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    code: 'code',
    description: 'description',
    managerId: 'managerId',
    parentId: 'parentId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    departmentId: 'departmentId',
    name: 'name',
    description: 'description',
    leaderId: 'leaderId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const PositionScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    code: 'code',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PositionScalarFieldEnum = (typeof PositionScalarFieldEnum)[keyof typeof PositionScalarFieldEnum]


  export const PositionLevelScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    level: 'level',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PositionLevelScalarFieldEnum = (typeof PositionLevelScalarFieldEnum)[keyof typeof PositionLevelScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    userId: 'userId',
    employeeCode: 'employeeCode',
    firstName: 'firstName',
    lastName: 'lastName',
    thaiFirstName: 'thaiFirstName',
    thaiLastName: 'thaiLastName',
    nickname: 'nickname',
    email: 'email',
    phone: 'phone',
    emergencyContact: 'emergencyContact',
    birthdate: 'birthdate',
    gender: 'gender',
    nationalId: 'nationalId',
    nationalIdIv: 'nationalIdIv',
    passportNumber: 'passportNumber',
    passportNumberIv: 'passportNumberIv',
    address: 'address',
    taxId: 'taxId',
    bankAccount: 'bankAccount',
    bankAccountIv: 'bankAccountIv',
    bankName: 'bankName',
    hireDate: 'hireDate',
    probationEndDate: 'probationEndDate',
    resignDate: 'resignDate',
    departmentId: 'departmentId',
    teamId: 'teamId',
    positionId: 'positionId',
    positionLevelId: 'positionLevelId',
    managerId: 'managerId',
    status: 'status',
    employmentType: 'employmentType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const EmploymentHistoryScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    positionId: 'positionId',
    positionLevelId: 'positionLevelId',
    departmentId: 'departmentId',
    startDate: 'startDate',
    endDate: 'endDate',
    salary: 'salary',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmploymentHistoryScalarFieldEnum = (typeof EmploymentHistoryScalarFieldEnum)[keyof typeof EmploymentHistoryScalarFieldEnum]


  export const EmployeeDocumentScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    type: 'type',
    name: 'name',
    filename: 'filename',
    mimeType: 'mimeType',
    size: 'size',
    url: 'url',
    uploadedBy: 'uploadedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeDocumentScalarFieldEnum = (typeof EmployeeDocumentScalarFieldEnum)[keyof typeof EmployeeDocumentScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    code: 'code',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    budget: 'budget',
    status: 'status',
    priority: 'priority',
    managerId: 'managerId',
    clientName: 'clientName',
    clientContact: 'clientContact',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectMemberScalarFieldEnum: {
    id: 'id',
    projectId: 'projectId',
    employeeId: 'employeeId',
    roleId: 'roleId',
    allocation: 'allocation',
    startDate: 'startDate',
    endDate: 'endDate'
  };

  export type ProjectMemberScalarFieldEnum = (typeof ProjectMemberScalarFieldEnum)[keyof typeof ProjectMemberScalarFieldEnum]


  export const ProjectRoleScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectRoleScalarFieldEnum = (typeof ProjectRoleScalarFieldEnum)[keyof typeof ProjectRoleScalarFieldEnum]


  export const LeaveTypeScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    code: 'code',
    description: 'description',
    color: 'color',
    isPaid: 'isPaid',
    requiresApproval: 'requiresApproval',
    requiresAttachment: 'requiresAttachment',
    maxDaysPerYear: 'maxDaysPerYear',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveTypeScalarFieldEnum = (typeof LeaveTypeScalarFieldEnum)[keyof typeof LeaveTypeScalarFieldEnum]


  export const LeaveQuotaScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    employeeId: 'employeeId',
    leaveTypeId: 'leaveTypeId',
    year: 'year',
    total: 'total',
    used: 'used',
    pending: 'pending',
    remaining: 'remaining',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveQuotaScalarFieldEnum = (typeof LeaveQuotaScalarFieldEnum)[keyof typeof LeaveQuotaScalarFieldEnum]


  export const LeaveScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    employeeId: 'employeeId',
    leaveTypeId: 'leaveTypeId',
    startDate: 'startDate',
    endDate: 'endDate',
    halfDay: 'halfDay',
    duration: 'duration',
    reason: 'reason',
    attachment: 'attachment',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveScalarFieldEnum = (typeof LeaveScalarFieldEnum)[keyof typeof LeaveScalarFieldEnum]


  export const OvertimePolicyScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    rate: 'rate',
    minimumHours: 'minimumHours',
    maximumHours: 'maximumHours',
    requiresApproval: 'requiresApproval',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OvertimePolicyScalarFieldEnum = (typeof OvertimePolicyScalarFieldEnum)[keyof typeof OvertimePolicyScalarFieldEnum]


  export const OvertimeScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    employeeId: 'employeeId',
    policyId: 'policyId',
    date: 'date',
    startTime: 'startTime',
    endTime: 'endTime',
    hours: 'hours',
    reason: 'reason',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OvertimeScalarFieldEnum = (typeof OvertimeScalarFieldEnum)[keyof typeof OvertimeScalarFieldEnum]


  export const ApprovalTemplateScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    name: 'name',
    description: 'description',
    entityType: 'entityType',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApprovalTemplateScalarFieldEnum = (typeof ApprovalTemplateScalarFieldEnum)[keyof typeof ApprovalTemplateScalarFieldEnum]


  export const ApprovalStepScalarFieldEnum: {
    id: 'id',
    approvalTemplateId: 'approvalTemplateId',
    stepNumber: 'stepNumber',
    approverType: 'approverType',
    approverId: 'approverId',
    backup1Id: 'backup1Id',
    backup2Id: 'backup2Id',
    timeLimit: 'timeLimit'
  };

  export type ApprovalStepScalarFieldEnum = (typeof ApprovalStepScalarFieldEnum)[keyof typeof ApprovalStepScalarFieldEnum]


  export const ApprovalScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    templateId: 'templateId',
    entityType: 'entityType',
    entityId: 'entityId',
    requesterId: 'requesterId',
    currentStep: 'currentStep',
    status: 'status',
    leaveId: 'leaveId',
    overtimeId: 'overtimeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApprovalScalarFieldEnum = (typeof ApprovalScalarFieldEnum)[keyof typeof ApprovalScalarFieldEnum]


  export const ApprovalActionScalarFieldEnum: {
    id: 'id',
    approvalId: 'approvalId',
    userId: 'userId',
    step: 'step',
    action: 'action',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type ApprovalActionScalarFieldEnum = (typeof ApprovalActionScalarFieldEnum)[keyof typeof ApprovalActionScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    category: 'category',
    key: 'key',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const UserConsentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    purpose: 'purpose',
    consentGiven: 'consentGiven',
    timestamp: 'timestamp',
    ipAddress: 'ipAddress'
  };

  export type UserConsentScalarFieldEnum = (typeof UserConsentScalarFieldEnum)[keyof typeof UserConsentScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    resourceId: 'resourceId',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const InvitationScalarFieldEnum: {
    id: 'id',
    workspaceId: 'workspaceId',
    email: 'email',
    code: 'code',
    type: 'type',
    status: 'status',
    data: 'data',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'WorkspaceStatus'
   */
  export type EnumWorkspaceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkspaceStatus'>
    


  /**
   * Reference to a field of type 'WorkspaceStatus[]'
   */
  export type ListEnumWorkspaceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WorkspaceStatus[]'>
    


  /**
   * Reference to a field of type 'PlanType'
   */
  export type EnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType'>
    


  /**
   * Reference to a field of type 'PlanType[]'
   */
  export type ListEnumPlanTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlanType[]'>
    


  /**
   * Reference to a field of type 'MemberRole'
   */
  export type EnumMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberRole'>
    


  /**
   * Reference to a field of type 'MemberRole[]'
   */
  export type ListEnumMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberRole[]'>
    


  /**
   * Reference to a field of type 'MemberStatus'
   */
  export type EnumMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberStatus'>
    


  /**
   * Reference to a field of type 'MemberStatus[]'
   */
  export type ListEnumMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberStatus[]'>
    


  /**
   * Reference to a field of type 'EmployeeStatus'
   */
  export type EnumEmployeeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeStatus'>
    


  /**
   * Reference to a field of type 'EmployeeStatus[]'
   */
  export type ListEnumEmployeeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmployeeStatus[]'>
    


  /**
   * Reference to a field of type 'EmploymentType'
   */
  export type EnumEmploymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmploymentType'>
    


  /**
   * Reference to a field of type 'EmploymentType[]'
   */
  export type ListEnumEmploymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmploymentType[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'ProjectPriority'
   */
  export type EnumProjectPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectPriority'>
    


  /**
   * Reference to a field of type 'ProjectPriority[]'
   */
  export type ListEnumProjectPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectPriority[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'LeaveStatus'
   */
  export type EnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus'>
    


  /**
   * Reference to a field of type 'LeaveStatus[]'
   */
  export type ListEnumLeaveStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeaveStatus[]'>
    


  /**
   * Reference to a field of type 'OvertimeStatus'
   */
  export type EnumOvertimeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OvertimeStatus'>
    


  /**
   * Reference to a field of type 'OvertimeStatus[]'
   */
  export type ListEnumOvertimeStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OvertimeStatus[]'>
    


  /**
   * Reference to a field of type 'ApproverType'
   */
  export type EnumApproverTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApproverType'>
    


  /**
   * Reference to a field of type 'ApproverType[]'
   */
  export type ListEnumApproverTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApproverType[]'>
    


  /**
   * Reference to a field of type 'ApprovalStatus'
   */
  export type EnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus'>
    


  /**
   * Reference to a field of type 'ApprovalStatus[]'
   */
  export type ListEnumApprovalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApprovalStatus[]'>
    


  /**
   * Reference to a field of type 'InvitationType'
   */
  export type EnumInvitationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationType'>
    


  /**
   * Reference to a field of type 'InvitationType[]'
   */
  export type ListEnumInvitationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationType[]'>
    


  /**
   * Reference to a field of type 'InvitationStatus'
   */
  export type EnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus'>
    


  /**
   * Reference to a field of type 'InvitationStatus[]'
   */
  export type ListEnumInvitationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvitationStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    activityLogs?: ActivityLogListRelationFilter
    workspaceMember?: WorkspaceMemberListRelationFilter
    approvalActions?: ApprovalActionListRelationFilter
    consents?: UserConsentListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    employee?: EmployeeOrderByWithRelationInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    workspaceMember?: WorkspaceMemberOrderByRelationAggregateInput
    approvalActions?: ApprovalActionOrderByRelationAggregateInput
    consents?: UserConsentOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    password?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    activityLogs?: ActivityLogListRelationFilter
    workspaceMember?: WorkspaceMemberListRelationFilter
    approvalActions?: ApprovalActionListRelationFilter
    consents?: UserConsentListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type WorkspaceWhereInput = {
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    id?: StringFilter<"Workspace"> | string
    name?: StringFilter<"Workspace"> | string
    slug?: StringFilter<"Workspace"> | string
    logo?: StringNullableFilter<"Workspace"> | string | null
    address?: StringNullableFilter<"Workspace"> | string | null
    taxId?: StringNullableFilter<"Workspace"> | string | null
    phone?: StringNullableFilter<"Workspace"> | string | null
    email?: StringNullableFilter<"Workspace"> | string | null
    contactPerson?: StringNullableFilter<"Workspace"> | string | null
    status?: EnumWorkspaceStatusFilter<"Workspace"> | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFilter<"Workspace"> | $Enums.PlanType
    subscriptionStart?: DateTimeNullableFilter<"Workspace"> | Date | string | null
    subscriptionEnd?: DateTimeNullableFilter<"Workspace"> | Date | string | null
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    members?: WorkspaceMemberListRelationFilter
    departments?: DepartmentListRelationFilter
    teams?: TeamListRelationFilter
    positions?: PositionListRelationFilter
    positionLevels?: PositionLevelListRelationFilter
    employees?: EmployeeListRelationFilter
    projects?: ProjectListRelationFilter
    projectRoles?: ProjectRoleListRelationFilter
    leaveTypes?: LeaveTypeListRelationFilter
    leaveQuotas?: LeaveQuotaListRelationFilter
    leaves?: LeaveListRelationFilter
    overtimePolicies?: OvertimePolicyListRelationFilter
    overtimes?: OvertimeListRelationFilter
    approvalTemplates?: ApprovalTemplateListRelationFilter
    approvals?: ApprovalListRelationFilter
    settings?: SettingsListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    invitations?: InvitationListRelationFilter
  }

  export type WorkspaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    status?: SortOrder
    planType?: SortOrder
    subscriptionStart?: SortOrderInput | SortOrder
    subscriptionEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    members?: WorkspaceMemberOrderByRelationAggregateInput
    departments?: DepartmentOrderByRelationAggregateInput
    teams?: TeamOrderByRelationAggregateInput
    positions?: PositionOrderByRelationAggregateInput
    positionLevels?: PositionLevelOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
    projects?: ProjectOrderByRelationAggregateInput
    projectRoles?: ProjectRoleOrderByRelationAggregateInput
    leaveTypes?: LeaveTypeOrderByRelationAggregateInput
    leaveQuotas?: LeaveQuotaOrderByRelationAggregateInput
    leaves?: LeaveOrderByRelationAggregateInput
    overtimePolicies?: OvertimePolicyOrderByRelationAggregateInput
    overtimes?: OvertimeOrderByRelationAggregateInput
    approvalTemplates?: ApprovalTemplateOrderByRelationAggregateInput
    approvals?: ApprovalOrderByRelationAggregateInput
    settings?: SettingsOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    invitations?: InvitationOrderByRelationAggregateInput
  }

  export type WorkspaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    name?: StringFilter<"Workspace"> | string
    logo?: StringNullableFilter<"Workspace"> | string | null
    address?: StringNullableFilter<"Workspace"> | string | null
    taxId?: StringNullableFilter<"Workspace"> | string | null
    phone?: StringNullableFilter<"Workspace"> | string | null
    email?: StringNullableFilter<"Workspace"> | string | null
    contactPerson?: StringNullableFilter<"Workspace"> | string | null
    status?: EnumWorkspaceStatusFilter<"Workspace"> | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFilter<"Workspace"> | $Enums.PlanType
    subscriptionStart?: DateTimeNullableFilter<"Workspace"> | Date | string | null
    subscriptionEnd?: DateTimeNullableFilter<"Workspace"> | Date | string | null
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    members?: WorkspaceMemberListRelationFilter
    departments?: DepartmentListRelationFilter
    teams?: TeamListRelationFilter
    positions?: PositionListRelationFilter
    positionLevels?: PositionLevelListRelationFilter
    employees?: EmployeeListRelationFilter
    projects?: ProjectListRelationFilter
    projectRoles?: ProjectRoleListRelationFilter
    leaveTypes?: LeaveTypeListRelationFilter
    leaveQuotas?: LeaveQuotaListRelationFilter
    leaves?: LeaveListRelationFilter
    overtimePolicies?: OvertimePolicyListRelationFilter
    overtimes?: OvertimeListRelationFilter
    approvalTemplates?: ApprovalTemplateListRelationFilter
    approvals?: ApprovalListRelationFilter
    settings?: SettingsListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    invitations?: InvitationListRelationFilter
  }, "id" | "slug">

  export type WorkspaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    contactPerson?: SortOrderInput | SortOrder
    status?: SortOrder
    planType?: SortOrder
    subscriptionStart?: SortOrderInput | SortOrder
    subscriptionEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkspaceCountOrderByAggregateInput
    _max?: WorkspaceMaxOrderByAggregateInput
    _min?: WorkspaceMinOrderByAggregateInput
  }

  export type WorkspaceScalarWhereWithAggregatesInput = {
    AND?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    OR?: WorkspaceScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workspace"> | string
    name?: StringWithAggregatesFilter<"Workspace"> | string
    slug?: StringWithAggregatesFilter<"Workspace"> | string
    logo?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    address?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    email?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    contactPerson?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    status?: EnumWorkspaceStatusWithAggregatesFilter<"Workspace"> | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeWithAggregatesFilter<"Workspace"> | $Enums.PlanType
    subscriptionStart?: DateTimeNullableWithAggregatesFilter<"Workspace"> | Date | string | null
    subscriptionEnd?: DateTimeNullableWithAggregatesFilter<"Workspace"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
  }

  export type WorkspaceMemberWhereInput = {
    AND?: WorkspaceMemberWhereInput | WorkspaceMemberWhereInput[]
    OR?: WorkspaceMemberWhereInput[]
    NOT?: WorkspaceMemberWhereInput | WorkspaceMemberWhereInput[]
    id?: StringFilter<"WorkspaceMember"> | string
    workspaceId?: StringFilter<"WorkspaceMember"> | string
    userId?: StringFilter<"WorkspaceMember"> | string
    role?: EnumMemberRoleFilter<"WorkspaceMember"> | $Enums.MemberRole
    joinedAt?: DateTimeFilter<"WorkspaceMember"> | Date | string
    invitedBy?: StringNullableFilter<"WorkspaceMember"> | string | null
    status?: EnumMemberStatusFilter<"WorkspaceMember"> | $Enums.MemberStatus
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type WorkspaceMemberOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type WorkspaceMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_userId?: WorkspaceMemberWorkspaceIdUserIdCompoundUniqueInput
    AND?: WorkspaceMemberWhereInput | WorkspaceMemberWhereInput[]
    OR?: WorkspaceMemberWhereInput[]
    NOT?: WorkspaceMemberWhereInput | WorkspaceMemberWhereInput[]
    workspaceId?: StringFilter<"WorkspaceMember"> | string
    userId?: StringFilter<"WorkspaceMember"> | string
    role?: EnumMemberRoleFilter<"WorkspaceMember"> | $Enums.MemberRole
    joinedAt?: DateTimeFilter<"WorkspaceMember"> | Date | string
    invitedBy?: StringNullableFilter<"WorkspaceMember"> | string | null
    status?: EnumMemberStatusFilter<"WorkspaceMember"> | $Enums.MemberStatus
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "workspaceId_userId">

  export type WorkspaceMemberOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: WorkspaceMemberCountOrderByAggregateInput
    _max?: WorkspaceMemberMaxOrderByAggregateInput
    _min?: WorkspaceMemberMinOrderByAggregateInput
  }

  export type WorkspaceMemberScalarWhereWithAggregatesInput = {
    AND?: WorkspaceMemberScalarWhereWithAggregatesInput | WorkspaceMemberScalarWhereWithAggregatesInput[]
    OR?: WorkspaceMemberScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceMemberScalarWhereWithAggregatesInput | WorkspaceMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkspaceMember"> | string
    workspaceId?: StringWithAggregatesFilter<"WorkspaceMember"> | string
    userId?: StringWithAggregatesFilter<"WorkspaceMember"> | string
    role?: EnumMemberRoleWithAggregatesFilter<"WorkspaceMember"> | $Enums.MemberRole
    joinedAt?: DateTimeWithAggregatesFilter<"WorkspaceMember"> | Date | string
    invitedBy?: StringNullableWithAggregatesFilter<"WorkspaceMember"> | string | null
    status?: EnumMemberStatusWithAggregatesFilter<"WorkspaceMember"> | $Enums.MemberStatus
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    workspaceId?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    code?: StringNullableFilter<"Department"> | string | null
    description?: StringNullableFilter<"Department"> | string | null
    managerId?: StringNullableFilter<"Department"> | string | null
    parentId?: StringNullableFilter<"Department"> | string | null
    status?: StringFilter<"Department"> | string
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    teams?: TeamListRelationFilter
    employees?: EmployeeListRelationFilter
    parent?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    children?: DepartmentListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    teams?: TeamOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
    parent?: DepartmentOrderByWithRelationInput
    children?: DepartmentOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_code?: DepartmentWorkspaceIdCodeCompoundUniqueInput
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    workspaceId?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    code?: StringNullableFilter<"Department"> | string | null
    description?: StringNullableFilter<"Department"> | string | null
    managerId?: StringNullableFilter<"Department"> | string | null
    parentId?: StringNullableFilter<"Department"> | string | null
    status?: StringFilter<"Department"> | string
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    teams?: TeamListRelationFilter
    employees?: EmployeeListRelationFilter
    parent?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    children?: DepartmentListRelationFilter
  }, "id" | "workspaceId_code">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    workspaceId?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    code?: StringNullableWithAggregatesFilter<"Department"> | string | null
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"Department"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"Department"> | string | null
    status?: StringWithAggregatesFilter<"Department"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    workspaceId?: StringFilter<"Team"> | string
    departmentId?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    leaderId?: StringNullableFilter<"Team"> | string | null
    status?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    employees?: EmployeeListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    departmentId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    leaderId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    employees?: EmployeeOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_departmentId_name?: TeamWorkspaceIdDepartmentIdNameCompoundUniqueInput
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    workspaceId?: StringFilter<"Team"> | string
    departmentId?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    leaderId?: StringNullableFilter<"Team"> | string | null
    status?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    department?: XOR<DepartmentScalarRelationFilter, DepartmentWhereInput>
    employees?: EmployeeListRelationFilter
  }, "id" | "workspaceId_departmentId_name">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    departmentId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    leaderId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    workspaceId?: StringWithAggregatesFilter<"Team"> | string
    departmentId?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
    description?: StringNullableWithAggregatesFilter<"Team"> | string | null
    leaderId?: StringNullableWithAggregatesFilter<"Team"> | string | null
    status?: StringWithAggregatesFilter<"Team"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type PositionWhereInput = {
    AND?: PositionWhereInput | PositionWhereInput[]
    OR?: PositionWhereInput[]
    NOT?: PositionWhereInput | PositionWhereInput[]
    id?: StringFilter<"Position"> | string
    workspaceId?: StringFilter<"Position"> | string
    name?: StringFilter<"Position"> | string
    code?: StringNullableFilter<"Position"> | string | null
    description?: StringNullableFilter<"Position"> | string | null
    status?: StringFilter<"Position"> | string
    createdAt?: DateTimeFilter<"Position"> | Date | string
    updatedAt?: DateTimeFilter<"Position"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    employees?: EmployeeListRelationFilter
    employmentHistory?: EmploymentHistoryListRelationFilter
  }

  export type PositionOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    employees?: EmployeeOrderByRelationAggregateInput
    employmentHistory?: EmploymentHistoryOrderByRelationAggregateInput
  }

  export type PositionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_code?: PositionWorkspaceIdCodeCompoundUniqueInput
    AND?: PositionWhereInput | PositionWhereInput[]
    OR?: PositionWhereInput[]
    NOT?: PositionWhereInput | PositionWhereInput[]
    workspaceId?: StringFilter<"Position"> | string
    name?: StringFilter<"Position"> | string
    code?: StringNullableFilter<"Position"> | string | null
    description?: StringNullableFilter<"Position"> | string | null
    status?: StringFilter<"Position"> | string
    createdAt?: DateTimeFilter<"Position"> | Date | string
    updatedAt?: DateTimeFilter<"Position"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    employees?: EmployeeListRelationFilter
    employmentHistory?: EmploymentHistoryListRelationFilter
  }, "id" | "workspaceId_code">

  export type PositionOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PositionCountOrderByAggregateInput
    _max?: PositionMaxOrderByAggregateInput
    _min?: PositionMinOrderByAggregateInput
  }

  export type PositionScalarWhereWithAggregatesInput = {
    AND?: PositionScalarWhereWithAggregatesInput | PositionScalarWhereWithAggregatesInput[]
    OR?: PositionScalarWhereWithAggregatesInput[]
    NOT?: PositionScalarWhereWithAggregatesInput | PositionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Position"> | string
    workspaceId?: StringWithAggregatesFilter<"Position"> | string
    name?: StringWithAggregatesFilter<"Position"> | string
    code?: StringNullableWithAggregatesFilter<"Position"> | string | null
    description?: StringNullableWithAggregatesFilter<"Position"> | string | null
    status?: StringWithAggregatesFilter<"Position"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Position"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Position"> | Date | string
  }

  export type PositionLevelWhereInput = {
    AND?: PositionLevelWhereInput | PositionLevelWhereInput[]
    OR?: PositionLevelWhereInput[]
    NOT?: PositionLevelWhereInput | PositionLevelWhereInput[]
    id?: StringFilter<"PositionLevel"> | string
    workspaceId?: StringFilter<"PositionLevel"> | string
    name?: StringFilter<"PositionLevel"> | string
    level?: IntFilter<"PositionLevel"> | number
    description?: StringNullableFilter<"PositionLevel"> | string | null
    status?: StringFilter<"PositionLevel"> | string
    createdAt?: DateTimeFilter<"PositionLevel"> | Date | string
    updatedAt?: DateTimeFilter<"PositionLevel"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    employees?: EmployeeListRelationFilter
    employmentHistory?: EmploymentHistoryListRelationFilter
  }

  export type PositionLevelOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    employees?: EmployeeOrderByRelationAggregateInput
    employmentHistory?: EmploymentHistoryOrderByRelationAggregateInput
  }

  export type PositionLevelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_level?: PositionLevelWorkspaceIdLevelCompoundUniqueInput
    AND?: PositionLevelWhereInput | PositionLevelWhereInput[]
    OR?: PositionLevelWhereInput[]
    NOT?: PositionLevelWhereInput | PositionLevelWhereInput[]
    workspaceId?: StringFilter<"PositionLevel"> | string
    name?: StringFilter<"PositionLevel"> | string
    level?: IntFilter<"PositionLevel"> | number
    description?: StringNullableFilter<"PositionLevel"> | string | null
    status?: StringFilter<"PositionLevel"> | string
    createdAt?: DateTimeFilter<"PositionLevel"> | Date | string
    updatedAt?: DateTimeFilter<"PositionLevel"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    employees?: EmployeeListRelationFilter
    employmentHistory?: EmploymentHistoryListRelationFilter
  }, "id" | "workspaceId_level">

  export type PositionLevelOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PositionLevelCountOrderByAggregateInput
    _avg?: PositionLevelAvgOrderByAggregateInput
    _max?: PositionLevelMaxOrderByAggregateInput
    _min?: PositionLevelMinOrderByAggregateInput
    _sum?: PositionLevelSumOrderByAggregateInput
  }

  export type PositionLevelScalarWhereWithAggregatesInput = {
    AND?: PositionLevelScalarWhereWithAggregatesInput | PositionLevelScalarWhereWithAggregatesInput[]
    OR?: PositionLevelScalarWhereWithAggregatesInput[]
    NOT?: PositionLevelScalarWhereWithAggregatesInput | PositionLevelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PositionLevel"> | string
    workspaceId?: StringWithAggregatesFilter<"PositionLevel"> | string
    name?: StringWithAggregatesFilter<"PositionLevel"> | string
    level?: IntWithAggregatesFilter<"PositionLevel"> | number
    description?: StringNullableWithAggregatesFilter<"PositionLevel"> | string | null
    status?: StringWithAggregatesFilter<"PositionLevel"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PositionLevel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PositionLevel"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    workspaceId?: StringFilter<"Employee"> | string
    userId?: StringNullableFilter<"Employee"> | string | null
    employeeCode?: StringNullableFilter<"Employee"> | string | null
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    thaiFirstName?: StringNullableFilter<"Employee"> | string | null
    thaiLastName?: StringNullableFilter<"Employee"> | string | null
    nickname?: StringNullableFilter<"Employee"> | string | null
    email?: StringFilter<"Employee"> | string
    phone?: StringNullableFilter<"Employee"> | string | null
    emergencyContact?: StringNullableFilter<"Employee"> | string | null
    birthdate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    gender?: StringNullableFilter<"Employee"> | string | null
    nationalId?: StringNullableFilter<"Employee"> | string | null
    nationalIdIv?: StringNullableFilter<"Employee"> | string | null
    passportNumber?: StringNullableFilter<"Employee"> | string | null
    passportNumberIv?: StringNullableFilter<"Employee"> | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    taxId?: StringNullableFilter<"Employee"> | string | null
    bankAccount?: StringNullableFilter<"Employee"> | string | null
    bankAccountIv?: StringNullableFilter<"Employee"> | string | null
    bankName?: StringNullableFilter<"Employee"> | string | null
    hireDate?: DateTimeFilter<"Employee"> | Date | string
    probationEndDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    resignDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    departmentId?: StringNullableFilter<"Employee"> | string | null
    teamId?: StringNullableFilter<"Employee"> | string | null
    positionId?: StringNullableFilter<"Employee"> | string | null
    positionLevelId?: StringNullableFilter<"Employee"> | string | null
    managerId?: StringNullableFilter<"Employee"> | string | null
    status?: EnumEmployeeStatusFilter<"Employee"> | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFilter<"Employee"> | $Enums.EmploymentType
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    position?: XOR<PositionNullableScalarRelationFilter, PositionWhereInput> | null
    positionLevel?: XOR<PositionLevelNullableScalarRelationFilter, PositionLevelWhereInput> | null
    manager?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    subordinates?: EmployeeListRelationFilter
    projectMembers?: ProjectMemberListRelationFilter
    employmentHistory?: EmploymentHistoryListRelationFilter
    documents?: EmployeeDocumentListRelationFilter
    leaveQuotas?: LeaveQuotaListRelationFilter
    leaves?: LeaveListRelationFilter
    overtimes?: OvertimeListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrderInput | SortOrder
    employeeCode?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    thaiFirstName?: SortOrderInput | SortOrder
    thaiLastName?: SortOrderInput | SortOrder
    nickname?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    birthdate?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    nationalId?: SortOrderInput | SortOrder
    nationalIdIv?: SortOrderInput | SortOrder
    passportNumber?: SortOrderInput | SortOrder
    passportNumberIv?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    bankAccountIv?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    hireDate?: SortOrder
    probationEndDate?: SortOrderInput | SortOrder
    resignDate?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    positionLevelId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    status?: SortOrder
    employmentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
    department?: DepartmentOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    position?: PositionOrderByWithRelationInput
    positionLevel?: PositionLevelOrderByWithRelationInput
    manager?: EmployeeOrderByWithRelationInput
    subordinates?: EmployeeOrderByRelationAggregateInput
    projectMembers?: ProjectMemberOrderByRelationAggregateInput
    employmentHistory?: EmploymentHistoryOrderByRelationAggregateInput
    documents?: EmployeeDocumentOrderByRelationAggregateInput
    leaveQuotas?: LeaveQuotaOrderByRelationAggregateInput
    leaves?: LeaveOrderByRelationAggregateInput
    overtimes?: OvertimeOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    workspaceId_employeeCode?: EmployeeWorkspaceIdEmployeeCodeCompoundUniqueInput
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    workspaceId?: StringFilter<"Employee"> | string
    employeeCode?: StringNullableFilter<"Employee"> | string | null
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    thaiFirstName?: StringNullableFilter<"Employee"> | string | null
    thaiLastName?: StringNullableFilter<"Employee"> | string | null
    nickname?: StringNullableFilter<"Employee"> | string | null
    email?: StringFilter<"Employee"> | string
    phone?: StringNullableFilter<"Employee"> | string | null
    emergencyContact?: StringNullableFilter<"Employee"> | string | null
    birthdate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    gender?: StringNullableFilter<"Employee"> | string | null
    nationalId?: StringNullableFilter<"Employee"> | string | null
    nationalIdIv?: StringNullableFilter<"Employee"> | string | null
    passportNumber?: StringNullableFilter<"Employee"> | string | null
    passportNumberIv?: StringNullableFilter<"Employee"> | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    taxId?: StringNullableFilter<"Employee"> | string | null
    bankAccount?: StringNullableFilter<"Employee"> | string | null
    bankAccountIv?: StringNullableFilter<"Employee"> | string | null
    bankName?: StringNullableFilter<"Employee"> | string | null
    hireDate?: DateTimeFilter<"Employee"> | Date | string
    probationEndDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    resignDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    departmentId?: StringNullableFilter<"Employee"> | string | null
    teamId?: StringNullableFilter<"Employee"> | string | null
    positionId?: StringNullableFilter<"Employee"> | string | null
    positionLevelId?: StringNullableFilter<"Employee"> | string | null
    managerId?: StringNullableFilter<"Employee"> | string | null
    status?: EnumEmployeeStatusFilter<"Employee"> | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFilter<"Employee"> | $Enums.EmploymentType
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, TeamWhereInput> | null
    position?: XOR<PositionNullableScalarRelationFilter, PositionWhereInput> | null
    positionLevel?: XOR<PositionLevelNullableScalarRelationFilter, PositionLevelWhereInput> | null
    manager?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
    subordinates?: EmployeeListRelationFilter
    projectMembers?: ProjectMemberListRelationFilter
    employmentHistory?: EmploymentHistoryListRelationFilter
    documents?: EmployeeDocumentListRelationFilter
    leaveQuotas?: LeaveQuotaListRelationFilter
    leaves?: LeaveListRelationFilter
    overtimes?: OvertimeListRelationFilter
  }, "id" | "userId" | "workspaceId_employeeCode">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrderInput | SortOrder
    employeeCode?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    thaiFirstName?: SortOrderInput | SortOrder
    thaiLastName?: SortOrderInput | SortOrder
    nickname?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    emergencyContact?: SortOrderInput | SortOrder
    birthdate?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    nationalId?: SortOrderInput | SortOrder
    nationalIdIv?: SortOrderInput | SortOrder
    passportNumber?: SortOrderInput | SortOrder
    passportNumberIv?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    bankAccount?: SortOrderInput | SortOrder
    bankAccountIv?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    hireDate?: SortOrder
    probationEndDate?: SortOrderInput | SortOrder
    resignDate?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    positionLevelId?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    status?: SortOrder
    employmentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    workspaceId?: StringWithAggregatesFilter<"Employee"> | string
    userId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    employeeCode?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    firstName?: StringWithAggregatesFilter<"Employee"> | string
    lastName?: StringWithAggregatesFilter<"Employee"> | string
    thaiFirstName?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    thaiLastName?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    nickname?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    email?: StringWithAggregatesFilter<"Employee"> | string
    phone?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    emergencyContact?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    birthdate?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    nationalId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    nationalIdIv?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    passportNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    passportNumberIv?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    address?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    bankAccount?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    bankAccountIv?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    hireDate?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    probationEndDate?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    resignDate?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    departmentId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    teamId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    positionId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    positionLevelId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    status?: EnumEmployeeStatusWithAggregatesFilter<"Employee"> | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeWithAggregatesFilter<"Employee"> | $Enums.EmploymentType
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type EmploymentHistoryWhereInput = {
    AND?: EmploymentHistoryWhereInput | EmploymentHistoryWhereInput[]
    OR?: EmploymentHistoryWhereInput[]
    NOT?: EmploymentHistoryWhereInput | EmploymentHistoryWhereInput[]
    id?: StringFilter<"EmploymentHistory"> | string
    employeeId?: StringFilter<"EmploymentHistory"> | string
    positionId?: StringFilter<"EmploymentHistory"> | string
    positionLevelId?: StringNullableFilter<"EmploymentHistory"> | string | null
    departmentId?: StringNullableFilter<"EmploymentHistory"> | string | null
    startDate?: DateTimeFilter<"EmploymentHistory"> | Date | string
    endDate?: DateTimeNullableFilter<"EmploymentHistory"> | Date | string | null
    salary?: DecimalNullableFilter<"EmploymentHistory"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"EmploymentHistory"> | string | null
    createdAt?: DateTimeFilter<"EmploymentHistory"> | Date | string
    updatedAt?: DateTimeFilter<"EmploymentHistory"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    position?: XOR<PositionScalarRelationFilter, PositionWhereInput>
    positionLevel?: XOR<PositionLevelNullableScalarRelationFilter, PositionLevelWhereInput> | null
  }

  export type EmploymentHistoryOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    positionId?: SortOrder
    positionLevelId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    position?: PositionOrderByWithRelationInput
    positionLevel?: PositionLevelOrderByWithRelationInput
  }

  export type EmploymentHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmploymentHistoryWhereInput | EmploymentHistoryWhereInput[]
    OR?: EmploymentHistoryWhereInput[]
    NOT?: EmploymentHistoryWhereInput | EmploymentHistoryWhereInput[]
    employeeId?: StringFilter<"EmploymentHistory"> | string
    positionId?: StringFilter<"EmploymentHistory"> | string
    positionLevelId?: StringNullableFilter<"EmploymentHistory"> | string | null
    departmentId?: StringNullableFilter<"EmploymentHistory"> | string | null
    startDate?: DateTimeFilter<"EmploymentHistory"> | Date | string
    endDate?: DateTimeNullableFilter<"EmploymentHistory"> | Date | string | null
    salary?: DecimalNullableFilter<"EmploymentHistory"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"EmploymentHistory"> | string | null
    createdAt?: DateTimeFilter<"EmploymentHistory"> | Date | string
    updatedAt?: DateTimeFilter<"EmploymentHistory"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    position?: XOR<PositionScalarRelationFilter, PositionWhereInput>
    positionLevel?: XOR<PositionLevelNullableScalarRelationFilter, PositionLevelWhereInput> | null
  }, "id">

  export type EmploymentHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    positionId?: SortOrder
    positionLevelId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmploymentHistoryCountOrderByAggregateInput
    _avg?: EmploymentHistoryAvgOrderByAggregateInput
    _max?: EmploymentHistoryMaxOrderByAggregateInput
    _min?: EmploymentHistoryMinOrderByAggregateInput
    _sum?: EmploymentHistorySumOrderByAggregateInput
  }

  export type EmploymentHistoryScalarWhereWithAggregatesInput = {
    AND?: EmploymentHistoryScalarWhereWithAggregatesInput | EmploymentHistoryScalarWhereWithAggregatesInput[]
    OR?: EmploymentHistoryScalarWhereWithAggregatesInput[]
    NOT?: EmploymentHistoryScalarWhereWithAggregatesInput | EmploymentHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmploymentHistory"> | string
    employeeId?: StringWithAggregatesFilter<"EmploymentHistory"> | string
    positionId?: StringWithAggregatesFilter<"EmploymentHistory"> | string
    positionLevelId?: StringNullableWithAggregatesFilter<"EmploymentHistory"> | string | null
    departmentId?: StringNullableWithAggregatesFilter<"EmploymentHistory"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"EmploymentHistory"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"EmploymentHistory"> | Date | string | null
    salary?: DecimalNullableWithAggregatesFilter<"EmploymentHistory"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"EmploymentHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmploymentHistory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmploymentHistory"> | Date | string
  }

  export type EmployeeDocumentWhereInput = {
    AND?: EmployeeDocumentWhereInput | EmployeeDocumentWhereInput[]
    OR?: EmployeeDocumentWhereInput[]
    NOT?: EmployeeDocumentWhereInput | EmployeeDocumentWhereInput[]
    id?: StringFilter<"EmployeeDocument"> | string
    employeeId?: StringFilter<"EmployeeDocument"> | string
    type?: StringFilter<"EmployeeDocument"> | string
    name?: StringFilter<"EmployeeDocument"> | string
    filename?: StringFilter<"EmployeeDocument"> | string
    mimeType?: StringFilter<"EmployeeDocument"> | string
    size?: IntFilter<"EmployeeDocument"> | number
    url?: StringFilter<"EmployeeDocument"> | string
    uploadedBy?: StringFilter<"EmployeeDocument"> | string
    createdAt?: DateTimeFilter<"EmployeeDocument"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeDocument"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type EmployeeDocumentOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
  }

  export type EmployeeDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmployeeDocumentWhereInput | EmployeeDocumentWhereInput[]
    OR?: EmployeeDocumentWhereInput[]
    NOT?: EmployeeDocumentWhereInput | EmployeeDocumentWhereInput[]
    employeeId?: StringFilter<"EmployeeDocument"> | string
    type?: StringFilter<"EmployeeDocument"> | string
    name?: StringFilter<"EmployeeDocument"> | string
    filename?: StringFilter<"EmployeeDocument"> | string
    mimeType?: StringFilter<"EmployeeDocument"> | string
    size?: IntFilter<"EmployeeDocument"> | number
    url?: StringFilter<"EmployeeDocument"> | string
    uploadedBy?: StringFilter<"EmployeeDocument"> | string
    createdAt?: DateTimeFilter<"EmployeeDocument"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeDocument"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type EmployeeDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeDocumentCountOrderByAggregateInput
    _avg?: EmployeeDocumentAvgOrderByAggregateInput
    _max?: EmployeeDocumentMaxOrderByAggregateInput
    _min?: EmployeeDocumentMinOrderByAggregateInput
    _sum?: EmployeeDocumentSumOrderByAggregateInput
  }

  export type EmployeeDocumentScalarWhereWithAggregatesInput = {
    AND?: EmployeeDocumentScalarWhereWithAggregatesInput | EmployeeDocumentScalarWhereWithAggregatesInput[]
    OR?: EmployeeDocumentScalarWhereWithAggregatesInput[]
    NOT?: EmployeeDocumentScalarWhereWithAggregatesInput | EmployeeDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeDocument"> | string
    employeeId?: StringWithAggregatesFilter<"EmployeeDocument"> | string
    type?: StringWithAggregatesFilter<"EmployeeDocument"> | string
    name?: StringWithAggregatesFilter<"EmployeeDocument"> | string
    filename?: StringWithAggregatesFilter<"EmployeeDocument"> | string
    mimeType?: StringWithAggregatesFilter<"EmployeeDocument"> | string
    size?: IntWithAggregatesFilter<"EmployeeDocument"> | number
    url?: StringWithAggregatesFilter<"EmployeeDocument"> | string
    uploadedBy?: StringWithAggregatesFilter<"EmployeeDocument"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeDocument"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeDocument"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    workspaceId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    code?: StringNullableFilter<"Project"> | string | null
    description?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    budget?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    priority?: EnumProjectPriorityFilter<"Project"> | $Enums.ProjectPriority
    managerId?: StringNullableFilter<"Project"> | string | null
    clientName?: StringNullableFilter<"Project"> | string | null
    clientContact?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    members?: ProjectMemberListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    managerId?: SortOrderInput | SortOrder
    clientName?: SortOrderInput | SortOrder
    clientContact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    members?: ProjectMemberOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_code?: ProjectWorkspaceIdCodeCompoundUniqueInput
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    workspaceId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    code?: StringNullableFilter<"Project"> | string | null
    description?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    budget?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    priority?: EnumProjectPriorityFilter<"Project"> | $Enums.ProjectPriority
    managerId?: StringNullableFilter<"Project"> | string | null
    clientName?: StringNullableFilter<"Project"> | string | null
    clientContact?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    members?: ProjectMemberListRelationFilter
  }, "id" | "workspaceId_code">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    managerId?: SortOrderInput | SortOrder
    clientName?: SortOrderInput | SortOrder
    clientContact?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    workspaceId?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    code?: StringNullableWithAggregatesFilter<"Project"> | string | null
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    budget?: DecimalNullableWithAggregatesFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumProjectStatusWithAggregatesFilter<"Project"> | $Enums.ProjectStatus
    priority?: EnumProjectPriorityWithAggregatesFilter<"Project"> | $Enums.ProjectPriority
    managerId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    clientName?: StringNullableWithAggregatesFilter<"Project"> | string | null
    clientContact?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type ProjectMemberWhereInput = {
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    id?: StringFilter<"ProjectMember"> | string
    projectId?: StringFilter<"ProjectMember"> | string
    employeeId?: StringFilter<"ProjectMember"> | string
    roleId?: StringFilter<"ProjectMember"> | string
    allocation?: IntFilter<"ProjectMember"> | number
    startDate?: DateTimeFilter<"ProjectMember"> | Date | string
    endDate?: DateTimeNullableFilter<"ProjectMember"> | Date | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    projectRole?: XOR<ProjectRoleScalarRelationFilter, ProjectRoleWhereInput>
  }

  export type ProjectMemberOrderByWithRelationInput = {
    id?: SortOrder
    projectId?: SortOrder
    employeeId?: SortOrder
    roleId?: SortOrder
    allocation?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    project?: ProjectOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    projectRole?: ProjectRoleOrderByWithRelationInput
  }

  export type ProjectMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    projectId_employeeId?: ProjectMemberProjectIdEmployeeIdCompoundUniqueInput
    AND?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    OR?: ProjectMemberWhereInput[]
    NOT?: ProjectMemberWhereInput | ProjectMemberWhereInput[]
    projectId?: StringFilter<"ProjectMember"> | string
    employeeId?: StringFilter<"ProjectMember"> | string
    roleId?: StringFilter<"ProjectMember"> | string
    allocation?: IntFilter<"ProjectMember"> | number
    startDate?: DateTimeFilter<"ProjectMember"> | Date | string
    endDate?: DateTimeNullableFilter<"ProjectMember"> | Date | string | null
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    projectRole?: XOR<ProjectRoleScalarRelationFilter, ProjectRoleWhereInput>
  }, "id" | "projectId_employeeId">

  export type ProjectMemberOrderByWithAggregationInput = {
    id?: SortOrder
    projectId?: SortOrder
    employeeId?: SortOrder
    roleId?: SortOrder
    allocation?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    _count?: ProjectMemberCountOrderByAggregateInput
    _avg?: ProjectMemberAvgOrderByAggregateInput
    _max?: ProjectMemberMaxOrderByAggregateInput
    _min?: ProjectMemberMinOrderByAggregateInput
    _sum?: ProjectMemberSumOrderByAggregateInput
  }

  export type ProjectMemberScalarWhereWithAggregatesInput = {
    AND?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    OR?: ProjectMemberScalarWhereWithAggregatesInput[]
    NOT?: ProjectMemberScalarWhereWithAggregatesInput | ProjectMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectMember"> | string
    projectId?: StringWithAggregatesFilter<"ProjectMember"> | string
    employeeId?: StringWithAggregatesFilter<"ProjectMember"> | string
    roleId?: StringWithAggregatesFilter<"ProjectMember"> | string
    allocation?: IntWithAggregatesFilter<"ProjectMember"> | number
    startDate?: DateTimeWithAggregatesFilter<"ProjectMember"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"ProjectMember"> | Date | string | null
  }

  export type ProjectRoleWhereInput = {
    AND?: ProjectRoleWhereInput | ProjectRoleWhereInput[]
    OR?: ProjectRoleWhereInput[]
    NOT?: ProjectRoleWhereInput | ProjectRoleWhereInput[]
    id?: StringFilter<"ProjectRole"> | string
    workspaceId?: StringNullableFilter<"ProjectRole"> | string | null
    name?: StringFilter<"ProjectRole"> | string
    description?: StringNullableFilter<"ProjectRole"> | string | null
    createdAt?: DateTimeFilter<"ProjectRole"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectRole"> | Date | string
    workspace?: XOR<WorkspaceNullableScalarRelationFilter, WorkspaceWhereInput> | null
    projectMembers?: ProjectMemberListRelationFilter
  }

  export type ProjectRoleOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    projectMembers?: ProjectMemberOrderByRelationAggregateInput
  }

  export type ProjectRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_name?: ProjectRoleWorkspaceIdNameCompoundUniqueInput
    AND?: ProjectRoleWhereInput | ProjectRoleWhereInput[]
    OR?: ProjectRoleWhereInput[]
    NOT?: ProjectRoleWhereInput | ProjectRoleWhereInput[]
    workspaceId?: StringNullableFilter<"ProjectRole"> | string | null
    name?: StringFilter<"ProjectRole"> | string
    description?: StringNullableFilter<"ProjectRole"> | string | null
    createdAt?: DateTimeFilter<"ProjectRole"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectRole"> | Date | string
    workspace?: XOR<WorkspaceNullableScalarRelationFilter, WorkspaceWhereInput> | null
    projectMembers?: ProjectMemberListRelationFilter
  }, "id" | "workspaceId_name">

  export type ProjectRoleOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectRoleCountOrderByAggregateInput
    _max?: ProjectRoleMaxOrderByAggregateInput
    _min?: ProjectRoleMinOrderByAggregateInput
  }

  export type ProjectRoleScalarWhereWithAggregatesInput = {
    AND?: ProjectRoleScalarWhereWithAggregatesInput | ProjectRoleScalarWhereWithAggregatesInput[]
    OR?: ProjectRoleScalarWhereWithAggregatesInput[]
    NOT?: ProjectRoleScalarWhereWithAggregatesInput | ProjectRoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectRole"> | string
    workspaceId?: StringNullableWithAggregatesFilter<"ProjectRole"> | string | null
    name?: StringWithAggregatesFilter<"ProjectRole"> | string
    description?: StringNullableWithAggregatesFilter<"ProjectRole"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProjectRole"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectRole"> | Date | string
  }

  export type LeaveTypeWhereInput = {
    AND?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    OR?: LeaveTypeWhereInput[]
    NOT?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    id?: StringFilter<"LeaveType"> | string
    workspaceId?: StringFilter<"LeaveType"> | string
    name?: StringFilter<"LeaveType"> | string
    code?: StringFilter<"LeaveType"> | string
    description?: StringNullableFilter<"LeaveType"> | string | null
    color?: StringNullableFilter<"LeaveType"> | string | null
    isPaid?: BoolFilter<"LeaveType"> | boolean
    requiresApproval?: BoolFilter<"LeaveType"> | boolean
    requiresAttachment?: BoolFilter<"LeaveType"> | boolean
    maxDaysPerYear?: IntNullableFilter<"LeaveType"> | number | null
    status?: StringFilter<"LeaveType"> | string
    createdAt?: DateTimeFilter<"LeaveType"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveType"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    leaveQuotas?: LeaveQuotaListRelationFilter
    leaves?: LeaveListRelationFilter
  }

  export type LeaveTypeOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isPaid?: SortOrder
    requiresApproval?: SortOrder
    requiresAttachment?: SortOrder
    maxDaysPerYear?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    leaveQuotas?: LeaveQuotaOrderByRelationAggregateInput
    leaves?: LeaveOrderByRelationAggregateInput
  }

  export type LeaveTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_code?: LeaveTypeWorkspaceIdCodeCompoundUniqueInput
    AND?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    OR?: LeaveTypeWhereInput[]
    NOT?: LeaveTypeWhereInput | LeaveTypeWhereInput[]
    workspaceId?: StringFilter<"LeaveType"> | string
    name?: StringFilter<"LeaveType"> | string
    code?: StringFilter<"LeaveType"> | string
    description?: StringNullableFilter<"LeaveType"> | string | null
    color?: StringNullableFilter<"LeaveType"> | string | null
    isPaid?: BoolFilter<"LeaveType"> | boolean
    requiresApproval?: BoolFilter<"LeaveType"> | boolean
    requiresAttachment?: BoolFilter<"LeaveType"> | boolean
    maxDaysPerYear?: IntNullableFilter<"LeaveType"> | number | null
    status?: StringFilter<"LeaveType"> | string
    createdAt?: DateTimeFilter<"LeaveType"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveType"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    leaveQuotas?: LeaveQuotaListRelationFilter
    leaves?: LeaveListRelationFilter
  }, "id" | "workspaceId_code">

  export type LeaveTypeOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    isPaid?: SortOrder
    requiresApproval?: SortOrder
    requiresAttachment?: SortOrder
    maxDaysPerYear?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveTypeCountOrderByAggregateInput
    _avg?: LeaveTypeAvgOrderByAggregateInput
    _max?: LeaveTypeMaxOrderByAggregateInput
    _min?: LeaveTypeMinOrderByAggregateInput
    _sum?: LeaveTypeSumOrderByAggregateInput
  }

  export type LeaveTypeScalarWhereWithAggregatesInput = {
    AND?: LeaveTypeScalarWhereWithAggregatesInput | LeaveTypeScalarWhereWithAggregatesInput[]
    OR?: LeaveTypeScalarWhereWithAggregatesInput[]
    NOT?: LeaveTypeScalarWhereWithAggregatesInput | LeaveTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveType"> | string
    workspaceId?: StringWithAggregatesFilter<"LeaveType"> | string
    name?: StringWithAggregatesFilter<"LeaveType"> | string
    code?: StringWithAggregatesFilter<"LeaveType"> | string
    description?: StringNullableWithAggregatesFilter<"LeaveType"> | string | null
    color?: StringNullableWithAggregatesFilter<"LeaveType"> | string | null
    isPaid?: BoolWithAggregatesFilter<"LeaveType"> | boolean
    requiresApproval?: BoolWithAggregatesFilter<"LeaveType"> | boolean
    requiresAttachment?: BoolWithAggregatesFilter<"LeaveType"> | boolean
    maxDaysPerYear?: IntNullableWithAggregatesFilter<"LeaveType"> | number | null
    status?: StringWithAggregatesFilter<"LeaveType"> | string
    createdAt?: DateTimeWithAggregatesFilter<"LeaveType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaveType"> | Date | string
  }

  export type LeaveQuotaWhereInput = {
    AND?: LeaveQuotaWhereInput | LeaveQuotaWhereInput[]
    OR?: LeaveQuotaWhereInput[]
    NOT?: LeaveQuotaWhereInput | LeaveQuotaWhereInput[]
    id?: StringFilter<"LeaveQuota"> | string
    workspaceId?: StringFilter<"LeaveQuota"> | string
    employeeId?: StringFilter<"LeaveQuota"> | string
    leaveTypeId?: StringFilter<"LeaveQuota"> | string
    year?: IntFilter<"LeaveQuota"> | number
    total?: FloatFilter<"LeaveQuota"> | number
    used?: FloatFilter<"LeaveQuota"> | number
    pending?: FloatFilter<"LeaveQuota"> | number
    remaining?: FloatFilter<"LeaveQuota"> | number
    createdAt?: DateTimeFilter<"LeaveQuota"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveQuota"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    leaveType?: XOR<LeaveTypeScalarRelationFilter, LeaveTypeWhereInput>
  }

  export type LeaveQuotaOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    year?: SortOrder
    total?: SortOrder
    used?: SortOrder
    pending?: SortOrder
    remaining?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    leaveType?: LeaveTypeOrderByWithRelationInput
  }

  export type LeaveQuotaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_employeeId_leaveTypeId_year?: LeaveQuotaWorkspaceIdEmployeeIdLeaveTypeIdYearCompoundUniqueInput
    AND?: LeaveQuotaWhereInput | LeaveQuotaWhereInput[]
    OR?: LeaveQuotaWhereInput[]
    NOT?: LeaveQuotaWhereInput | LeaveQuotaWhereInput[]
    workspaceId?: StringFilter<"LeaveQuota"> | string
    employeeId?: StringFilter<"LeaveQuota"> | string
    leaveTypeId?: StringFilter<"LeaveQuota"> | string
    year?: IntFilter<"LeaveQuota"> | number
    total?: FloatFilter<"LeaveQuota"> | number
    used?: FloatFilter<"LeaveQuota"> | number
    pending?: FloatFilter<"LeaveQuota"> | number
    remaining?: FloatFilter<"LeaveQuota"> | number
    createdAt?: DateTimeFilter<"LeaveQuota"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveQuota"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    leaveType?: XOR<LeaveTypeScalarRelationFilter, LeaveTypeWhereInput>
  }, "id" | "workspaceId_employeeId_leaveTypeId_year">

  export type LeaveQuotaOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    year?: SortOrder
    total?: SortOrder
    used?: SortOrder
    pending?: SortOrder
    remaining?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveQuotaCountOrderByAggregateInput
    _avg?: LeaveQuotaAvgOrderByAggregateInput
    _max?: LeaveQuotaMaxOrderByAggregateInput
    _min?: LeaveQuotaMinOrderByAggregateInput
    _sum?: LeaveQuotaSumOrderByAggregateInput
  }

  export type LeaveQuotaScalarWhereWithAggregatesInput = {
    AND?: LeaveQuotaScalarWhereWithAggregatesInput | LeaveQuotaScalarWhereWithAggregatesInput[]
    OR?: LeaveQuotaScalarWhereWithAggregatesInput[]
    NOT?: LeaveQuotaScalarWhereWithAggregatesInput | LeaveQuotaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveQuota"> | string
    workspaceId?: StringWithAggregatesFilter<"LeaveQuota"> | string
    employeeId?: StringWithAggregatesFilter<"LeaveQuota"> | string
    leaveTypeId?: StringWithAggregatesFilter<"LeaveQuota"> | string
    year?: IntWithAggregatesFilter<"LeaveQuota"> | number
    total?: FloatWithAggregatesFilter<"LeaveQuota"> | number
    used?: FloatWithAggregatesFilter<"LeaveQuota"> | number
    pending?: FloatWithAggregatesFilter<"LeaveQuota"> | number
    remaining?: FloatWithAggregatesFilter<"LeaveQuota"> | number
    createdAt?: DateTimeWithAggregatesFilter<"LeaveQuota"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaveQuota"> | Date | string
  }

  export type LeaveWhereInput = {
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    id?: StringFilter<"Leave"> | string
    workspaceId?: StringFilter<"Leave"> | string
    employeeId?: StringFilter<"Leave"> | string
    leaveTypeId?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    halfDay?: BoolFilter<"Leave"> | boolean
    duration?: FloatFilter<"Leave"> | number
    reason?: StringNullableFilter<"Leave"> | string | null
    attachment?: StringNullableFilter<"Leave"> | string | null
    status?: EnumLeaveStatusFilter<"Leave"> | $Enums.LeaveStatus
    notes?: StringNullableFilter<"Leave"> | string | null
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    leaveType?: XOR<LeaveTypeScalarRelationFilter, LeaveTypeWhereInput>
    approval?: XOR<ApprovalNullableScalarRelationFilter, ApprovalWhereInput> | null
  }

  export type LeaveOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    halfDay?: SortOrder
    duration?: SortOrder
    reason?: SortOrderInput | SortOrder
    attachment?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    leaveType?: LeaveTypeOrderByWithRelationInput
    approval?: ApprovalOrderByWithRelationInput
  }

  export type LeaveWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    workspaceId?: StringFilter<"Leave"> | string
    employeeId?: StringFilter<"Leave"> | string
    leaveTypeId?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    halfDay?: BoolFilter<"Leave"> | boolean
    duration?: FloatFilter<"Leave"> | number
    reason?: StringNullableFilter<"Leave"> | string | null
    attachment?: StringNullableFilter<"Leave"> | string | null
    status?: EnumLeaveStatusFilter<"Leave"> | $Enums.LeaveStatus
    notes?: StringNullableFilter<"Leave"> | string | null
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    leaveType?: XOR<LeaveTypeScalarRelationFilter, LeaveTypeWhereInput>
    approval?: XOR<ApprovalNullableScalarRelationFilter, ApprovalWhereInput> | null
  }, "id">

  export type LeaveOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    halfDay?: SortOrder
    duration?: SortOrder
    reason?: SortOrderInput | SortOrder
    attachment?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveCountOrderByAggregateInput
    _avg?: LeaveAvgOrderByAggregateInput
    _max?: LeaveMaxOrderByAggregateInput
    _min?: LeaveMinOrderByAggregateInput
    _sum?: LeaveSumOrderByAggregateInput
  }

  export type LeaveScalarWhereWithAggregatesInput = {
    AND?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    OR?: LeaveScalarWhereWithAggregatesInput[]
    NOT?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Leave"> | string
    workspaceId?: StringWithAggregatesFilter<"Leave"> | string
    employeeId?: StringWithAggregatesFilter<"Leave"> | string
    leaveTypeId?: StringWithAggregatesFilter<"Leave"> | string
    startDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    halfDay?: BoolWithAggregatesFilter<"Leave"> | boolean
    duration?: FloatWithAggregatesFilter<"Leave"> | number
    reason?: StringNullableWithAggregatesFilter<"Leave"> | string | null
    attachment?: StringNullableWithAggregatesFilter<"Leave"> | string | null
    status?: EnumLeaveStatusWithAggregatesFilter<"Leave"> | $Enums.LeaveStatus
    notes?: StringNullableWithAggregatesFilter<"Leave"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
  }

  export type OvertimePolicyWhereInput = {
    AND?: OvertimePolicyWhereInput | OvertimePolicyWhereInput[]
    OR?: OvertimePolicyWhereInput[]
    NOT?: OvertimePolicyWhereInput | OvertimePolicyWhereInput[]
    id?: StringFilter<"OvertimePolicy"> | string
    workspaceId?: StringFilter<"OvertimePolicy"> | string
    name?: StringFilter<"OvertimePolicy"> | string
    description?: StringNullableFilter<"OvertimePolicy"> | string | null
    rate?: FloatFilter<"OvertimePolicy"> | number
    minimumHours?: FloatFilter<"OvertimePolicy"> | number
    maximumHours?: FloatNullableFilter<"OvertimePolicy"> | number | null
    requiresApproval?: BoolFilter<"OvertimePolicy"> | boolean
    status?: StringFilter<"OvertimePolicy"> | string
    createdAt?: DateTimeFilter<"OvertimePolicy"> | Date | string
    updatedAt?: DateTimeFilter<"OvertimePolicy"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    overtimes?: OvertimeListRelationFilter
  }

  export type OvertimePolicyOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    rate?: SortOrder
    minimumHours?: SortOrder
    maximumHours?: SortOrderInput | SortOrder
    requiresApproval?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    overtimes?: OvertimeOrderByRelationAggregateInput
  }

  export type OvertimePolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_name?: OvertimePolicyWorkspaceIdNameCompoundUniqueInput
    AND?: OvertimePolicyWhereInput | OvertimePolicyWhereInput[]
    OR?: OvertimePolicyWhereInput[]
    NOT?: OvertimePolicyWhereInput | OvertimePolicyWhereInput[]
    workspaceId?: StringFilter<"OvertimePolicy"> | string
    name?: StringFilter<"OvertimePolicy"> | string
    description?: StringNullableFilter<"OvertimePolicy"> | string | null
    rate?: FloatFilter<"OvertimePolicy"> | number
    minimumHours?: FloatFilter<"OvertimePolicy"> | number
    maximumHours?: FloatNullableFilter<"OvertimePolicy"> | number | null
    requiresApproval?: BoolFilter<"OvertimePolicy"> | boolean
    status?: StringFilter<"OvertimePolicy"> | string
    createdAt?: DateTimeFilter<"OvertimePolicy"> | Date | string
    updatedAt?: DateTimeFilter<"OvertimePolicy"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    overtimes?: OvertimeListRelationFilter
  }, "id" | "workspaceId_name">

  export type OvertimePolicyOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    rate?: SortOrder
    minimumHours?: SortOrder
    maximumHours?: SortOrderInput | SortOrder
    requiresApproval?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OvertimePolicyCountOrderByAggregateInput
    _avg?: OvertimePolicyAvgOrderByAggregateInput
    _max?: OvertimePolicyMaxOrderByAggregateInput
    _min?: OvertimePolicyMinOrderByAggregateInput
    _sum?: OvertimePolicySumOrderByAggregateInput
  }

  export type OvertimePolicyScalarWhereWithAggregatesInput = {
    AND?: OvertimePolicyScalarWhereWithAggregatesInput | OvertimePolicyScalarWhereWithAggregatesInput[]
    OR?: OvertimePolicyScalarWhereWithAggregatesInput[]
    NOT?: OvertimePolicyScalarWhereWithAggregatesInput | OvertimePolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OvertimePolicy"> | string
    workspaceId?: StringWithAggregatesFilter<"OvertimePolicy"> | string
    name?: StringWithAggregatesFilter<"OvertimePolicy"> | string
    description?: StringNullableWithAggregatesFilter<"OvertimePolicy"> | string | null
    rate?: FloatWithAggregatesFilter<"OvertimePolicy"> | number
    minimumHours?: FloatWithAggregatesFilter<"OvertimePolicy"> | number
    maximumHours?: FloatNullableWithAggregatesFilter<"OvertimePolicy"> | number | null
    requiresApproval?: BoolWithAggregatesFilter<"OvertimePolicy"> | boolean
    status?: StringWithAggregatesFilter<"OvertimePolicy"> | string
    createdAt?: DateTimeWithAggregatesFilter<"OvertimePolicy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OvertimePolicy"> | Date | string
  }

  export type OvertimeWhereInput = {
    AND?: OvertimeWhereInput | OvertimeWhereInput[]
    OR?: OvertimeWhereInput[]
    NOT?: OvertimeWhereInput | OvertimeWhereInput[]
    id?: StringFilter<"Overtime"> | string
    workspaceId?: StringFilter<"Overtime"> | string
    employeeId?: StringFilter<"Overtime"> | string
    policyId?: StringFilter<"Overtime"> | string
    date?: DateTimeFilter<"Overtime"> | Date | string
    startTime?: DateTimeFilter<"Overtime"> | Date | string
    endTime?: DateTimeFilter<"Overtime"> | Date | string
    hours?: FloatFilter<"Overtime"> | number
    reason?: StringFilter<"Overtime"> | string
    status?: EnumOvertimeStatusFilter<"Overtime"> | $Enums.OvertimeStatus
    notes?: StringNullableFilter<"Overtime"> | string | null
    createdAt?: DateTimeFilter<"Overtime"> | Date | string
    updatedAt?: DateTimeFilter<"Overtime"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    overtimePolicy?: XOR<OvertimePolicyScalarRelationFilter, OvertimePolicyWhereInput>
    approval?: XOR<ApprovalNullableScalarRelationFilter, ApprovalWhereInput> | null
  }

  export type OvertimeOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    employeeId?: SortOrder
    policyId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    hours?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
    overtimePolicy?: OvertimePolicyOrderByWithRelationInput
    approval?: ApprovalOrderByWithRelationInput
  }

  export type OvertimeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OvertimeWhereInput | OvertimeWhereInput[]
    OR?: OvertimeWhereInput[]
    NOT?: OvertimeWhereInput | OvertimeWhereInput[]
    workspaceId?: StringFilter<"Overtime"> | string
    employeeId?: StringFilter<"Overtime"> | string
    policyId?: StringFilter<"Overtime"> | string
    date?: DateTimeFilter<"Overtime"> | Date | string
    startTime?: DateTimeFilter<"Overtime"> | Date | string
    endTime?: DateTimeFilter<"Overtime"> | Date | string
    hours?: FloatFilter<"Overtime"> | number
    reason?: StringFilter<"Overtime"> | string
    status?: EnumOvertimeStatusFilter<"Overtime"> | $Enums.OvertimeStatus
    notes?: StringNullableFilter<"Overtime"> | string | null
    createdAt?: DateTimeFilter<"Overtime"> | Date | string
    updatedAt?: DateTimeFilter<"Overtime"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    overtimePolicy?: XOR<OvertimePolicyScalarRelationFilter, OvertimePolicyWhereInput>
    approval?: XOR<ApprovalNullableScalarRelationFilter, ApprovalWhereInput> | null
  }, "id">

  export type OvertimeOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    employeeId?: SortOrder
    policyId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    hours?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OvertimeCountOrderByAggregateInput
    _avg?: OvertimeAvgOrderByAggregateInput
    _max?: OvertimeMaxOrderByAggregateInput
    _min?: OvertimeMinOrderByAggregateInput
    _sum?: OvertimeSumOrderByAggregateInput
  }

  export type OvertimeScalarWhereWithAggregatesInput = {
    AND?: OvertimeScalarWhereWithAggregatesInput | OvertimeScalarWhereWithAggregatesInput[]
    OR?: OvertimeScalarWhereWithAggregatesInput[]
    NOT?: OvertimeScalarWhereWithAggregatesInput | OvertimeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Overtime"> | string
    workspaceId?: StringWithAggregatesFilter<"Overtime"> | string
    employeeId?: StringWithAggregatesFilter<"Overtime"> | string
    policyId?: StringWithAggregatesFilter<"Overtime"> | string
    date?: DateTimeWithAggregatesFilter<"Overtime"> | Date | string
    startTime?: DateTimeWithAggregatesFilter<"Overtime"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Overtime"> | Date | string
    hours?: FloatWithAggregatesFilter<"Overtime"> | number
    reason?: StringWithAggregatesFilter<"Overtime"> | string
    status?: EnumOvertimeStatusWithAggregatesFilter<"Overtime"> | $Enums.OvertimeStatus
    notes?: StringNullableWithAggregatesFilter<"Overtime"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Overtime"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Overtime"> | Date | string
  }

  export type ApprovalTemplateWhereInput = {
    AND?: ApprovalTemplateWhereInput | ApprovalTemplateWhereInput[]
    OR?: ApprovalTemplateWhereInput[]
    NOT?: ApprovalTemplateWhereInput | ApprovalTemplateWhereInput[]
    id?: StringFilter<"ApprovalTemplate"> | string
    workspaceId?: StringFilter<"ApprovalTemplate"> | string
    name?: StringFilter<"ApprovalTemplate"> | string
    description?: StringNullableFilter<"ApprovalTemplate"> | string | null
    entityType?: StringFilter<"ApprovalTemplate"> | string
    active?: BoolFilter<"ApprovalTemplate"> | boolean
    createdAt?: DateTimeFilter<"ApprovalTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalTemplate"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    steps?: ApprovalStepListRelationFilter
    approvals?: ApprovalListRelationFilter
  }

  export type ApprovalTemplateOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    entityType?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    steps?: ApprovalStepOrderByRelationAggregateInput
    approvals?: ApprovalOrderByRelationAggregateInput
  }

  export type ApprovalTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_name?: ApprovalTemplateWorkspaceIdNameCompoundUniqueInput
    AND?: ApprovalTemplateWhereInput | ApprovalTemplateWhereInput[]
    OR?: ApprovalTemplateWhereInput[]
    NOT?: ApprovalTemplateWhereInput | ApprovalTemplateWhereInput[]
    workspaceId?: StringFilter<"ApprovalTemplate"> | string
    name?: StringFilter<"ApprovalTemplate"> | string
    description?: StringNullableFilter<"ApprovalTemplate"> | string | null
    entityType?: StringFilter<"ApprovalTemplate"> | string
    active?: BoolFilter<"ApprovalTemplate"> | boolean
    createdAt?: DateTimeFilter<"ApprovalTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalTemplate"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    steps?: ApprovalStepListRelationFilter
    approvals?: ApprovalListRelationFilter
  }, "id" | "workspaceId_name">

  export type ApprovalTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    entityType?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApprovalTemplateCountOrderByAggregateInput
    _max?: ApprovalTemplateMaxOrderByAggregateInput
    _min?: ApprovalTemplateMinOrderByAggregateInput
  }

  export type ApprovalTemplateScalarWhereWithAggregatesInput = {
    AND?: ApprovalTemplateScalarWhereWithAggregatesInput | ApprovalTemplateScalarWhereWithAggregatesInput[]
    OR?: ApprovalTemplateScalarWhereWithAggregatesInput[]
    NOT?: ApprovalTemplateScalarWhereWithAggregatesInput | ApprovalTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApprovalTemplate"> | string
    workspaceId?: StringWithAggregatesFilter<"ApprovalTemplate"> | string
    name?: StringWithAggregatesFilter<"ApprovalTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"ApprovalTemplate"> | string | null
    entityType?: StringWithAggregatesFilter<"ApprovalTemplate"> | string
    active?: BoolWithAggregatesFilter<"ApprovalTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ApprovalTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApprovalTemplate"> | Date | string
  }

  export type ApprovalStepWhereInput = {
    AND?: ApprovalStepWhereInput | ApprovalStepWhereInput[]
    OR?: ApprovalStepWhereInput[]
    NOT?: ApprovalStepWhereInput | ApprovalStepWhereInput[]
    id?: StringFilter<"ApprovalStep"> | string
    approvalTemplateId?: StringFilter<"ApprovalStep"> | string
    stepNumber?: IntFilter<"ApprovalStep"> | number
    approverType?: EnumApproverTypeFilter<"ApprovalStep"> | $Enums.ApproverType
    approverId?: StringNullableFilter<"ApprovalStep"> | string | null
    backup1Id?: StringNullableFilter<"ApprovalStep"> | string | null
    backup2Id?: StringNullableFilter<"ApprovalStep"> | string | null
    timeLimit?: IntNullableFilter<"ApprovalStep"> | number | null
    approvalTemplate?: XOR<ApprovalTemplateScalarRelationFilter, ApprovalTemplateWhereInput>
  }

  export type ApprovalStepOrderByWithRelationInput = {
    id?: SortOrder
    approvalTemplateId?: SortOrder
    stepNumber?: SortOrder
    approverType?: SortOrder
    approverId?: SortOrderInput | SortOrder
    backup1Id?: SortOrderInput | SortOrder
    backup2Id?: SortOrderInput | SortOrder
    timeLimit?: SortOrderInput | SortOrder
    approvalTemplate?: ApprovalTemplateOrderByWithRelationInput
  }

  export type ApprovalStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    approvalTemplateId_stepNumber?: ApprovalStepApprovalTemplateIdStepNumberCompoundUniqueInput
    AND?: ApprovalStepWhereInput | ApprovalStepWhereInput[]
    OR?: ApprovalStepWhereInput[]
    NOT?: ApprovalStepWhereInput | ApprovalStepWhereInput[]
    approvalTemplateId?: StringFilter<"ApprovalStep"> | string
    stepNumber?: IntFilter<"ApprovalStep"> | number
    approverType?: EnumApproverTypeFilter<"ApprovalStep"> | $Enums.ApproverType
    approverId?: StringNullableFilter<"ApprovalStep"> | string | null
    backup1Id?: StringNullableFilter<"ApprovalStep"> | string | null
    backup2Id?: StringNullableFilter<"ApprovalStep"> | string | null
    timeLimit?: IntNullableFilter<"ApprovalStep"> | number | null
    approvalTemplate?: XOR<ApprovalTemplateScalarRelationFilter, ApprovalTemplateWhereInput>
  }, "id" | "approvalTemplateId_stepNumber">

  export type ApprovalStepOrderByWithAggregationInput = {
    id?: SortOrder
    approvalTemplateId?: SortOrder
    stepNumber?: SortOrder
    approverType?: SortOrder
    approverId?: SortOrderInput | SortOrder
    backup1Id?: SortOrderInput | SortOrder
    backup2Id?: SortOrderInput | SortOrder
    timeLimit?: SortOrderInput | SortOrder
    _count?: ApprovalStepCountOrderByAggregateInput
    _avg?: ApprovalStepAvgOrderByAggregateInput
    _max?: ApprovalStepMaxOrderByAggregateInput
    _min?: ApprovalStepMinOrderByAggregateInput
    _sum?: ApprovalStepSumOrderByAggregateInput
  }

  export type ApprovalStepScalarWhereWithAggregatesInput = {
    AND?: ApprovalStepScalarWhereWithAggregatesInput | ApprovalStepScalarWhereWithAggregatesInput[]
    OR?: ApprovalStepScalarWhereWithAggregatesInput[]
    NOT?: ApprovalStepScalarWhereWithAggregatesInput | ApprovalStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApprovalStep"> | string
    approvalTemplateId?: StringWithAggregatesFilter<"ApprovalStep"> | string
    stepNumber?: IntWithAggregatesFilter<"ApprovalStep"> | number
    approverType?: EnumApproverTypeWithAggregatesFilter<"ApprovalStep"> | $Enums.ApproverType
    approverId?: StringNullableWithAggregatesFilter<"ApprovalStep"> | string | null
    backup1Id?: StringNullableWithAggregatesFilter<"ApprovalStep"> | string | null
    backup2Id?: StringNullableWithAggregatesFilter<"ApprovalStep"> | string | null
    timeLimit?: IntNullableWithAggregatesFilter<"ApprovalStep"> | number | null
  }

  export type ApprovalWhereInput = {
    AND?: ApprovalWhereInput | ApprovalWhereInput[]
    OR?: ApprovalWhereInput[]
    NOT?: ApprovalWhereInput | ApprovalWhereInput[]
    id?: StringFilter<"Approval"> | string
    workspaceId?: StringFilter<"Approval"> | string
    templateId?: StringFilter<"Approval"> | string
    entityType?: StringFilter<"Approval"> | string
    entityId?: StringFilter<"Approval"> | string
    requesterId?: StringFilter<"Approval"> | string
    currentStep?: IntFilter<"Approval"> | number
    status?: EnumApprovalStatusFilter<"Approval"> | $Enums.ApprovalStatus
    leaveId?: StringNullableFilter<"Approval"> | string | null
    overtimeId?: StringNullableFilter<"Approval"> | string | null
    createdAt?: DateTimeFilter<"Approval"> | Date | string
    updatedAt?: DateTimeFilter<"Approval"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    template?: XOR<ApprovalTemplateScalarRelationFilter, ApprovalTemplateWhereInput>
    leave?: XOR<LeaveNullableScalarRelationFilter, LeaveWhereInput> | null
    overtime?: XOR<OvertimeNullableScalarRelationFilter, OvertimeWhereInput> | null
    actions?: ApprovalActionListRelationFilter
  }

  export type ApprovalOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    templateId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    requesterId?: SortOrder
    currentStep?: SortOrder
    status?: SortOrder
    leaveId?: SortOrderInput | SortOrder
    overtimeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    template?: ApprovalTemplateOrderByWithRelationInput
    leave?: LeaveOrderByWithRelationInput
    overtime?: OvertimeOrderByWithRelationInput
    actions?: ApprovalActionOrderByRelationAggregateInput
  }

  export type ApprovalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    leaveId?: string
    overtimeId?: string
    AND?: ApprovalWhereInput | ApprovalWhereInput[]
    OR?: ApprovalWhereInput[]
    NOT?: ApprovalWhereInput | ApprovalWhereInput[]
    workspaceId?: StringFilter<"Approval"> | string
    templateId?: StringFilter<"Approval"> | string
    entityType?: StringFilter<"Approval"> | string
    entityId?: StringFilter<"Approval"> | string
    requesterId?: StringFilter<"Approval"> | string
    currentStep?: IntFilter<"Approval"> | number
    status?: EnumApprovalStatusFilter<"Approval"> | $Enums.ApprovalStatus
    createdAt?: DateTimeFilter<"Approval"> | Date | string
    updatedAt?: DateTimeFilter<"Approval"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    template?: XOR<ApprovalTemplateScalarRelationFilter, ApprovalTemplateWhereInput>
    leave?: XOR<LeaveNullableScalarRelationFilter, LeaveWhereInput> | null
    overtime?: XOR<OvertimeNullableScalarRelationFilter, OvertimeWhereInput> | null
    actions?: ApprovalActionListRelationFilter
  }, "id" | "leaveId" | "overtimeId">

  export type ApprovalOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    templateId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    requesterId?: SortOrder
    currentStep?: SortOrder
    status?: SortOrder
    leaveId?: SortOrderInput | SortOrder
    overtimeId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApprovalCountOrderByAggregateInput
    _avg?: ApprovalAvgOrderByAggregateInput
    _max?: ApprovalMaxOrderByAggregateInput
    _min?: ApprovalMinOrderByAggregateInput
    _sum?: ApprovalSumOrderByAggregateInput
  }

  export type ApprovalScalarWhereWithAggregatesInput = {
    AND?: ApprovalScalarWhereWithAggregatesInput | ApprovalScalarWhereWithAggregatesInput[]
    OR?: ApprovalScalarWhereWithAggregatesInput[]
    NOT?: ApprovalScalarWhereWithAggregatesInput | ApprovalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Approval"> | string
    workspaceId?: StringWithAggregatesFilter<"Approval"> | string
    templateId?: StringWithAggregatesFilter<"Approval"> | string
    entityType?: StringWithAggregatesFilter<"Approval"> | string
    entityId?: StringWithAggregatesFilter<"Approval"> | string
    requesterId?: StringWithAggregatesFilter<"Approval"> | string
    currentStep?: IntWithAggregatesFilter<"Approval"> | number
    status?: EnumApprovalStatusWithAggregatesFilter<"Approval"> | $Enums.ApprovalStatus
    leaveId?: StringNullableWithAggregatesFilter<"Approval"> | string | null
    overtimeId?: StringNullableWithAggregatesFilter<"Approval"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Approval"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Approval"> | Date | string
  }

  export type ApprovalActionWhereInput = {
    AND?: ApprovalActionWhereInput | ApprovalActionWhereInput[]
    OR?: ApprovalActionWhereInput[]
    NOT?: ApprovalActionWhereInput | ApprovalActionWhereInput[]
    id?: StringFilter<"ApprovalAction"> | string
    approvalId?: StringFilter<"ApprovalAction"> | string
    userId?: StringFilter<"ApprovalAction"> | string
    step?: IntFilter<"ApprovalAction"> | number
    action?: StringFilter<"ApprovalAction"> | string
    comment?: StringNullableFilter<"ApprovalAction"> | string | null
    createdAt?: DateTimeFilter<"ApprovalAction"> | Date | string
    approval?: XOR<ApprovalScalarRelationFilter, ApprovalWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ApprovalActionOrderByWithRelationInput = {
    id?: SortOrder
    approvalId?: SortOrder
    userId?: SortOrder
    step?: SortOrder
    action?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    approval?: ApprovalOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ApprovalActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApprovalActionWhereInput | ApprovalActionWhereInput[]
    OR?: ApprovalActionWhereInput[]
    NOT?: ApprovalActionWhereInput | ApprovalActionWhereInput[]
    approvalId?: StringFilter<"ApprovalAction"> | string
    userId?: StringFilter<"ApprovalAction"> | string
    step?: IntFilter<"ApprovalAction"> | number
    action?: StringFilter<"ApprovalAction"> | string
    comment?: StringNullableFilter<"ApprovalAction"> | string | null
    createdAt?: DateTimeFilter<"ApprovalAction"> | Date | string
    approval?: XOR<ApprovalScalarRelationFilter, ApprovalWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ApprovalActionOrderByWithAggregationInput = {
    id?: SortOrder
    approvalId?: SortOrder
    userId?: SortOrder
    step?: SortOrder
    action?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ApprovalActionCountOrderByAggregateInput
    _avg?: ApprovalActionAvgOrderByAggregateInput
    _max?: ApprovalActionMaxOrderByAggregateInput
    _min?: ApprovalActionMinOrderByAggregateInput
    _sum?: ApprovalActionSumOrderByAggregateInput
  }

  export type ApprovalActionScalarWhereWithAggregatesInput = {
    AND?: ApprovalActionScalarWhereWithAggregatesInput | ApprovalActionScalarWhereWithAggregatesInput[]
    OR?: ApprovalActionScalarWhereWithAggregatesInput[]
    NOT?: ApprovalActionScalarWhereWithAggregatesInput | ApprovalActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApprovalAction"> | string
    approvalId?: StringWithAggregatesFilter<"ApprovalAction"> | string
    userId?: StringWithAggregatesFilter<"ApprovalAction"> | string
    step?: IntWithAggregatesFilter<"ApprovalAction"> | number
    action?: StringWithAggregatesFilter<"ApprovalAction"> | string
    comment?: StringNullableWithAggregatesFilter<"ApprovalAction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ApprovalAction"> | Date | string
  }

  export type SettingsWhereInput = {
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    id?: StringFilter<"Settings"> | string
    workspaceId?: StringFilter<"Settings"> | string
    category?: StringFilter<"Settings"> | string
    key?: StringFilter<"Settings"> | string
    value?: StringFilter<"Settings"> | string
    createdAt?: DateTimeFilter<"Settings"> | Date | string
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type SettingsOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    category?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type SettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspaceId_category_key?: SettingsWorkspaceIdCategoryKeyCompoundUniqueInput
    AND?: SettingsWhereInput | SettingsWhereInput[]
    OR?: SettingsWhereInput[]
    NOT?: SettingsWhereInput | SettingsWhereInput[]
    workspaceId?: StringFilter<"Settings"> | string
    category?: StringFilter<"Settings"> | string
    key?: StringFilter<"Settings"> | string
    value?: StringFilter<"Settings"> | string
    createdAt?: DateTimeFilter<"Settings"> | Date | string
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id" | "workspaceId_category_key">

  export type SettingsOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    category?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingsCountOrderByAggregateInput
    _max?: SettingsMaxOrderByAggregateInput
    _min?: SettingsMinOrderByAggregateInput
  }

  export type SettingsScalarWhereWithAggregatesInput = {
    AND?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    OR?: SettingsScalarWhereWithAggregatesInput[]
    NOT?: SettingsScalarWhereWithAggregatesInput | SettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Settings"> | string
    workspaceId?: StringWithAggregatesFilter<"Settings"> | string
    category?: StringWithAggregatesFilter<"Settings"> | string
    key?: StringWithAggregatesFilter<"Settings"> | string
    value?: StringWithAggregatesFilter<"Settings"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Settings"> | Date | string
  }

  export type UserConsentWhereInput = {
    AND?: UserConsentWhereInput | UserConsentWhereInput[]
    OR?: UserConsentWhereInput[]
    NOT?: UserConsentWhereInput | UserConsentWhereInput[]
    id?: StringFilter<"UserConsent"> | string
    userId?: StringFilter<"UserConsent"> | string
    purpose?: StringFilter<"UserConsent"> | string
    consentGiven?: BoolFilter<"UserConsent"> | boolean
    timestamp?: DateTimeFilter<"UserConsent"> | Date | string
    ipAddress?: StringNullableFilter<"UserConsent"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserConsentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    purpose?: SortOrder
    consentGiven?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserConsentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserConsentWhereInput | UserConsentWhereInput[]
    OR?: UserConsentWhereInput[]
    NOT?: UserConsentWhereInput | UserConsentWhereInput[]
    userId?: StringFilter<"UserConsent"> | string
    purpose?: StringFilter<"UserConsent"> | string
    consentGiven?: BoolFilter<"UserConsent"> | boolean
    timestamp?: DateTimeFilter<"UserConsent"> | Date | string
    ipAddress?: StringNullableFilter<"UserConsent"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UserConsentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    purpose?: SortOrder
    consentGiven?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    _count?: UserConsentCountOrderByAggregateInput
    _max?: UserConsentMaxOrderByAggregateInput
    _min?: UserConsentMinOrderByAggregateInput
  }

  export type UserConsentScalarWhereWithAggregatesInput = {
    AND?: UserConsentScalarWhereWithAggregatesInput | UserConsentScalarWhereWithAggregatesInput[]
    OR?: UserConsentScalarWhereWithAggregatesInput[]
    NOT?: UserConsentScalarWhereWithAggregatesInput | UserConsentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserConsent"> | string
    userId?: StringWithAggregatesFilter<"UserConsent"> | string
    purpose?: StringWithAggregatesFilter<"UserConsent"> | string
    consentGiven?: BoolWithAggregatesFilter<"UserConsent"> | boolean
    timestamp?: DateTimeWithAggregatesFilter<"UserConsent"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"UserConsent"> | string | null
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    entity?: StringFilter<"ActivityLog"> | string
    entityId?: StringFilter<"ActivityLog"> | string
    details?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    userId?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    entity?: StringFilter<"ActivityLog"> | string
    entityId?: StringFilter<"ActivityLog"> | string
    details?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLog"> | string
    userId?: StringWithAggregatesFilter<"ActivityLog"> | string
    action?: StringWithAggregatesFilter<"ActivityLog"> | string
    entity?: StringWithAggregatesFilter<"ActivityLog"> | string
    entityId?: StringWithAggregatesFilter<"ActivityLog"> | string
    details?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    workspaceId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    workspaceId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrderInput | SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    workspaceId?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringWithAggregatesFilter<"AuditLog"> | string
    resourceId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    details?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type InvitationWhereInput = {
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    id?: StringFilter<"Invitation"> | string
    workspaceId?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    code?: StringFilter<"Invitation"> | string
    type?: EnumInvitationTypeFilter<"Invitation"> | $Enums.InvitationType
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    data?: StringNullableFilter<"Invitation"> | string | null
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
    updatedAt?: DateTimeFilter<"Invitation"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type InvitationOrderByWithRelationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    code?: SortOrder
    type?: SortOrder
    status?: SortOrder
    data?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type InvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    workspaceId?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    code?: StringFilter<"Invitation"> | string
    type?: EnumInvitationTypeFilter<"Invitation"> | $Enums.InvitationType
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    data?: StringNullableFilter<"Invitation"> | string | null
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
    updatedAt?: DateTimeFilter<"Invitation"> | Date | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id">

  export type InvitationOrderByWithAggregationInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    code?: SortOrder
    type?: SortOrder
    status?: SortOrder
    data?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvitationCountOrderByAggregateInput
    _max?: InvitationMaxOrderByAggregateInput
    _min?: InvitationMinOrderByAggregateInput
  }

  export type InvitationScalarWhereWithAggregatesInput = {
    AND?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    OR?: InvitationScalarWhereWithAggregatesInput[]
    NOT?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invitation"> | string
    workspaceId?: StringWithAggregatesFilter<"Invitation"> | string
    email?: StringWithAggregatesFilter<"Invitation"> | string
    code?: StringWithAggregatesFilter<"Invitation"> | string
    type?: EnumInvitationTypeWithAggregatesFilter<"Invitation"> | $Enums.InvitationType
    status?: EnumInvitationStatusWithAggregatesFilter<"Invitation"> | $Enums.InvitationStatus
    data?: StringNullableWithAggregatesFilter<"Invitation"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    workspaceMember?: WorkspaceMemberCreateNestedManyWithoutUserInput
    approvalActions?: ApprovalActionCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    workspaceMember?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    approvalActions?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    workspaceMember?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    approvalActions?: ApprovalActionUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    workspaceMember?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    approvalActions?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkspaceCreateInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateManyInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceMemberCreateInput = {
    id?: string
    role: $Enums.MemberRole
    joinedAt?: Date | string
    invitedBy?: string | null
    status?: $Enums.MemberStatus
    workspace: WorkspaceCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutWorkspaceMemberInput
  }

  export type WorkspaceMemberUncheckedCreateInput = {
    id?: string
    workspaceId: string
    userId: string
    role: $Enums.MemberRole
    joinedAt?: Date | string
    invitedBy?: string | null
    status?: $Enums.MemberStatus
  }

  export type WorkspaceMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    workspace?: WorkspaceUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutWorkspaceMemberNestedInput
  }

  export type WorkspaceMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
  }

  export type WorkspaceMemberCreateManyInput = {
    id?: string
    workspaceId: string
    userId: string
    role: $Enums.MemberRole
    joinedAt?: Date | string
    invitedBy?: string | null
    status?: $Enums.MemberStatus
  }

  export type WorkspaceMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
  }

  export type WorkspaceMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    managerId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutDepartmentsInput
    teams?: TeamCreateNestedManyWithoutDepartmentInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
    parent?: DepartmentCreateNestedOneWithoutChildrenInput
    children?: DepartmentCreateNestedManyWithoutParentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    code?: string | null
    description?: string | null
    managerId?: string | null
    parentId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutDepartmentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    children?: DepartmentUncheckedCreateNestedManyWithoutParentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutDepartmentsNestedInput
    teams?: TeamUpdateManyWithoutDepartmentNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
    parent?: DepartmentUpdateOneWithoutChildrenNestedInput
    children?: DepartmentUpdateManyWithoutParentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutDepartmentNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
    children?: DepartmentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    code?: string | null
    description?: string | null
    managerId?: string | null
    parentId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    description?: string | null
    leaderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutTeamsInput
    department: DepartmentCreateNestedOneWithoutTeamsInput
    employees?: EmployeeCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    workspaceId: string
    departmentId: string
    name: string
    description?: string | null
    leaderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutTeamsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutTeamsNestedInput
    employees?: EmployeeUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    workspaceId: string
    departmentId: string
    name: string
    description?: string | null
    leaderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionCreateInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutPositionsInput
    employees?: EmployeeCreateNestedManyWithoutPositionInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    code?: string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutPositionInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutPositionsNestedInput
    employees?: EmployeeUpdateManyWithoutPositionNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutPositionNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    code?: string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionLevelCreateInput = {
    id?: string
    name: string
    level: number
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutPositionLevelsInput
    employees?: EmployeeCreateNestedManyWithoutPositionLevelInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutPositionLevelInput
  }

  export type PositionLevelUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    level: number
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutPositionLevelInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutPositionLevelInput
  }

  export type PositionLevelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutPositionLevelsNestedInput
    employees?: EmployeeUpdateManyWithoutPositionLevelNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutPositionLevelNestedInput
  }

  export type PositionLevelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutPositionLevelNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutPositionLevelNestedInput
  }

  export type PositionLevelCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    level: number
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionLevelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionLevelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    id?: string
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeeInput
    workspace: WorkspaceCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    positionLevel?: PositionLevelCreateNestedOneWithoutEmployeesInput
    manager?: EmployeeCreateNestedOneWithoutSubordinatesInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeeNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    positionLevel?: PositionLevelUpdateOneWithoutEmployeesNestedInput
    manager?: EmployeeUpdateOneWithoutSubordinatesNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentHistoryCreateInput = {
    id?: string
    departmentId?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutEmploymentHistoryInput
    position: PositionCreateNestedOneWithoutEmploymentHistoryInput
    positionLevel?: PositionLevelCreateNestedOneWithoutEmploymentHistoryInput
  }

  export type EmploymentHistoryUncheckedCreateInput = {
    id?: string
    employeeId: string
    positionId: string
    positionLevelId?: string | null
    departmentId?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmploymentHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutEmploymentHistoryNestedInput
    position?: PositionUpdateOneRequiredWithoutEmploymentHistoryNestedInput
    positionLevel?: PositionLevelUpdateOneWithoutEmploymentHistoryNestedInput
  }

  export type EmploymentHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentHistoryCreateManyInput = {
    id?: string
    employeeId: string
    positionId: string
    positionLevelId?: string | null
    departmentId?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmploymentHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeDocumentCreateInput = {
    id?: string
    type: string
    name: string
    filename: string
    mimeType: string
    size: number
    url: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutDocumentsInput
  }

  export type EmployeeDocumentUncheckedCreateInput = {
    id?: string
    employeeId: string
    type: string
    name: string
    filename: string
    mimeType: string
    size: number
    url: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type EmployeeDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeDocumentCreateManyInput = {
    id?: string
    employeeId: string
    type: string
    name: string
    filename: string
    mimeType: string
    size: number
    url: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.ProjectStatus
    priority?: $Enums.ProjectPriority
    managerId?: string | null
    clientName?: string | null
    clientContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    code?: string | null
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.ProjectStatus
    priority?: $Enums.ProjectPriority
    managerId?: string | null
    clientName?: string | null
    clientContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumProjectPriorityFieldUpdateOperationsInput | $Enums.ProjectPriority
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    clientContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumProjectPriorityFieldUpdateOperationsInput | $Enums.ProjectPriority
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    clientContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    code?: string | null
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.ProjectStatus
    priority?: $Enums.ProjectPriority
    managerId?: string | null
    clientName?: string | null
    clientContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumProjectPriorityFieldUpdateOperationsInput | $Enums.ProjectPriority
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    clientContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumProjectPriorityFieldUpdateOperationsInput | $Enums.ProjectPriority
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    clientContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateInput = {
    id?: string
    allocation?: number
    startDate?: Date | string
    endDate?: Date | string | null
    project: ProjectCreateNestedOneWithoutMembersInput
    employee: EmployeeCreateNestedOneWithoutProjectMembersInput
    projectRole: ProjectRoleCreateNestedOneWithoutProjectMembersInput
  }

  export type ProjectMemberUncheckedCreateInput = {
    id?: string
    projectId: string
    employeeId: string
    roleId: string
    allocation?: number
    startDate?: Date | string
    endDate?: Date | string | null
  }

  export type ProjectMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocation?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutProjectMembersNestedInput
    projectRole?: ProjectRoleUpdateOneRequiredWithoutProjectMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    allocation?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectMemberCreateManyInput = {
    id?: string
    projectId: string
    employeeId: string
    roleId: string
    allocation?: number
    startDate?: Date | string
    endDate?: Date | string | null
  }

  export type ProjectMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocation?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    allocation?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectRoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace?: WorkspaceCreateNestedOneWithoutProjectRolesInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutProjectRoleInput
  }

  export type ProjectRoleUncheckedCreateInput = {
    id?: string
    workspaceId?: string | null
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutProjectRoleInput
  }

  export type ProjectRoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneWithoutProjectRolesNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutProjectRoleNestedInput
  }

  export type ProjectRoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutProjectRoleNestedInput
  }

  export type ProjectRoleCreateManyInput = {
    id?: string
    workspaceId?: string | null
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectRoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectRoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveTypeCreateInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    color?: string | null
    isPaid?: boolean
    requiresApproval?: boolean
    requiresAttachment?: boolean
    maxDaysPerYear?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutLeaveTypesInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutLeaveTypeInput
    leaves?: LeaveCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    code: string
    description?: string | null
    color?: string | null
    isPaid?: boolean
    requiresApproval?: boolean
    requiresAttachment?: boolean
    maxDaysPerYear?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutLeaveTypeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    requiresAttachment?: BoolFieldUpdateOperationsInput | boolean
    maxDaysPerYear?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutLeaveTypesNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutLeaveTypeNestedInput
    leaves?: LeaveUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    requiresAttachment?: BoolFieldUpdateOperationsInput | boolean
    maxDaysPerYear?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutLeaveTypeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    code: string
    description?: string | null
    color?: string | null
    isPaid?: boolean
    requiresApproval?: boolean
    requiresAttachment?: boolean
    maxDaysPerYear?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    requiresAttachment?: BoolFieldUpdateOperationsInput | boolean
    maxDaysPerYear?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    requiresAttachment?: BoolFieldUpdateOperationsInput | boolean
    maxDaysPerYear?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveQuotaCreateInput = {
    id?: string
    year: number
    total: number
    used?: number
    pending?: number
    remaining: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutLeaveQuotasInput
    employee: EmployeeCreateNestedOneWithoutLeaveQuotasInput
    leaveType: LeaveTypeCreateNestedOneWithoutLeaveQuotasInput
  }

  export type LeaveQuotaUncheckedCreateInput = {
    id?: string
    workspaceId: string
    employeeId: string
    leaveTypeId: string
    year: number
    total: number
    used?: number
    pending?: number
    remaining: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveQuotaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutLeaveQuotasNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLeaveQuotasNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutLeaveQuotasNestedInput
  }

  export type LeaveQuotaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveQuotaCreateManyInput = {
    id?: string
    workspaceId: string
    employeeId: string
    leaveTypeId: string
    year: number
    total: number
    used?: number
    pending?: number
    remaining: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveQuotaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveQuotaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    halfDay?: boolean
    duration: number
    reason?: string | null
    attachment?: string | null
    status?: $Enums.LeaveStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutLeavesInput
    employee: EmployeeCreateNestedOneWithoutLeavesInput
    leaveType: LeaveTypeCreateNestedOneWithoutLeavesInput
    approval?: ApprovalCreateNestedOneWithoutLeaveInput
  }

  export type LeaveUncheckedCreateInput = {
    id?: string
    workspaceId: string
    employeeId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    halfDay?: boolean
    duration: number
    reason?: string | null
    attachment?: string | null
    status?: $Enums.LeaveStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approval?: ApprovalUncheckedCreateNestedOneWithoutLeaveInput
  }

  export type LeaveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    halfDay?: BoolFieldUpdateOperationsInput | boolean
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutLeavesNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLeavesNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutLeavesNestedInput
    approval?: ApprovalUpdateOneWithoutLeaveNestedInput
  }

  export type LeaveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    halfDay?: BoolFieldUpdateOperationsInput | boolean
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approval?: ApprovalUncheckedUpdateOneWithoutLeaveNestedInput
  }

  export type LeaveCreateManyInput = {
    id?: string
    workspaceId: string
    employeeId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    halfDay?: boolean
    duration: number
    reason?: string | null
    attachment?: string | null
    status?: $Enums.LeaveStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    halfDay?: BoolFieldUpdateOperationsInput | boolean
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    halfDay?: BoolFieldUpdateOperationsInput | boolean
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimePolicyCreateInput = {
    id?: string
    name: string
    description?: string | null
    rate: number
    minimumHours?: number
    maximumHours?: number | null
    requiresApproval?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutOvertimePoliciesInput
    overtimes?: OvertimeCreateNestedManyWithoutOvertimePolicyInput
  }

  export type OvertimePolicyUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    rate: number
    minimumHours?: number
    maximumHours?: number | null
    requiresApproval?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutOvertimePolicyInput
  }

  export type OvertimePolicyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    minimumHours?: FloatFieldUpdateOperationsInput | number
    maximumHours?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutOvertimePoliciesNestedInput
    overtimes?: OvertimeUpdateManyWithoutOvertimePolicyNestedInput
  }

  export type OvertimePolicyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    minimumHours?: FloatFieldUpdateOperationsInput | number
    maximumHours?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overtimes?: OvertimeUncheckedUpdateManyWithoutOvertimePolicyNestedInput
  }

  export type OvertimePolicyCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    rate: number
    minimumHours?: number
    maximumHours?: number | null
    requiresApproval?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimePolicyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    minimumHours?: FloatFieldUpdateOperationsInput | number
    maximumHours?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimePolicyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    minimumHours?: FloatFieldUpdateOperationsInput | number
    maximumHours?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeCreateInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    hours: number
    reason: string
    status?: $Enums.OvertimeStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutOvertimesInput
    employee: EmployeeCreateNestedOneWithoutOvertimesInput
    overtimePolicy: OvertimePolicyCreateNestedOneWithoutOvertimesInput
    approval?: ApprovalCreateNestedOneWithoutOvertimeInput
  }

  export type OvertimeUncheckedCreateInput = {
    id?: string
    workspaceId: string
    employeeId: string
    policyId: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    hours: number
    reason: string
    status?: $Enums.OvertimeStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approval?: ApprovalUncheckedCreateNestedOneWithoutOvertimeInput
  }

  export type OvertimeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutOvertimesNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutOvertimesNestedInput
    overtimePolicy?: OvertimePolicyUpdateOneRequiredWithoutOvertimesNestedInput
    approval?: ApprovalUpdateOneWithoutOvertimeNestedInput
  }

  export type OvertimeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approval?: ApprovalUncheckedUpdateOneWithoutOvertimeNestedInput
  }

  export type OvertimeCreateManyInput = {
    id?: string
    workspaceId: string
    employeeId: string
    policyId: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    hours: number
    reason: string
    status?: $Enums.OvertimeStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    entityType: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutApprovalTemplatesInput
    steps?: ApprovalStepCreateNestedManyWithoutApprovalTemplateInput
    approvals?: ApprovalCreateNestedManyWithoutTemplateInput
  }

  export type ApprovalTemplateUncheckedCreateInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    entityType: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: ApprovalStepUncheckedCreateNestedManyWithoutApprovalTemplateInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type ApprovalTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutApprovalTemplatesNestedInput
    steps?: ApprovalStepUpdateManyWithoutApprovalTemplateNestedInput
    approvals?: ApprovalUpdateManyWithoutTemplateNestedInput
  }

  export type ApprovalTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: ApprovalStepUncheckedUpdateManyWithoutApprovalTemplateNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type ApprovalTemplateCreateManyInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    entityType: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalStepCreateInput = {
    id?: string
    stepNumber: number
    approverType: $Enums.ApproverType
    approverId?: string | null
    backup1Id?: string | null
    backup2Id?: string | null
    timeLimit?: number | null
    approvalTemplate: ApprovalTemplateCreateNestedOneWithoutStepsInput
  }

  export type ApprovalStepUncheckedCreateInput = {
    id?: string
    approvalTemplateId: string
    stepNumber: number
    approverType: $Enums.ApproverType
    approverId?: string | null
    backup1Id?: string | null
    backup2Id?: string | null
    timeLimit?: number | null
  }

  export type ApprovalStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    backup1Id?: NullableStringFieldUpdateOperationsInput | string | null
    backup2Id?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
    approvalTemplate?: ApprovalTemplateUpdateOneRequiredWithoutStepsNestedInput
  }

  export type ApprovalStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approvalTemplateId?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    backup1Id?: NullableStringFieldUpdateOperationsInput | string | null
    backup2Id?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ApprovalStepCreateManyInput = {
    id?: string
    approvalTemplateId: string
    stepNumber: number
    approverType: $Enums.ApproverType
    approverId?: string | null
    backup1Id?: string | null
    backup2Id?: string | null
    timeLimit?: number | null
  }

  export type ApprovalStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    backup1Id?: NullableStringFieldUpdateOperationsInput | string | null
    backup2Id?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ApprovalStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    approvalTemplateId?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    backup1Id?: NullableStringFieldUpdateOperationsInput | string | null
    backup2Id?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ApprovalCreateInput = {
    id?: string
    entityType: string
    entityId: string
    requesterId: string
    currentStep?: number
    status?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutApprovalsInput
    template: ApprovalTemplateCreateNestedOneWithoutApprovalsInput
    leave?: LeaveCreateNestedOneWithoutApprovalInput
    overtime?: OvertimeCreateNestedOneWithoutApprovalInput
    actions?: ApprovalActionCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalUncheckedCreateInput = {
    id?: string
    workspaceId: string
    templateId: string
    entityType: string
    entityId: string
    requesterId: string
    currentStep?: number
    status?: $Enums.ApprovalStatus
    leaveId?: string | null
    overtimeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: ApprovalActionUncheckedCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutApprovalsNestedInput
    template?: ApprovalTemplateUpdateOneRequiredWithoutApprovalsNestedInput
    leave?: LeaveUpdateOneWithoutApprovalNestedInput
    overtime?: OvertimeUpdateOneWithoutApprovalNestedInput
    actions?: ApprovalActionUpdateManyWithoutApprovalNestedInput
  }

  export type ApprovalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    leaveId?: NullableStringFieldUpdateOperationsInput | string | null
    overtimeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: ApprovalActionUncheckedUpdateManyWithoutApprovalNestedInput
  }

  export type ApprovalCreateManyInput = {
    id?: string
    workspaceId: string
    templateId: string
    entityType: string
    entityId: string
    requesterId: string
    currentStep?: number
    status?: $Enums.ApprovalStatus
    leaveId?: string | null
    overtimeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    leaveId?: NullableStringFieldUpdateOperationsInput | string | null
    overtimeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalActionCreateInput = {
    id?: string
    step: number
    action: string
    comment?: string | null
    createdAt?: Date | string
    approval: ApprovalCreateNestedOneWithoutActionsInput
    user: UserCreateNestedOneWithoutApprovalActionsInput
  }

  export type ApprovalActionUncheckedCreateInput = {
    id?: string
    approvalId: string
    userId: string
    step: number
    action: string
    comment?: string | null
    createdAt?: Date | string
  }

  export type ApprovalActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approval?: ApprovalUpdateOneRequiredWithoutActionsNestedInput
    user?: UserUpdateOneRequiredWithoutApprovalActionsNestedInput
  }

  export type ApprovalActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    approvalId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalActionCreateManyInput = {
    id?: string
    approvalId: string
    userId: string
    step: number
    action: string
    comment?: string | null
    createdAt?: Date | string
  }

  export type ApprovalActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    approvalId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateInput = {
    id?: string
    category: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutSettingsInput
  }

  export type SettingsUncheckedCreateInput = {
    id?: string
    workspaceId: string
    category: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type SettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsCreateManyInput = {
    id?: string
    workspaceId: string
    category: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentCreateInput = {
    id?: string
    purpose: string
    consentGiven: boolean
    timestamp: Date | string
    ipAddress?: string | null
    user: UserCreateNestedOneWithoutConsentsInput
  }

  export type UserConsentUncheckedCreateInput = {
    id?: string
    userId: string
    purpose: string
    consentGiven: boolean
    timestamp: Date | string
    ipAddress?: string | null
  }

  export type UserConsentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    consentGiven?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutConsentsNestedInput
  }

  export type UserConsentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    consentGiven?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserConsentCreateManyInput = {
    id?: string
    userId: string
    purpose: string
    consentGiven: boolean
    timestamp: Date | string
    ipAddress?: string | null
  }

  export type UserConsentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    consentGiven?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserConsentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    consentGiven?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityLogCreateInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    details?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    entity: string
    entityId: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutAuditLogsInput
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    workspaceId: string
    userId: string
    action: string
    resource: string
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutAuditLogsNestedInput
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    workspaceId: string
    userId: string
    action: string
    resource: string
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateInput = {
    id?: string
    email: string
    code: string
    type: $Enums.InvitationType
    status?: $Enums.InvitationStatus
    data?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateInput = {
    id?: string
    workspaceId: string
    email: string
    code: string
    type: $Enums.InvitationType
    status?: $Enums.InvitationStatus
    data?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumInvitationTypeFieldUpdateOperationsInput | $Enums.InvitationType
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    data?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumInvitationTypeFieldUpdateOperationsInput | $Enums.InvitationType
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    data?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateManyInput = {
    id?: string
    workspaceId: string
    email: string
    code: string
    type: $Enums.InvitationType
    status?: $Enums.InvitationStatus
    data?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumInvitationTypeFieldUpdateOperationsInput | $Enums.InvitationType
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    data?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumInvitationTypeFieldUpdateOperationsInput | $Enums.InvitationType
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    data?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type WorkspaceMemberListRelationFilter = {
    every?: WorkspaceMemberWhereInput
    some?: WorkspaceMemberWhereInput
    none?: WorkspaceMemberWhereInput
  }

  export type ApprovalActionListRelationFilter = {
    every?: ApprovalActionWhereInput
    some?: ApprovalActionWhereInput
    none?: ApprovalActionWhereInput
  }

  export type UserConsentListRelationFilter = {
    every?: UserConsentWhereInput
    some?: UserConsentWhereInput
    none?: UserConsentWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApprovalActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserConsentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    password?: SortOrder
    image?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type EnumWorkspaceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceStatus | EnumWorkspaceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceStatus[] | ListEnumWorkspaceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceStatus[] | ListEnumWorkspaceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceStatusFilter<$PrismaModel> | $Enums.WorkspaceStatus
  }

  export type EnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type PositionListRelationFilter = {
    every?: PositionWhereInput
    some?: PositionWhereInput
    none?: PositionWhereInput
  }

  export type PositionLevelListRelationFilter = {
    every?: PositionLevelWhereInput
    some?: PositionLevelWhereInput
    none?: PositionLevelWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ProjectRoleListRelationFilter = {
    every?: ProjectRoleWhereInput
    some?: ProjectRoleWhereInput
    none?: ProjectRoleWhereInput
  }

  export type LeaveTypeListRelationFilter = {
    every?: LeaveTypeWhereInput
    some?: LeaveTypeWhereInput
    none?: LeaveTypeWhereInput
  }

  export type LeaveQuotaListRelationFilter = {
    every?: LeaveQuotaWhereInput
    some?: LeaveQuotaWhereInput
    none?: LeaveQuotaWhereInput
  }

  export type LeaveListRelationFilter = {
    every?: LeaveWhereInput
    some?: LeaveWhereInput
    none?: LeaveWhereInput
  }

  export type OvertimePolicyListRelationFilter = {
    every?: OvertimePolicyWhereInput
    some?: OvertimePolicyWhereInput
    none?: OvertimePolicyWhereInput
  }

  export type OvertimeListRelationFilter = {
    every?: OvertimeWhereInput
    some?: OvertimeWhereInput
    none?: OvertimeWhereInput
  }

  export type ApprovalTemplateListRelationFilter = {
    every?: ApprovalTemplateWhereInput
    some?: ApprovalTemplateWhereInput
    none?: ApprovalTemplateWhereInput
  }

  export type ApprovalListRelationFilter = {
    every?: ApprovalWhereInput
    some?: ApprovalWhereInput
    none?: ApprovalWhereInput
  }

  export type SettingsListRelationFilter = {
    every?: SettingsWhereInput
    some?: SettingsWhereInput
    none?: SettingsWhereInput
  }

  export type InvitationListRelationFilter = {
    every?: InvitationWhereInput
    some?: InvitationWhereInput
    none?: InvitationWhereInput
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PositionLevelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveQuotaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OvertimePolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OvertimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApprovalTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApprovalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SettingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    taxId?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    contactPerson?: SortOrder
    status?: SortOrder
    planType?: SortOrder
    subscriptionStart?: SortOrder
    subscriptionEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    taxId?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    contactPerson?: SortOrder
    status?: SortOrder
    planType?: SortOrder
    subscriptionStart?: SortOrder
    subscriptionEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    logo?: SortOrder
    address?: SortOrder
    taxId?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    contactPerson?: SortOrder
    status?: SortOrder
    planType?: SortOrder
    subscriptionStart?: SortOrder
    subscriptionEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWorkspaceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceStatus | EnumWorkspaceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceStatus[] | ListEnumWorkspaceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceStatus[] | ListEnumWorkspaceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkspaceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkspaceStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkspaceStatusFilter<$PrismaModel>
  }

  export type EnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type EnumMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleFilter<$PrismaModel> | $Enums.MemberRole
  }

  export type EnumMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusFilter<$PrismaModel> | $Enums.MemberStatus
  }

  export type WorkspaceScalarRelationFilter = {
    is?: WorkspaceWhereInput
    isNot?: WorkspaceWhereInput
  }

  export type WorkspaceMemberWorkspaceIdUserIdCompoundUniqueInput = {
    workspaceId: string
    userId: string
  }

  export type WorkspaceMemberCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrder
    status?: SortOrder
  }

  export type WorkspaceMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrder
    status?: SortOrder
  }

  export type WorkspaceMemberMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    joinedAt?: SortOrder
    invitedBy?: SortOrder
    status?: SortOrder
  }

  export type EnumMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.MemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumMemberRoleFilter<$PrismaModel>
  }

  export type EnumMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.MemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumMemberStatusFilter<$PrismaModel>
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type DepartmentWorkspaceIdCodeCompoundUniqueInput = {
    workspaceId: string
    code: string
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    parentId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    parentId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    parentId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentScalarRelationFilter = {
    is?: DepartmentWhereInput
    isNot?: DepartmentWhereInput
  }

  export type TeamWorkspaceIdDepartmentIdNameCompoundUniqueInput = {
    workspaceId: string
    departmentId: string
    name: string
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    departmentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    leaderId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    departmentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    leaderId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    departmentId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    leaderId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmploymentHistoryListRelationFilter = {
    every?: EmploymentHistoryWhereInput
    some?: EmploymentHistoryWhereInput
    none?: EmploymentHistoryWhereInput
  }

  export type EmploymentHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PositionWorkspaceIdCodeCompoundUniqueInput = {
    workspaceId: string
    code: string
  }

  export type PositionCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PositionLevelWorkspaceIdLevelCompoundUniqueInput = {
    workspaceId: string
    level: number
  }

  export type PositionLevelCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionLevelAvgOrderByAggregateInput = {
    level?: SortOrder
  }

  export type PositionLevelMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionLevelMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    level?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PositionLevelSumOrderByAggregateInput = {
    level?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumEmployeeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeStatus | EnumEmployeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeStatus[] | ListEnumEmployeeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeStatus[] | ListEnumEmployeeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeStatusFilter<$PrismaModel> | $Enums.EmployeeStatus
  }

  export type EnumEmploymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeFilter<$PrismaModel> | $Enums.EmploymentType
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TeamNullableScalarRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type PositionNullableScalarRelationFilter = {
    is?: PositionWhereInput | null
    isNot?: PositionWhereInput | null
  }

  export type PositionLevelNullableScalarRelationFilter = {
    is?: PositionLevelWhereInput | null
    isNot?: PositionLevelWhereInput | null
  }

  export type ProjectMemberListRelationFilter = {
    every?: ProjectMemberWhereInput
    some?: ProjectMemberWhereInput
    none?: ProjectMemberWhereInput
  }

  export type EmployeeDocumentListRelationFilter = {
    every?: EmployeeDocumentWhereInput
    some?: EmployeeDocumentWhereInput
    none?: EmployeeDocumentWhereInput
  }

  export type ProjectMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeWorkspaceIdEmployeeCodeCompoundUniqueInput = {
    workspaceId: string
    employeeCode: string
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    employeeCode?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    thaiFirstName?: SortOrder
    thaiLastName?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    emergencyContact?: SortOrder
    birthdate?: SortOrder
    gender?: SortOrder
    nationalId?: SortOrder
    nationalIdIv?: SortOrder
    passportNumber?: SortOrder
    passportNumberIv?: SortOrder
    address?: SortOrder
    taxId?: SortOrder
    bankAccount?: SortOrder
    bankAccountIv?: SortOrder
    bankName?: SortOrder
    hireDate?: SortOrder
    probationEndDate?: SortOrder
    resignDate?: SortOrder
    departmentId?: SortOrder
    teamId?: SortOrder
    positionId?: SortOrder
    positionLevelId?: SortOrder
    managerId?: SortOrder
    status?: SortOrder
    employmentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    employeeCode?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    thaiFirstName?: SortOrder
    thaiLastName?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    emergencyContact?: SortOrder
    birthdate?: SortOrder
    gender?: SortOrder
    nationalId?: SortOrder
    nationalIdIv?: SortOrder
    passportNumber?: SortOrder
    passportNumberIv?: SortOrder
    address?: SortOrder
    taxId?: SortOrder
    bankAccount?: SortOrder
    bankAccountIv?: SortOrder
    bankName?: SortOrder
    hireDate?: SortOrder
    probationEndDate?: SortOrder
    resignDate?: SortOrder
    departmentId?: SortOrder
    teamId?: SortOrder
    positionId?: SortOrder
    positionLevelId?: SortOrder
    managerId?: SortOrder
    status?: SortOrder
    employmentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    employeeCode?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    thaiFirstName?: SortOrder
    thaiLastName?: SortOrder
    nickname?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    emergencyContact?: SortOrder
    birthdate?: SortOrder
    gender?: SortOrder
    nationalId?: SortOrder
    nationalIdIv?: SortOrder
    passportNumber?: SortOrder
    passportNumberIv?: SortOrder
    address?: SortOrder
    taxId?: SortOrder
    bankAccount?: SortOrder
    bankAccountIv?: SortOrder
    bankName?: SortOrder
    hireDate?: SortOrder
    probationEndDate?: SortOrder
    resignDate?: SortOrder
    departmentId?: SortOrder
    teamId?: SortOrder
    positionId?: SortOrder
    positionLevelId?: SortOrder
    managerId?: SortOrder
    status?: SortOrder
    employmentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEmployeeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeStatus | EnumEmployeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeStatus[] | ListEnumEmployeeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeStatus[] | ListEnumEmployeeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeStatusFilter<$PrismaModel>
    _max?: NestedEnumEmployeeStatusFilter<$PrismaModel>
  }

  export type EnumEmploymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmploymentTypeFilter<$PrismaModel>
    _max?: NestedEnumEmploymentTypeFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type PositionScalarRelationFilter = {
    is?: PositionWhereInput
    isNot?: PositionWhereInput
  }

  export type EmploymentHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    positionId?: SortOrder
    positionLevelId?: SortOrder
    departmentId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    salary?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmploymentHistoryAvgOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type EmploymentHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    positionId?: SortOrder
    positionLevelId?: SortOrder
    departmentId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    salary?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmploymentHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    positionId?: SortOrder
    positionLevelId?: SortOrder
    departmentId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    salary?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmploymentHistorySumOrderByAggregateInput = {
    salary?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EmployeeDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeDocumentAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EmployeeDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    uploadedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeDocumentSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type EnumProjectPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectPriority | EnumProjectPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectPriority[] | ListEnumProjectPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectPriority[] | ListEnumProjectPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectPriorityFilter<$PrismaModel> | $Enums.ProjectPriority
  }

  export type ProjectWorkspaceIdCodeCompoundUniqueInput = {
    workspaceId: string
    code: string
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    managerId?: SortOrder
    clientName?: SortOrder
    clientContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    managerId?: SortOrder
    clientName?: SortOrder
    clientContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    budget?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    managerId?: SortOrder
    clientName?: SortOrder
    clientContact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type EnumProjectPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectPriority | EnumProjectPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectPriority[] | ListEnumProjectPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectPriority[] | ListEnumProjectPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectPriorityWithAggregatesFilter<$PrismaModel> | $Enums.ProjectPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectPriorityFilter<$PrismaModel>
    _max?: NestedEnumProjectPriorityFilter<$PrismaModel>
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectRoleScalarRelationFilter = {
    is?: ProjectRoleWhereInput
    isNot?: ProjectRoleWhereInput
  }

  export type ProjectMemberProjectIdEmployeeIdCompoundUniqueInput = {
    projectId: string
    employeeId: string
  }

  export type ProjectMemberCountOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    employeeId?: SortOrder
    roleId?: SortOrder
    allocation?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type ProjectMemberAvgOrderByAggregateInput = {
    allocation?: SortOrder
  }

  export type ProjectMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    employeeId?: SortOrder
    roleId?: SortOrder
    allocation?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type ProjectMemberMinOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    employeeId?: SortOrder
    roleId?: SortOrder
    allocation?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
  }

  export type ProjectMemberSumOrderByAggregateInput = {
    allocation?: SortOrder
  }

  export type WorkspaceNullableScalarRelationFilter = {
    is?: WorkspaceWhereInput | null
    isNot?: WorkspaceWhereInput | null
  }

  export type ProjectRoleWorkspaceIdNameCompoundUniqueInput = {
    workspaceId: string
    name: string
  }

  export type ProjectRoleCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectRoleMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type LeaveTypeWorkspaceIdCodeCompoundUniqueInput = {
    workspaceId: string
    code: string
  }

  export type LeaveTypeCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isPaid?: SortOrder
    requiresApproval?: SortOrder
    requiresAttachment?: SortOrder
    maxDaysPerYear?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveTypeAvgOrderByAggregateInput = {
    maxDaysPerYear?: SortOrder
  }

  export type LeaveTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isPaid?: SortOrder
    requiresApproval?: SortOrder
    requiresAttachment?: SortOrder
    maxDaysPerYear?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveTypeMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    color?: SortOrder
    isPaid?: SortOrder
    requiresApproval?: SortOrder
    requiresAttachment?: SortOrder
    maxDaysPerYear?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveTypeSumOrderByAggregateInput = {
    maxDaysPerYear?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type LeaveTypeScalarRelationFilter = {
    is?: LeaveTypeWhereInput
    isNot?: LeaveTypeWhereInput
  }

  export type LeaveQuotaWorkspaceIdEmployeeIdLeaveTypeIdYearCompoundUniqueInput = {
    workspaceId: string
    employeeId: string
    leaveTypeId: string
    year: number
  }

  export type LeaveQuotaCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    year?: SortOrder
    total?: SortOrder
    used?: SortOrder
    pending?: SortOrder
    remaining?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveQuotaAvgOrderByAggregateInput = {
    year?: SortOrder
    total?: SortOrder
    used?: SortOrder
    pending?: SortOrder
    remaining?: SortOrder
  }

  export type LeaveQuotaMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    year?: SortOrder
    total?: SortOrder
    used?: SortOrder
    pending?: SortOrder
    remaining?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveQuotaMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    year?: SortOrder
    total?: SortOrder
    used?: SortOrder
    pending?: SortOrder
    remaining?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveQuotaSumOrderByAggregateInput = {
    year?: SortOrder
    total?: SortOrder
    used?: SortOrder
    pending?: SortOrder
    remaining?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type ApprovalNullableScalarRelationFilter = {
    is?: ApprovalWhereInput | null
    isNot?: ApprovalWhereInput | null
  }

  export type LeaveCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    halfDay?: SortOrder
    duration?: SortOrder
    reason?: SortOrder
    attachment?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type LeaveMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    halfDay?: SortOrder
    duration?: SortOrder
    reason?: SortOrder
    attachment?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    employeeId?: SortOrder
    leaveTypeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    halfDay?: SortOrder
    duration?: SortOrder
    reason?: SortOrder
    attachment?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type OvertimePolicyWorkspaceIdNameCompoundUniqueInput = {
    workspaceId: string
    name: string
  }

  export type OvertimePolicyCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rate?: SortOrder
    minimumHours?: SortOrder
    maximumHours?: SortOrder
    requiresApproval?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OvertimePolicyAvgOrderByAggregateInput = {
    rate?: SortOrder
    minimumHours?: SortOrder
    maximumHours?: SortOrder
  }

  export type OvertimePolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rate?: SortOrder
    minimumHours?: SortOrder
    maximumHours?: SortOrder
    requiresApproval?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OvertimePolicyMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    rate?: SortOrder
    minimumHours?: SortOrder
    maximumHours?: SortOrder
    requiresApproval?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OvertimePolicySumOrderByAggregateInput = {
    rate?: SortOrder
    minimumHours?: SortOrder
    maximumHours?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumOvertimeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OvertimeStatus | EnumOvertimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OvertimeStatus[] | ListEnumOvertimeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OvertimeStatus[] | ListEnumOvertimeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOvertimeStatusFilter<$PrismaModel> | $Enums.OvertimeStatus
  }

  export type OvertimePolicyScalarRelationFilter = {
    is?: OvertimePolicyWhereInput
    isNot?: OvertimePolicyWhereInput
  }

  export type OvertimeCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    employeeId?: SortOrder
    policyId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    hours?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OvertimeAvgOrderByAggregateInput = {
    hours?: SortOrder
  }

  export type OvertimeMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    employeeId?: SortOrder
    policyId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    hours?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OvertimeMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    employeeId?: SortOrder
    policyId?: SortOrder
    date?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    hours?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OvertimeSumOrderByAggregateInput = {
    hours?: SortOrder
  }

  export type EnumOvertimeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OvertimeStatus | EnumOvertimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OvertimeStatus[] | ListEnumOvertimeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OvertimeStatus[] | ListEnumOvertimeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOvertimeStatusWithAggregatesFilter<$PrismaModel> | $Enums.OvertimeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOvertimeStatusFilter<$PrismaModel>
    _max?: NestedEnumOvertimeStatusFilter<$PrismaModel>
  }

  export type ApprovalStepListRelationFilter = {
    every?: ApprovalStepWhereInput
    some?: ApprovalStepWhereInput
    none?: ApprovalStepWhereInput
  }

  export type ApprovalStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApprovalTemplateWorkspaceIdNameCompoundUniqueInput = {
    workspaceId: string
    name: string
  }

  export type ApprovalTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    entityType?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    entityType?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    entityType?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumApproverTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApproverType | EnumApproverTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApproverType[] | ListEnumApproverTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApproverType[] | ListEnumApproverTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApproverTypeFilter<$PrismaModel> | $Enums.ApproverType
  }

  export type ApprovalTemplateScalarRelationFilter = {
    is?: ApprovalTemplateWhereInput
    isNot?: ApprovalTemplateWhereInput
  }

  export type ApprovalStepApprovalTemplateIdStepNumberCompoundUniqueInput = {
    approvalTemplateId: string
    stepNumber: number
  }

  export type ApprovalStepCountOrderByAggregateInput = {
    id?: SortOrder
    approvalTemplateId?: SortOrder
    stepNumber?: SortOrder
    approverType?: SortOrder
    approverId?: SortOrder
    backup1Id?: SortOrder
    backup2Id?: SortOrder
    timeLimit?: SortOrder
  }

  export type ApprovalStepAvgOrderByAggregateInput = {
    stepNumber?: SortOrder
    timeLimit?: SortOrder
  }

  export type ApprovalStepMaxOrderByAggregateInput = {
    id?: SortOrder
    approvalTemplateId?: SortOrder
    stepNumber?: SortOrder
    approverType?: SortOrder
    approverId?: SortOrder
    backup1Id?: SortOrder
    backup2Id?: SortOrder
    timeLimit?: SortOrder
  }

  export type ApprovalStepMinOrderByAggregateInput = {
    id?: SortOrder
    approvalTemplateId?: SortOrder
    stepNumber?: SortOrder
    approverType?: SortOrder
    approverId?: SortOrder
    backup1Id?: SortOrder
    backup2Id?: SortOrder
    timeLimit?: SortOrder
  }

  export type ApprovalStepSumOrderByAggregateInput = {
    stepNumber?: SortOrder
    timeLimit?: SortOrder
  }

  export type EnumApproverTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApproverType | EnumApproverTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApproverType[] | ListEnumApproverTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApproverType[] | ListEnumApproverTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApproverTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApproverType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApproverTypeFilter<$PrismaModel>
    _max?: NestedEnumApproverTypeFilter<$PrismaModel>
  }

  export type EnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type LeaveNullableScalarRelationFilter = {
    is?: LeaveWhereInput | null
    isNot?: LeaveWhereInput | null
  }

  export type OvertimeNullableScalarRelationFilter = {
    is?: OvertimeWhereInput | null
    isNot?: OvertimeWhereInput | null
  }

  export type ApprovalCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    templateId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    requesterId?: SortOrder
    currentStep?: SortOrder
    status?: SortOrder
    leaveId?: SortOrder
    overtimeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalAvgOrderByAggregateInput = {
    currentStep?: SortOrder
  }

  export type ApprovalMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    templateId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    requesterId?: SortOrder
    currentStep?: SortOrder
    status?: SortOrder
    leaveId?: SortOrder
    overtimeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    templateId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    requesterId?: SortOrder
    currentStep?: SortOrder
    status?: SortOrder
    leaveId?: SortOrder
    overtimeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApprovalSumOrderByAggregateInput = {
    currentStep?: SortOrder
  }

  export type EnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type ApprovalScalarRelationFilter = {
    is?: ApprovalWhereInput
    isNot?: ApprovalWhereInput
  }

  export type ApprovalActionCountOrderByAggregateInput = {
    id?: SortOrder
    approvalId?: SortOrder
    userId?: SortOrder
    step?: SortOrder
    action?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ApprovalActionAvgOrderByAggregateInput = {
    step?: SortOrder
  }

  export type ApprovalActionMaxOrderByAggregateInput = {
    id?: SortOrder
    approvalId?: SortOrder
    userId?: SortOrder
    step?: SortOrder
    action?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ApprovalActionMinOrderByAggregateInput = {
    id?: SortOrder
    approvalId?: SortOrder
    userId?: SortOrder
    step?: SortOrder
    action?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ApprovalActionSumOrderByAggregateInput = {
    step?: SortOrder
  }

  export type SettingsWorkspaceIdCategoryKeyCompoundUniqueInput = {
    workspaceId: string
    category: string
    key: string
  }

  export type SettingsCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    category?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    category?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingsMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    category?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserConsentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    purpose?: SortOrder
    consentGiven?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
  }

  export type UserConsentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    purpose?: SortOrder
    consentGiven?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
  }

  export type UserConsentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    purpose?: SortOrder
    consentGiven?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    resourceId?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumInvitationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationType | EnumInvitationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationType[] | ListEnumInvitationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationType[] | ListEnumInvitationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationTypeFilter<$PrismaModel> | $Enums.InvitationType
  }

  export type EnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type InvitationCountOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    code?: SortOrder
    type?: SortOrder
    status?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    code?: SortOrder
    type?: SortOrder
    status?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvitationMinOrderByAggregateInput = {
    id?: SortOrder
    workspaceId?: SortOrder
    email?: SortOrder
    code?: SortOrder
    type?: SortOrder
    status?: SortOrder
    data?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInvitationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationType | EnumInvitationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationType[] | ListEnumInvitationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationType[] | ListEnumInvitationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvitationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationTypeFilter<$PrismaModel>
    _max?: NestedEnumInvitationTypeFilter<$PrismaModel>
  }

  export type EnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type EmployeeCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ActivityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type WorkspaceMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput> | WorkspaceMemberCreateWithoutUserInput[] | WorkspaceMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutUserInput | WorkspaceMemberCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceMemberCreateManyUserInputEnvelope
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
  }

  export type ApprovalActionCreateNestedManyWithoutUserInput = {
    create?: XOR<ApprovalActionCreateWithoutUserInput, ApprovalActionUncheckedCreateWithoutUserInput> | ApprovalActionCreateWithoutUserInput[] | ApprovalActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutUserInput | ApprovalActionCreateOrConnectWithoutUserInput[]
    createMany?: ApprovalActionCreateManyUserInputEnvelope
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
  }

  export type UserConsentCreateNestedManyWithoutUserInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput> | UserConsentCreateWithoutUserInput[] | UserConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput | UserConsentCreateOrConnectWithoutUserInput[]
    createMany?: UserConsentCreateManyUserInputEnvelope
    connect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput> | WorkspaceMemberCreateWithoutUserInput[] | WorkspaceMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutUserInput | WorkspaceMemberCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceMemberCreateManyUserInputEnvelope
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
  }

  export type ApprovalActionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApprovalActionCreateWithoutUserInput, ApprovalActionUncheckedCreateWithoutUserInput> | ApprovalActionCreateWithoutUserInput[] | ApprovalActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutUserInput | ApprovalActionCreateOrConnectWithoutUserInput[]
    createMany?: ApprovalActionCreateManyUserInputEnvelope
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
  }

  export type UserConsentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput> | UserConsentCreateWithoutUserInput[] | UserConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput | UserConsentCreateOrConnectWithoutUserInput[]
    createMany?: UserConsentCreateManyUserInputEnvelope
    connect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type EmployeeUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type WorkspaceMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput> | WorkspaceMemberCreateWithoutUserInput[] | WorkspaceMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutUserInput | WorkspaceMemberCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceMemberUpsertWithWhereUniqueWithoutUserInput | WorkspaceMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceMemberCreateManyUserInputEnvelope
    set?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    disconnect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    delete?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    update?: WorkspaceMemberUpdateWithWhereUniqueWithoutUserInput | WorkspaceMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceMemberUpdateManyWithWhereWithoutUserInput | WorkspaceMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
  }

  export type ApprovalActionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApprovalActionCreateWithoutUserInput, ApprovalActionUncheckedCreateWithoutUserInput> | ApprovalActionCreateWithoutUserInput[] | ApprovalActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutUserInput | ApprovalActionCreateOrConnectWithoutUserInput[]
    upsert?: ApprovalActionUpsertWithWhereUniqueWithoutUserInput | ApprovalActionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApprovalActionCreateManyUserInputEnvelope
    set?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    disconnect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    delete?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    update?: ApprovalActionUpdateWithWhereUniqueWithoutUserInput | ApprovalActionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApprovalActionUpdateManyWithWhereWithoutUserInput | ApprovalActionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApprovalActionScalarWhereInput | ApprovalActionScalarWhereInput[]
  }

  export type UserConsentUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput> | UserConsentCreateWithoutUserInput[] | UserConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput | UserConsentCreateOrConnectWithoutUserInput[]
    upsert?: UserConsentUpsertWithWhereUniqueWithoutUserInput | UserConsentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserConsentCreateManyUserInputEnvelope
    set?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    disconnect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    delete?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    connect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    update?: UserConsentUpdateWithWhereUniqueWithoutUserInput | UserConsentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserConsentUpdateManyWithWhereWithoutUserInput | UserConsentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserConsentScalarWhereInput | UserConsentScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput> | WorkspaceMemberCreateWithoutUserInput[] | WorkspaceMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutUserInput | WorkspaceMemberCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceMemberUpsertWithWhereUniqueWithoutUserInput | WorkspaceMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceMemberCreateManyUserInputEnvelope
    set?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    disconnect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    delete?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    update?: WorkspaceMemberUpdateWithWhereUniqueWithoutUserInput | WorkspaceMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceMemberUpdateManyWithWhereWithoutUserInput | WorkspaceMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
  }

  export type ApprovalActionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApprovalActionCreateWithoutUserInput, ApprovalActionUncheckedCreateWithoutUserInput> | ApprovalActionCreateWithoutUserInput[] | ApprovalActionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutUserInput | ApprovalActionCreateOrConnectWithoutUserInput[]
    upsert?: ApprovalActionUpsertWithWhereUniqueWithoutUserInput | ApprovalActionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApprovalActionCreateManyUserInputEnvelope
    set?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    disconnect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    delete?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    update?: ApprovalActionUpdateWithWhereUniqueWithoutUserInput | ApprovalActionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApprovalActionUpdateManyWithWhereWithoutUserInput | ApprovalActionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApprovalActionScalarWhereInput | ApprovalActionScalarWhereInput[]
  }

  export type UserConsentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput> | UserConsentCreateWithoutUserInput[] | UserConsentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserConsentCreateOrConnectWithoutUserInput | UserConsentCreateOrConnectWithoutUserInput[]
    upsert?: UserConsentUpsertWithWhereUniqueWithoutUserInput | UserConsentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserConsentCreateManyUserInputEnvelope
    set?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    disconnect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    delete?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    connect?: UserConsentWhereUniqueInput | UserConsentWhereUniqueInput[]
    update?: UserConsentUpdateWithWhereUniqueWithoutUserInput | UserConsentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserConsentUpdateManyWithWhereWithoutUserInput | UserConsentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserConsentScalarWhereInput | UserConsentScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type WorkspaceMemberCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput> | WorkspaceMemberCreateWithoutWorkspaceInput[] | WorkspaceMemberUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutWorkspaceInput | WorkspaceMemberCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceMemberCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
  }

  export type DepartmentCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<DepartmentCreateWithoutWorkspaceInput, DepartmentUncheckedCreateWithoutWorkspaceInput> | DepartmentCreateWithoutWorkspaceInput[] | DepartmentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutWorkspaceInput | DepartmentCreateOrConnectWithoutWorkspaceInput[]
    createMany?: DepartmentCreateManyWorkspaceInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<TeamCreateWithoutWorkspaceInput, TeamUncheckedCreateWithoutWorkspaceInput> | TeamCreateWithoutWorkspaceInput[] | TeamUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutWorkspaceInput | TeamCreateOrConnectWithoutWorkspaceInput[]
    createMany?: TeamCreateManyWorkspaceInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type PositionCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<PositionCreateWithoutWorkspaceInput, PositionUncheckedCreateWithoutWorkspaceInput> | PositionCreateWithoutWorkspaceInput[] | PositionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutWorkspaceInput | PositionCreateOrConnectWithoutWorkspaceInput[]
    createMany?: PositionCreateManyWorkspaceInputEnvelope
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
  }

  export type PositionLevelCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<PositionLevelCreateWithoutWorkspaceInput, PositionLevelUncheckedCreateWithoutWorkspaceInput> | PositionLevelCreateWithoutWorkspaceInput[] | PositionLevelUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: PositionLevelCreateOrConnectWithoutWorkspaceInput | PositionLevelCreateOrConnectWithoutWorkspaceInput[]
    createMany?: PositionLevelCreateManyWorkspaceInputEnvelope
    connect?: PositionLevelWhereUniqueInput | PositionLevelWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<EmployeeCreateWithoutWorkspaceInput, EmployeeUncheckedCreateWithoutWorkspaceInput> | EmployeeCreateWithoutWorkspaceInput[] | EmployeeUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkspaceInput | EmployeeCreateOrConnectWithoutWorkspaceInput[]
    createMany?: EmployeeCreateManyWorkspaceInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type ProjectCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ProjectCreateWithoutWorkspaceInput, ProjectUncheckedCreateWithoutWorkspaceInput> | ProjectCreateWithoutWorkspaceInput[] | ProjectUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkspaceInput | ProjectCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ProjectCreateManyWorkspaceInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectRoleCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ProjectRoleCreateWithoutWorkspaceInput, ProjectRoleUncheckedCreateWithoutWorkspaceInput> | ProjectRoleCreateWithoutWorkspaceInput[] | ProjectRoleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutWorkspaceInput | ProjectRoleCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ProjectRoleCreateManyWorkspaceInputEnvelope
    connect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
  }

  export type LeaveTypeCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<LeaveTypeCreateWithoutWorkspaceInput, LeaveTypeUncheckedCreateWithoutWorkspaceInput> | LeaveTypeCreateWithoutWorkspaceInput[] | LeaveTypeUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutWorkspaceInput | LeaveTypeCreateOrConnectWithoutWorkspaceInput[]
    createMany?: LeaveTypeCreateManyWorkspaceInputEnvelope
    connect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
  }

  export type LeaveQuotaCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<LeaveQuotaCreateWithoutWorkspaceInput, LeaveQuotaUncheckedCreateWithoutWorkspaceInput> | LeaveQuotaCreateWithoutWorkspaceInput[] | LeaveQuotaUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LeaveQuotaCreateOrConnectWithoutWorkspaceInput | LeaveQuotaCreateOrConnectWithoutWorkspaceInput[]
    createMany?: LeaveQuotaCreateManyWorkspaceInputEnvelope
    connect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
  }

  export type LeaveCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<LeaveCreateWithoutWorkspaceInput, LeaveUncheckedCreateWithoutWorkspaceInput> | LeaveCreateWithoutWorkspaceInput[] | LeaveUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutWorkspaceInput | LeaveCreateOrConnectWithoutWorkspaceInput[]
    createMany?: LeaveCreateManyWorkspaceInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type OvertimePolicyCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<OvertimePolicyCreateWithoutWorkspaceInput, OvertimePolicyUncheckedCreateWithoutWorkspaceInput> | OvertimePolicyCreateWithoutWorkspaceInput[] | OvertimePolicyUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: OvertimePolicyCreateOrConnectWithoutWorkspaceInput | OvertimePolicyCreateOrConnectWithoutWorkspaceInput[]
    createMany?: OvertimePolicyCreateManyWorkspaceInputEnvelope
    connect?: OvertimePolicyWhereUniqueInput | OvertimePolicyWhereUniqueInput[]
  }

  export type OvertimeCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<OvertimeCreateWithoutWorkspaceInput, OvertimeUncheckedCreateWithoutWorkspaceInput> | OvertimeCreateWithoutWorkspaceInput[] | OvertimeUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutWorkspaceInput | OvertimeCreateOrConnectWithoutWorkspaceInput[]
    createMany?: OvertimeCreateManyWorkspaceInputEnvelope
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
  }

  export type ApprovalTemplateCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ApprovalTemplateCreateWithoutWorkspaceInput, ApprovalTemplateUncheckedCreateWithoutWorkspaceInput> | ApprovalTemplateCreateWithoutWorkspaceInput[] | ApprovalTemplateUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ApprovalTemplateCreateOrConnectWithoutWorkspaceInput | ApprovalTemplateCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ApprovalTemplateCreateManyWorkspaceInputEnvelope
    connect?: ApprovalTemplateWhereUniqueInput | ApprovalTemplateWhereUniqueInput[]
  }

  export type ApprovalCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ApprovalCreateWithoutWorkspaceInput, ApprovalUncheckedCreateWithoutWorkspaceInput> | ApprovalCreateWithoutWorkspaceInput[] | ApprovalUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutWorkspaceInput | ApprovalCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ApprovalCreateManyWorkspaceInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type SettingsCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<SettingsCreateWithoutWorkspaceInput, SettingsUncheckedCreateWithoutWorkspaceInput> | SettingsCreateWithoutWorkspaceInput[] | SettingsUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: SettingsCreateOrConnectWithoutWorkspaceInput | SettingsCreateOrConnectWithoutWorkspaceInput[]
    createMany?: SettingsCreateManyWorkspaceInputEnvelope
    connect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput> | AuditLogCreateWithoutWorkspaceInput[] | AuditLogUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutWorkspaceInput | AuditLogCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AuditLogCreateManyWorkspaceInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<InvitationCreateWithoutWorkspaceInput, InvitationUncheckedCreateWithoutWorkspaceInput> | InvitationCreateWithoutWorkspaceInput[] | InvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutWorkspaceInput | InvitationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: InvitationCreateManyWorkspaceInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput> | WorkspaceMemberCreateWithoutWorkspaceInput[] | WorkspaceMemberUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutWorkspaceInput | WorkspaceMemberCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkspaceMemberCreateManyWorkspaceInputEnvelope
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<DepartmentCreateWithoutWorkspaceInput, DepartmentUncheckedCreateWithoutWorkspaceInput> | DepartmentCreateWithoutWorkspaceInput[] | DepartmentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutWorkspaceInput | DepartmentCreateOrConnectWithoutWorkspaceInput[]
    createMany?: DepartmentCreateManyWorkspaceInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<TeamCreateWithoutWorkspaceInput, TeamUncheckedCreateWithoutWorkspaceInput> | TeamCreateWithoutWorkspaceInput[] | TeamUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutWorkspaceInput | TeamCreateOrConnectWithoutWorkspaceInput[]
    createMany?: TeamCreateManyWorkspaceInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type PositionUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<PositionCreateWithoutWorkspaceInput, PositionUncheckedCreateWithoutWorkspaceInput> | PositionCreateWithoutWorkspaceInput[] | PositionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutWorkspaceInput | PositionCreateOrConnectWithoutWorkspaceInput[]
    createMany?: PositionCreateManyWorkspaceInputEnvelope
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
  }

  export type PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<PositionLevelCreateWithoutWorkspaceInput, PositionLevelUncheckedCreateWithoutWorkspaceInput> | PositionLevelCreateWithoutWorkspaceInput[] | PositionLevelUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: PositionLevelCreateOrConnectWithoutWorkspaceInput | PositionLevelCreateOrConnectWithoutWorkspaceInput[]
    createMany?: PositionLevelCreateManyWorkspaceInputEnvelope
    connect?: PositionLevelWhereUniqueInput | PositionLevelWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<EmployeeCreateWithoutWorkspaceInput, EmployeeUncheckedCreateWithoutWorkspaceInput> | EmployeeCreateWithoutWorkspaceInput[] | EmployeeUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkspaceInput | EmployeeCreateOrConnectWithoutWorkspaceInput[]
    createMany?: EmployeeCreateManyWorkspaceInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ProjectCreateWithoutWorkspaceInput, ProjectUncheckedCreateWithoutWorkspaceInput> | ProjectCreateWithoutWorkspaceInput[] | ProjectUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkspaceInput | ProjectCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ProjectCreateManyWorkspaceInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ProjectRoleCreateWithoutWorkspaceInput, ProjectRoleUncheckedCreateWithoutWorkspaceInput> | ProjectRoleCreateWithoutWorkspaceInput[] | ProjectRoleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutWorkspaceInput | ProjectRoleCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ProjectRoleCreateManyWorkspaceInputEnvelope
    connect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
  }

  export type LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<LeaveTypeCreateWithoutWorkspaceInput, LeaveTypeUncheckedCreateWithoutWorkspaceInput> | LeaveTypeCreateWithoutWorkspaceInput[] | LeaveTypeUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutWorkspaceInput | LeaveTypeCreateOrConnectWithoutWorkspaceInput[]
    createMany?: LeaveTypeCreateManyWorkspaceInputEnvelope
    connect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
  }

  export type LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<LeaveQuotaCreateWithoutWorkspaceInput, LeaveQuotaUncheckedCreateWithoutWorkspaceInput> | LeaveQuotaCreateWithoutWorkspaceInput[] | LeaveQuotaUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LeaveQuotaCreateOrConnectWithoutWorkspaceInput | LeaveQuotaCreateOrConnectWithoutWorkspaceInput[]
    createMany?: LeaveQuotaCreateManyWorkspaceInputEnvelope
    connect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
  }

  export type LeaveUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<LeaveCreateWithoutWorkspaceInput, LeaveUncheckedCreateWithoutWorkspaceInput> | LeaveCreateWithoutWorkspaceInput[] | LeaveUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutWorkspaceInput | LeaveCreateOrConnectWithoutWorkspaceInput[]
    createMany?: LeaveCreateManyWorkspaceInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<OvertimePolicyCreateWithoutWorkspaceInput, OvertimePolicyUncheckedCreateWithoutWorkspaceInput> | OvertimePolicyCreateWithoutWorkspaceInput[] | OvertimePolicyUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: OvertimePolicyCreateOrConnectWithoutWorkspaceInput | OvertimePolicyCreateOrConnectWithoutWorkspaceInput[]
    createMany?: OvertimePolicyCreateManyWorkspaceInputEnvelope
    connect?: OvertimePolicyWhereUniqueInput | OvertimePolicyWhereUniqueInput[]
  }

  export type OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<OvertimeCreateWithoutWorkspaceInput, OvertimeUncheckedCreateWithoutWorkspaceInput> | OvertimeCreateWithoutWorkspaceInput[] | OvertimeUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutWorkspaceInput | OvertimeCreateOrConnectWithoutWorkspaceInput[]
    createMany?: OvertimeCreateManyWorkspaceInputEnvelope
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
  }

  export type ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ApprovalTemplateCreateWithoutWorkspaceInput, ApprovalTemplateUncheckedCreateWithoutWorkspaceInput> | ApprovalTemplateCreateWithoutWorkspaceInput[] | ApprovalTemplateUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ApprovalTemplateCreateOrConnectWithoutWorkspaceInput | ApprovalTemplateCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ApprovalTemplateCreateManyWorkspaceInputEnvelope
    connect?: ApprovalTemplateWhereUniqueInput | ApprovalTemplateWhereUniqueInput[]
  }

  export type ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ApprovalCreateWithoutWorkspaceInput, ApprovalUncheckedCreateWithoutWorkspaceInput> | ApprovalCreateWithoutWorkspaceInput[] | ApprovalUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutWorkspaceInput | ApprovalCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ApprovalCreateManyWorkspaceInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type SettingsUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<SettingsCreateWithoutWorkspaceInput, SettingsUncheckedCreateWithoutWorkspaceInput> | SettingsCreateWithoutWorkspaceInput[] | SettingsUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: SettingsCreateOrConnectWithoutWorkspaceInput | SettingsCreateOrConnectWithoutWorkspaceInput[]
    createMany?: SettingsCreateManyWorkspaceInputEnvelope
    connect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput> | AuditLogCreateWithoutWorkspaceInput[] | AuditLogUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutWorkspaceInput | AuditLogCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AuditLogCreateManyWorkspaceInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<InvitationCreateWithoutWorkspaceInput, InvitationUncheckedCreateWithoutWorkspaceInput> | InvitationCreateWithoutWorkspaceInput[] | InvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutWorkspaceInput | InvitationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: InvitationCreateManyWorkspaceInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type EnumWorkspaceStatusFieldUpdateOperationsInput = {
    set?: $Enums.WorkspaceStatus
  }

  export type EnumPlanTypeFieldUpdateOperationsInput = {
    set?: $Enums.PlanType
  }

  export type WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput> | WorkspaceMemberCreateWithoutWorkspaceInput[] | WorkspaceMemberUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutWorkspaceInput | WorkspaceMemberCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceMemberUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceMemberUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceMemberCreateManyWorkspaceInputEnvelope
    set?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    disconnect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    delete?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    update?: WorkspaceMemberUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceMemberUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceMemberUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceMemberUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
  }

  export type DepartmentUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<DepartmentCreateWithoutWorkspaceInput, DepartmentUncheckedCreateWithoutWorkspaceInput> | DepartmentCreateWithoutWorkspaceInput[] | DepartmentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutWorkspaceInput | DepartmentCreateOrConnectWithoutWorkspaceInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutWorkspaceInput | DepartmentUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: DepartmentCreateManyWorkspaceInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutWorkspaceInput | DepartmentUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutWorkspaceInput | DepartmentUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<TeamCreateWithoutWorkspaceInput, TeamUncheckedCreateWithoutWorkspaceInput> | TeamCreateWithoutWorkspaceInput[] | TeamUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutWorkspaceInput | TeamCreateOrConnectWithoutWorkspaceInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutWorkspaceInput | TeamUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: TeamCreateManyWorkspaceInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutWorkspaceInput | TeamUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutWorkspaceInput | TeamUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type PositionUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<PositionCreateWithoutWorkspaceInput, PositionUncheckedCreateWithoutWorkspaceInput> | PositionCreateWithoutWorkspaceInput[] | PositionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutWorkspaceInput | PositionCreateOrConnectWithoutWorkspaceInput[]
    upsert?: PositionUpsertWithWhereUniqueWithoutWorkspaceInput | PositionUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: PositionCreateManyWorkspaceInputEnvelope
    set?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    disconnect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    delete?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    update?: PositionUpdateWithWhereUniqueWithoutWorkspaceInput | PositionUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: PositionUpdateManyWithWhereWithoutWorkspaceInput | PositionUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: PositionScalarWhereInput | PositionScalarWhereInput[]
  }

  export type PositionLevelUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<PositionLevelCreateWithoutWorkspaceInput, PositionLevelUncheckedCreateWithoutWorkspaceInput> | PositionLevelCreateWithoutWorkspaceInput[] | PositionLevelUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: PositionLevelCreateOrConnectWithoutWorkspaceInput | PositionLevelCreateOrConnectWithoutWorkspaceInput[]
    upsert?: PositionLevelUpsertWithWhereUniqueWithoutWorkspaceInput | PositionLevelUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: PositionLevelCreateManyWorkspaceInputEnvelope
    set?: PositionLevelWhereUniqueInput | PositionLevelWhereUniqueInput[]
    disconnect?: PositionLevelWhereUniqueInput | PositionLevelWhereUniqueInput[]
    delete?: PositionLevelWhereUniqueInput | PositionLevelWhereUniqueInput[]
    connect?: PositionLevelWhereUniqueInput | PositionLevelWhereUniqueInput[]
    update?: PositionLevelUpdateWithWhereUniqueWithoutWorkspaceInput | PositionLevelUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: PositionLevelUpdateManyWithWhereWithoutWorkspaceInput | PositionLevelUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: PositionLevelScalarWhereInput | PositionLevelScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<EmployeeCreateWithoutWorkspaceInput, EmployeeUncheckedCreateWithoutWorkspaceInput> | EmployeeCreateWithoutWorkspaceInput[] | EmployeeUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkspaceInput | EmployeeCreateOrConnectWithoutWorkspaceInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutWorkspaceInput | EmployeeUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: EmployeeCreateManyWorkspaceInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutWorkspaceInput | EmployeeUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutWorkspaceInput | EmployeeUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type ProjectUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ProjectCreateWithoutWorkspaceInput, ProjectUncheckedCreateWithoutWorkspaceInput> | ProjectCreateWithoutWorkspaceInput[] | ProjectUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkspaceInput | ProjectCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutWorkspaceInput | ProjectUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ProjectCreateManyWorkspaceInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutWorkspaceInput | ProjectUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutWorkspaceInput | ProjectUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectRoleUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ProjectRoleCreateWithoutWorkspaceInput, ProjectRoleUncheckedCreateWithoutWorkspaceInput> | ProjectRoleCreateWithoutWorkspaceInput[] | ProjectRoleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutWorkspaceInput | ProjectRoleCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ProjectRoleUpsertWithWhereUniqueWithoutWorkspaceInput | ProjectRoleUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ProjectRoleCreateManyWorkspaceInputEnvelope
    set?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    disconnect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    delete?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    connect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    update?: ProjectRoleUpdateWithWhereUniqueWithoutWorkspaceInput | ProjectRoleUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ProjectRoleUpdateManyWithWhereWithoutWorkspaceInput | ProjectRoleUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ProjectRoleScalarWhereInput | ProjectRoleScalarWhereInput[]
  }

  export type LeaveTypeUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<LeaveTypeCreateWithoutWorkspaceInput, LeaveTypeUncheckedCreateWithoutWorkspaceInput> | LeaveTypeCreateWithoutWorkspaceInput[] | LeaveTypeUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutWorkspaceInput | LeaveTypeCreateOrConnectWithoutWorkspaceInput[]
    upsert?: LeaveTypeUpsertWithWhereUniqueWithoutWorkspaceInput | LeaveTypeUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: LeaveTypeCreateManyWorkspaceInputEnvelope
    set?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    disconnect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    delete?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    connect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    update?: LeaveTypeUpdateWithWhereUniqueWithoutWorkspaceInput | LeaveTypeUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: LeaveTypeUpdateManyWithWhereWithoutWorkspaceInput | LeaveTypeUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: LeaveTypeScalarWhereInput | LeaveTypeScalarWhereInput[]
  }

  export type LeaveQuotaUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<LeaveQuotaCreateWithoutWorkspaceInput, LeaveQuotaUncheckedCreateWithoutWorkspaceInput> | LeaveQuotaCreateWithoutWorkspaceInput[] | LeaveQuotaUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LeaveQuotaCreateOrConnectWithoutWorkspaceInput | LeaveQuotaCreateOrConnectWithoutWorkspaceInput[]
    upsert?: LeaveQuotaUpsertWithWhereUniqueWithoutWorkspaceInput | LeaveQuotaUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: LeaveQuotaCreateManyWorkspaceInputEnvelope
    set?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    disconnect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    delete?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    connect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    update?: LeaveQuotaUpdateWithWhereUniqueWithoutWorkspaceInput | LeaveQuotaUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: LeaveQuotaUpdateManyWithWhereWithoutWorkspaceInput | LeaveQuotaUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: LeaveQuotaScalarWhereInput | LeaveQuotaScalarWhereInput[]
  }

  export type LeaveUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<LeaveCreateWithoutWorkspaceInput, LeaveUncheckedCreateWithoutWorkspaceInput> | LeaveCreateWithoutWorkspaceInput[] | LeaveUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutWorkspaceInput | LeaveCreateOrConnectWithoutWorkspaceInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutWorkspaceInput | LeaveUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: LeaveCreateManyWorkspaceInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutWorkspaceInput | LeaveUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutWorkspaceInput | LeaveUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type OvertimePolicyUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<OvertimePolicyCreateWithoutWorkspaceInput, OvertimePolicyUncheckedCreateWithoutWorkspaceInput> | OvertimePolicyCreateWithoutWorkspaceInput[] | OvertimePolicyUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: OvertimePolicyCreateOrConnectWithoutWorkspaceInput | OvertimePolicyCreateOrConnectWithoutWorkspaceInput[]
    upsert?: OvertimePolicyUpsertWithWhereUniqueWithoutWorkspaceInput | OvertimePolicyUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: OvertimePolicyCreateManyWorkspaceInputEnvelope
    set?: OvertimePolicyWhereUniqueInput | OvertimePolicyWhereUniqueInput[]
    disconnect?: OvertimePolicyWhereUniqueInput | OvertimePolicyWhereUniqueInput[]
    delete?: OvertimePolicyWhereUniqueInput | OvertimePolicyWhereUniqueInput[]
    connect?: OvertimePolicyWhereUniqueInput | OvertimePolicyWhereUniqueInput[]
    update?: OvertimePolicyUpdateWithWhereUniqueWithoutWorkspaceInput | OvertimePolicyUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: OvertimePolicyUpdateManyWithWhereWithoutWorkspaceInput | OvertimePolicyUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: OvertimePolicyScalarWhereInput | OvertimePolicyScalarWhereInput[]
  }

  export type OvertimeUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<OvertimeCreateWithoutWorkspaceInput, OvertimeUncheckedCreateWithoutWorkspaceInput> | OvertimeCreateWithoutWorkspaceInput[] | OvertimeUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutWorkspaceInput | OvertimeCreateOrConnectWithoutWorkspaceInput[]
    upsert?: OvertimeUpsertWithWhereUniqueWithoutWorkspaceInput | OvertimeUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: OvertimeCreateManyWorkspaceInputEnvelope
    set?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    disconnect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    delete?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    update?: OvertimeUpdateWithWhereUniqueWithoutWorkspaceInput | OvertimeUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: OvertimeUpdateManyWithWhereWithoutWorkspaceInput | OvertimeUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
  }

  export type ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ApprovalTemplateCreateWithoutWorkspaceInput, ApprovalTemplateUncheckedCreateWithoutWorkspaceInput> | ApprovalTemplateCreateWithoutWorkspaceInput[] | ApprovalTemplateUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ApprovalTemplateCreateOrConnectWithoutWorkspaceInput | ApprovalTemplateCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ApprovalTemplateUpsertWithWhereUniqueWithoutWorkspaceInput | ApprovalTemplateUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ApprovalTemplateCreateManyWorkspaceInputEnvelope
    set?: ApprovalTemplateWhereUniqueInput | ApprovalTemplateWhereUniqueInput[]
    disconnect?: ApprovalTemplateWhereUniqueInput | ApprovalTemplateWhereUniqueInput[]
    delete?: ApprovalTemplateWhereUniqueInput | ApprovalTemplateWhereUniqueInput[]
    connect?: ApprovalTemplateWhereUniqueInput | ApprovalTemplateWhereUniqueInput[]
    update?: ApprovalTemplateUpdateWithWhereUniqueWithoutWorkspaceInput | ApprovalTemplateUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ApprovalTemplateUpdateManyWithWhereWithoutWorkspaceInput | ApprovalTemplateUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ApprovalTemplateScalarWhereInput | ApprovalTemplateScalarWhereInput[]
  }

  export type ApprovalUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ApprovalCreateWithoutWorkspaceInput, ApprovalUncheckedCreateWithoutWorkspaceInput> | ApprovalCreateWithoutWorkspaceInput[] | ApprovalUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutWorkspaceInput | ApprovalCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutWorkspaceInput | ApprovalUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ApprovalCreateManyWorkspaceInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutWorkspaceInput | ApprovalUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutWorkspaceInput | ApprovalUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type SettingsUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<SettingsCreateWithoutWorkspaceInput, SettingsUncheckedCreateWithoutWorkspaceInput> | SettingsCreateWithoutWorkspaceInput[] | SettingsUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: SettingsCreateOrConnectWithoutWorkspaceInput | SettingsCreateOrConnectWithoutWorkspaceInput[]
    upsert?: SettingsUpsertWithWhereUniqueWithoutWorkspaceInput | SettingsUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: SettingsCreateManyWorkspaceInputEnvelope
    set?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    disconnect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    delete?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    connect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    update?: SettingsUpdateWithWhereUniqueWithoutWorkspaceInput | SettingsUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: SettingsUpdateManyWithWhereWithoutWorkspaceInput | SettingsUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: SettingsScalarWhereInput | SettingsScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput> | AuditLogCreateWithoutWorkspaceInput[] | AuditLogUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutWorkspaceInput | AuditLogCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutWorkspaceInput | AuditLogUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AuditLogCreateManyWorkspaceInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutWorkspaceInput | AuditLogUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutWorkspaceInput | AuditLogUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<InvitationCreateWithoutWorkspaceInput, InvitationUncheckedCreateWithoutWorkspaceInput> | InvitationCreateWithoutWorkspaceInput[] | InvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutWorkspaceInput | InvitationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutWorkspaceInput | InvitationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: InvitationCreateManyWorkspaceInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutWorkspaceInput | InvitationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutWorkspaceInput | InvitationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput> | WorkspaceMemberCreateWithoutWorkspaceInput[] | WorkspaceMemberUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkspaceMemberCreateOrConnectWithoutWorkspaceInput | WorkspaceMemberCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkspaceMemberUpsertWithWhereUniqueWithoutWorkspaceInput | WorkspaceMemberUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkspaceMemberCreateManyWorkspaceInputEnvelope
    set?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    disconnect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    delete?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    connect?: WorkspaceMemberWhereUniqueInput | WorkspaceMemberWhereUniqueInput[]
    update?: WorkspaceMemberUpdateWithWhereUniqueWithoutWorkspaceInput | WorkspaceMemberUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkspaceMemberUpdateManyWithWhereWithoutWorkspaceInput | WorkspaceMemberUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<DepartmentCreateWithoutWorkspaceInput, DepartmentUncheckedCreateWithoutWorkspaceInput> | DepartmentCreateWithoutWorkspaceInput[] | DepartmentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutWorkspaceInput | DepartmentCreateOrConnectWithoutWorkspaceInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutWorkspaceInput | DepartmentUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: DepartmentCreateManyWorkspaceInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutWorkspaceInput | DepartmentUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutWorkspaceInput | DepartmentUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<TeamCreateWithoutWorkspaceInput, TeamUncheckedCreateWithoutWorkspaceInput> | TeamCreateWithoutWorkspaceInput[] | TeamUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutWorkspaceInput | TeamCreateOrConnectWithoutWorkspaceInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutWorkspaceInput | TeamUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: TeamCreateManyWorkspaceInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutWorkspaceInput | TeamUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutWorkspaceInput | TeamUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type PositionUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<PositionCreateWithoutWorkspaceInput, PositionUncheckedCreateWithoutWorkspaceInput> | PositionCreateWithoutWorkspaceInput[] | PositionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: PositionCreateOrConnectWithoutWorkspaceInput | PositionCreateOrConnectWithoutWorkspaceInput[]
    upsert?: PositionUpsertWithWhereUniqueWithoutWorkspaceInput | PositionUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: PositionCreateManyWorkspaceInputEnvelope
    set?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    disconnect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    delete?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    connect?: PositionWhereUniqueInput | PositionWhereUniqueInput[]
    update?: PositionUpdateWithWhereUniqueWithoutWorkspaceInput | PositionUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: PositionUpdateManyWithWhereWithoutWorkspaceInput | PositionUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: PositionScalarWhereInput | PositionScalarWhereInput[]
  }

  export type PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<PositionLevelCreateWithoutWorkspaceInput, PositionLevelUncheckedCreateWithoutWorkspaceInput> | PositionLevelCreateWithoutWorkspaceInput[] | PositionLevelUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: PositionLevelCreateOrConnectWithoutWorkspaceInput | PositionLevelCreateOrConnectWithoutWorkspaceInput[]
    upsert?: PositionLevelUpsertWithWhereUniqueWithoutWorkspaceInput | PositionLevelUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: PositionLevelCreateManyWorkspaceInputEnvelope
    set?: PositionLevelWhereUniqueInput | PositionLevelWhereUniqueInput[]
    disconnect?: PositionLevelWhereUniqueInput | PositionLevelWhereUniqueInput[]
    delete?: PositionLevelWhereUniqueInput | PositionLevelWhereUniqueInput[]
    connect?: PositionLevelWhereUniqueInput | PositionLevelWhereUniqueInput[]
    update?: PositionLevelUpdateWithWhereUniqueWithoutWorkspaceInput | PositionLevelUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: PositionLevelUpdateManyWithWhereWithoutWorkspaceInput | PositionLevelUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: PositionLevelScalarWhereInput | PositionLevelScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<EmployeeCreateWithoutWorkspaceInput, EmployeeUncheckedCreateWithoutWorkspaceInput> | EmployeeCreateWithoutWorkspaceInput[] | EmployeeUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutWorkspaceInput | EmployeeCreateOrConnectWithoutWorkspaceInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutWorkspaceInput | EmployeeUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: EmployeeCreateManyWorkspaceInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutWorkspaceInput | EmployeeUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutWorkspaceInput | EmployeeUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ProjectCreateWithoutWorkspaceInput, ProjectUncheckedCreateWithoutWorkspaceInput> | ProjectCreateWithoutWorkspaceInput[] | ProjectUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutWorkspaceInput | ProjectCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutWorkspaceInput | ProjectUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ProjectCreateManyWorkspaceInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutWorkspaceInput | ProjectUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutWorkspaceInput | ProjectUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ProjectRoleCreateWithoutWorkspaceInput, ProjectRoleUncheckedCreateWithoutWorkspaceInput> | ProjectRoleCreateWithoutWorkspaceInput[] | ProjectRoleUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutWorkspaceInput | ProjectRoleCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ProjectRoleUpsertWithWhereUniqueWithoutWorkspaceInput | ProjectRoleUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ProjectRoleCreateManyWorkspaceInputEnvelope
    set?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    disconnect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    delete?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    connect?: ProjectRoleWhereUniqueInput | ProjectRoleWhereUniqueInput[]
    update?: ProjectRoleUpdateWithWhereUniqueWithoutWorkspaceInput | ProjectRoleUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ProjectRoleUpdateManyWithWhereWithoutWorkspaceInput | ProjectRoleUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ProjectRoleScalarWhereInput | ProjectRoleScalarWhereInput[]
  }

  export type LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<LeaveTypeCreateWithoutWorkspaceInput, LeaveTypeUncheckedCreateWithoutWorkspaceInput> | LeaveTypeCreateWithoutWorkspaceInput[] | LeaveTypeUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutWorkspaceInput | LeaveTypeCreateOrConnectWithoutWorkspaceInput[]
    upsert?: LeaveTypeUpsertWithWhereUniqueWithoutWorkspaceInput | LeaveTypeUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: LeaveTypeCreateManyWorkspaceInputEnvelope
    set?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    disconnect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    delete?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    connect?: LeaveTypeWhereUniqueInput | LeaveTypeWhereUniqueInput[]
    update?: LeaveTypeUpdateWithWhereUniqueWithoutWorkspaceInput | LeaveTypeUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: LeaveTypeUpdateManyWithWhereWithoutWorkspaceInput | LeaveTypeUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: LeaveTypeScalarWhereInput | LeaveTypeScalarWhereInput[]
  }

  export type LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<LeaveQuotaCreateWithoutWorkspaceInput, LeaveQuotaUncheckedCreateWithoutWorkspaceInput> | LeaveQuotaCreateWithoutWorkspaceInput[] | LeaveQuotaUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LeaveQuotaCreateOrConnectWithoutWorkspaceInput | LeaveQuotaCreateOrConnectWithoutWorkspaceInput[]
    upsert?: LeaveQuotaUpsertWithWhereUniqueWithoutWorkspaceInput | LeaveQuotaUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: LeaveQuotaCreateManyWorkspaceInputEnvelope
    set?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    disconnect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    delete?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    connect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    update?: LeaveQuotaUpdateWithWhereUniqueWithoutWorkspaceInput | LeaveQuotaUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: LeaveQuotaUpdateManyWithWhereWithoutWorkspaceInput | LeaveQuotaUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: LeaveQuotaScalarWhereInput | LeaveQuotaScalarWhereInput[]
  }

  export type LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<LeaveCreateWithoutWorkspaceInput, LeaveUncheckedCreateWithoutWorkspaceInput> | LeaveCreateWithoutWorkspaceInput[] | LeaveUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutWorkspaceInput | LeaveCreateOrConnectWithoutWorkspaceInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutWorkspaceInput | LeaveUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: LeaveCreateManyWorkspaceInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutWorkspaceInput | LeaveUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutWorkspaceInput | LeaveUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<OvertimePolicyCreateWithoutWorkspaceInput, OvertimePolicyUncheckedCreateWithoutWorkspaceInput> | OvertimePolicyCreateWithoutWorkspaceInput[] | OvertimePolicyUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: OvertimePolicyCreateOrConnectWithoutWorkspaceInput | OvertimePolicyCreateOrConnectWithoutWorkspaceInput[]
    upsert?: OvertimePolicyUpsertWithWhereUniqueWithoutWorkspaceInput | OvertimePolicyUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: OvertimePolicyCreateManyWorkspaceInputEnvelope
    set?: OvertimePolicyWhereUniqueInput | OvertimePolicyWhereUniqueInput[]
    disconnect?: OvertimePolicyWhereUniqueInput | OvertimePolicyWhereUniqueInput[]
    delete?: OvertimePolicyWhereUniqueInput | OvertimePolicyWhereUniqueInput[]
    connect?: OvertimePolicyWhereUniqueInput | OvertimePolicyWhereUniqueInput[]
    update?: OvertimePolicyUpdateWithWhereUniqueWithoutWorkspaceInput | OvertimePolicyUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: OvertimePolicyUpdateManyWithWhereWithoutWorkspaceInput | OvertimePolicyUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: OvertimePolicyScalarWhereInput | OvertimePolicyScalarWhereInput[]
  }

  export type OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<OvertimeCreateWithoutWorkspaceInput, OvertimeUncheckedCreateWithoutWorkspaceInput> | OvertimeCreateWithoutWorkspaceInput[] | OvertimeUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutWorkspaceInput | OvertimeCreateOrConnectWithoutWorkspaceInput[]
    upsert?: OvertimeUpsertWithWhereUniqueWithoutWorkspaceInput | OvertimeUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: OvertimeCreateManyWorkspaceInputEnvelope
    set?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    disconnect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    delete?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    update?: OvertimeUpdateWithWhereUniqueWithoutWorkspaceInput | OvertimeUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: OvertimeUpdateManyWithWhereWithoutWorkspaceInput | OvertimeUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
  }

  export type ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ApprovalTemplateCreateWithoutWorkspaceInput, ApprovalTemplateUncheckedCreateWithoutWorkspaceInput> | ApprovalTemplateCreateWithoutWorkspaceInput[] | ApprovalTemplateUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ApprovalTemplateCreateOrConnectWithoutWorkspaceInput | ApprovalTemplateCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ApprovalTemplateUpsertWithWhereUniqueWithoutWorkspaceInput | ApprovalTemplateUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ApprovalTemplateCreateManyWorkspaceInputEnvelope
    set?: ApprovalTemplateWhereUniqueInput | ApprovalTemplateWhereUniqueInput[]
    disconnect?: ApprovalTemplateWhereUniqueInput | ApprovalTemplateWhereUniqueInput[]
    delete?: ApprovalTemplateWhereUniqueInput | ApprovalTemplateWhereUniqueInput[]
    connect?: ApprovalTemplateWhereUniqueInput | ApprovalTemplateWhereUniqueInput[]
    update?: ApprovalTemplateUpdateWithWhereUniqueWithoutWorkspaceInput | ApprovalTemplateUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ApprovalTemplateUpdateManyWithWhereWithoutWorkspaceInput | ApprovalTemplateUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ApprovalTemplateScalarWhereInput | ApprovalTemplateScalarWhereInput[]
  }

  export type ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ApprovalCreateWithoutWorkspaceInput, ApprovalUncheckedCreateWithoutWorkspaceInput> | ApprovalCreateWithoutWorkspaceInput[] | ApprovalUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutWorkspaceInput | ApprovalCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutWorkspaceInput | ApprovalUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ApprovalCreateManyWorkspaceInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutWorkspaceInput | ApprovalUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutWorkspaceInput | ApprovalUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<SettingsCreateWithoutWorkspaceInput, SettingsUncheckedCreateWithoutWorkspaceInput> | SettingsCreateWithoutWorkspaceInput[] | SettingsUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: SettingsCreateOrConnectWithoutWorkspaceInput | SettingsCreateOrConnectWithoutWorkspaceInput[]
    upsert?: SettingsUpsertWithWhereUniqueWithoutWorkspaceInput | SettingsUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: SettingsCreateManyWorkspaceInputEnvelope
    set?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    disconnect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    delete?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    connect?: SettingsWhereUniqueInput | SettingsWhereUniqueInput[]
    update?: SettingsUpdateWithWhereUniqueWithoutWorkspaceInput | SettingsUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: SettingsUpdateManyWithWhereWithoutWorkspaceInput | SettingsUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: SettingsScalarWhereInput | SettingsScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput> | AuditLogCreateWithoutWorkspaceInput[] | AuditLogUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutWorkspaceInput | AuditLogCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutWorkspaceInput | AuditLogUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AuditLogCreateManyWorkspaceInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutWorkspaceInput | AuditLogUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutWorkspaceInput | AuditLogUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<InvitationCreateWithoutWorkspaceInput, InvitationUncheckedCreateWithoutWorkspaceInput> | InvitationCreateWithoutWorkspaceInput[] | InvitationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutWorkspaceInput | InvitationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutWorkspaceInput | InvitationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: InvitationCreateManyWorkspaceInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutWorkspaceInput | InvitationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutWorkspaceInput | InvitationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutMembersInput = {
    create?: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutMembersInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWorkspaceMemberInput = {
    create?: XOR<UserCreateWithoutWorkspaceMemberInput, UserUncheckedCreateWithoutWorkspaceMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspaceMemberInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMemberRoleFieldUpdateOperationsInput = {
    set?: $Enums.MemberRole
  }

  export type EnumMemberStatusFieldUpdateOperationsInput = {
    set?: $Enums.MemberStatus
  }

  export type WorkspaceUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutMembersInput
    upsert?: WorkspaceUpsertWithoutMembersInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutMembersInput, WorkspaceUpdateWithoutMembersInput>, WorkspaceUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutWorkspaceMemberNestedInput = {
    create?: XOR<UserCreateWithoutWorkspaceMemberInput, UserUncheckedCreateWithoutWorkspaceMemberInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspaceMemberInput
    upsert?: UserUpsertWithoutWorkspaceMemberInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkspaceMemberInput, UserUpdateWithoutWorkspaceMemberInput>, UserUncheckedUpdateWithoutWorkspaceMemberInput>
  }

  export type WorkspaceCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<WorkspaceCreateWithoutDepartmentsInput, WorkspaceUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutDepartmentsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type TeamCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<TeamCreateWithoutDepartmentInput, TeamUncheckedCreateWithoutDepartmentInput> | TeamCreateWithoutDepartmentInput[] | TeamUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutDepartmentInput | TeamCreateOrConnectWithoutDepartmentInput[]
    createMany?: TeamCreateManyDepartmentInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type DepartmentCreateNestedOneWithoutChildrenInput = {
    create?: XOR<DepartmentCreateWithoutChildrenInput, DepartmentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutChildrenInput
    connect?: DepartmentWhereUniqueInput
  }

  export type DepartmentCreateNestedManyWithoutParentInput = {
    create?: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput> | DepartmentCreateWithoutParentInput[] | DepartmentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutParentInput | DepartmentCreateOrConnectWithoutParentInput[]
    createMany?: DepartmentCreateManyParentInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<TeamCreateWithoutDepartmentInput, TeamUncheckedCreateWithoutDepartmentInput> | TeamCreateWithoutDepartmentInput[] | TeamUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutDepartmentInput | TeamCreateOrConnectWithoutDepartmentInput[]
    createMany?: TeamCreateManyDepartmentInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput> | DepartmentCreateWithoutParentInput[] | DepartmentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutParentInput | DepartmentCreateOrConnectWithoutParentInput[]
    createMany?: DepartmentCreateManyParentInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutDepartmentsInput, WorkspaceUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutDepartmentsInput
    upsert?: WorkspaceUpsertWithoutDepartmentsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutDepartmentsInput, WorkspaceUpdateWithoutDepartmentsInput>, WorkspaceUncheckedUpdateWithoutDepartmentsInput>
  }

  export type TeamUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<TeamCreateWithoutDepartmentInput, TeamUncheckedCreateWithoutDepartmentInput> | TeamCreateWithoutDepartmentInput[] | TeamUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutDepartmentInput | TeamCreateOrConnectWithoutDepartmentInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutDepartmentInput | TeamUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: TeamCreateManyDepartmentInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutDepartmentInput | TeamUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutDepartmentInput | TeamUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDepartmentInput | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDepartmentInput | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDepartmentInput | EmployeeUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type DepartmentUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<DepartmentCreateWithoutChildrenInput, DepartmentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutChildrenInput
    upsert?: DepartmentUpsertWithoutChildrenInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutChildrenInput, DepartmentUpdateWithoutChildrenInput>, DepartmentUncheckedUpdateWithoutChildrenInput>
  }

  export type DepartmentUpdateManyWithoutParentNestedInput = {
    create?: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput> | DepartmentCreateWithoutParentInput[] | DepartmentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutParentInput | DepartmentCreateOrConnectWithoutParentInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutParentInput | DepartmentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DepartmentCreateManyParentInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutParentInput | DepartmentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutParentInput | DepartmentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<TeamCreateWithoutDepartmentInput, TeamUncheckedCreateWithoutDepartmentInput> | TeamCreateWithoutDepartmentInput[] | TeamUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutDepartmentInput | TeamCreateOrConnectWithoutDepartmentInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutDepartmentInput | TeamUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: TeamCreateManyDepartmentInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutDepartmentInput | TeamUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutDepartmentInput | TeamUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDepartmentInput | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDepartmentInput | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDepartmentInput | EmployeeUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput> | DepartmentCreateWithoutParentInput[] | DepartmentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutParentInput | DepartmentCreateOrConnectWithoutParentInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutParentInput | DepartmentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DepartmentCreateManyParentInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutParentInput | DepartmentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutParentInput | DepartmentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutTeamsInput = {
    create?: XOR<WorkspaceCreateWithoutTeamsInput, WorkspaceUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutTeamsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutTeamsInput = {
    create?: XOR<DepartmentCreateWithoutTeamsInput, DepartmentUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutTeamsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type EmployeeCreateNestedManyWithoutTeamInput = {
    create?: XOR<EmployeeCreateWithoutTeamInput, EmployeeUncheckedCreateWithoutTeamInput> | EmployeeCreateWithoutTeamInput[] | EmployeeUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTeamInput | EmployeeCreateOrConnectWithoutTeamInput[]
    createMany?: EmployeeCreateManyTeamInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<EmployeeCreateWithoutTeamInput, EmployeeUncheckedCreateWithoutTeamInput> | EmployeeCreateWithoutTeamInput[] | EmployeeUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTeamInput | EmployeeCreateOrConnectWithoutTeamInput[]
    createMany?: EmployeeCreateManyTeamInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutTeamsInput, WorkspaceUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutTeamsInput
    upsert?: WorkspaceUpsertWithoutTeamsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutTeamsInput, WorkspaceUpdateWithoutTeamsInput>, WorkspaceUncheckedUpdateWithoutTeamsInput>
  }

  export type DepartmentUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<DepartmentCreateWithoutTeamsInput, DepartmentUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutTeamsInput
    upsert?: DepartmentUpsertWithoutTeamsInput
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutTeamsInput, DepartmentUpdateWithoutTeamsInput>, DepartmentUncheckedUpdateWithoutTeamsInput>
  }

  export type EmployeeUpdateManyWithoutTeamNestedInput = {
    create?: XOR<EmployeeCreateWithoutTeamInput, EmployeeUncheckedCreateWithoutTeamInput> | EmployeeCreateWithoutTeamInput[] | EmployeeUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTeamInput | EmployeeCreateOrConnectWithoutTeamInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutTeamInput | EmployeeUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: EmployeeCreateManyTeamInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutTeamInput | EmployeeUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutTeamInput | EmployeeUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<EmployeeCreateWithoutTeamInput, EmployeeUncheckedCreateWithoutTeamInput> | EmployeeCreateWithoutTeamInput[] | EmployeeUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTeamInput | EmployeeCreateOrConnectWithoutTeamInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutTeamInput | EmployeeUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: EmployeeCreateManyTeamInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutTeamInput | EmployeeUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutTeamInput | EmployeeUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutPositionsInput = {
    create?: XOR<WorkspaceCreateWithoutPositionsInput, WorkspaceUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutPositionsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type EmployeeCreateNestedManyWithoutPositionInput = {
    create?: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput> | EmployeeCreateWithoutPositionInput[] | EmployeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionInput | EmployeeCreateOrConnectWithoutPositionInput[]
    createMany?: EmployeeCreateManyPositionInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmploymentHistoryCreateNestedManyWithoutPositionInput = {
    create?: XOR<EmploymentHistoryCreateWithoutPositionInput, EmploymentHistoryUncheckedCreateWithoutPositionInput> | EmploymentHistoryCreateWithoutPositionInput[] | EmploymentHistoryUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmploymentHistoryCreateOrConnectWithoutPositionInput | EmploymentHistoryCreateOrConnectWithoutPositionInput[]
    createMany?: EmploymentHistoryCreateManyPositionInputEnvelope
    connect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput> | EmployeeCreateWithoutPositionInput[] | EmployeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionInput | EmployeeCreateOrConnectWithoutPositionInput[]
    createMany?: EmployeeCreateManyPositionInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmploymentHistoryUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<EmploymentHistoryCreateWithoutPositionInput, EmploymentHistoryUncheckedCreateWithoutPositionInput> | EmploymentHistoryCreateWithoutPositionInput[] | EmploymentHistoryUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmploymentHistoryCreateOrConnectWithoutPositionInput | EmploymentHistoryCreateOrConnectWithoutPositionInput[]
    createMany?: EmploymentHistoryCreateManyPositionInputEnvelope
    connect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutPositionsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutPositionsInput, WorkspaceUncheckedCreateWithoutPositionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutPositionsInput
    upsert?: WorkspaceUpsertWithoutPositionsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutPositionsInput, WorkspaceUpdateWithoutPositionsInput>, WorkspaceUncheckedUpdateWithoutPositionsInput>
  }

  export type EmployeeUpdateManyWithoutPositionNestedInput = {
    create?: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput> | EmployeeCreateWithoutPositionInput[] | EmployeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionInput | EmployeeCreateOrConnectWithoutPositionInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutPositionInput | EmployeeUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: EmployeeCreateManyPositionInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutPositionInput | EmployeeUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutPositionInput | EmployeeUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmploymentHistoryUpdateManyWithoutPositionNestedInput = {
    create?: XOR<EmploymentHistoryCreateWithoutPositionInput, EmploymentHistoryUncheckedCreateWithoutPositionInput> | EmploymentHistoryCreateWithoutPositionInput[] | EmploymentHistoryUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmploymentHistoryCreateOrConnectWithoutPositionInput | EmploymentHistoryCreateOrConnectWithoutPositionInput[]
    upsert?: EmploymentHistoryUpsertWithWhereUniqueWithoutPositionInput | EmploymentHistoryUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: EmploymentHistoryCreateManyPositionInputEnvelope
    set?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    disconnect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    delete?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    connect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    update?: EmploymentHistoryUpdateWithWhereUniqueWithoutPositionInput | EmploymentHistoryUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: EmploymentHistoryUpdateManyWithWhereWithoutPositionInput | EmploymentHistoryUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: EmploymentHistoryScalarWhereInput | EmploymentHistoryScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput> | EmployeeCreateWithoutPositionInput[] | EmployeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionInput | EmployeeCreateOrConnectWithoutPositionInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutPositionInput | EmployeeUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: EmployeeCreateManyPositionInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutPositionInput | EmployeeUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutPositionInput | EmployeeUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmploymentHistoryUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<EmploymentHistoryCreateWithoutPositionInput, EmploymentHistoryUncheckedCreateWithoutPositionInput> | EmploymentHistoryCreateWithoutPositionInput[] | EmploymentHistoryUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmploymentHistoryCreateOrConnectWithoutPositionInput | EmploymentHistoryCreateOrConnectWithoutPositionInput[]
    upsert?: EmploymentHistoryUpsertWithWhereUniqueWithoutPositionInput | EmploymentHistoryUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: EmploymentHistoryCreateManyPositionInputEnvelope
    set?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    disconnect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    delete?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    connect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    update?: EmploymentHistoryUpdateWithWhereUniqueWithoutPositionInput | EmploymentHistoryUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: EmploymentHistoryUpdateManyWithWhereWithoutPositionInput | EmploymentHistoryUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: EmploymentHistoryScalarWhereInput | EmploymentHistoryScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutPositionLevelsInput = {
    create?: XOR<WorkspaceCreateWithoutPositionLevelsInput, WorkspaceUncheckedCreateWithoutPositionLevelsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutPositionLevelsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type EmployeeCreateNestedManyWithoutPositionLevelInput = {
    create?: XOR<EmployeeCreateWithoutPositionLevelInput, EmployeeUncheckedCreateWithoutPositionLevelInput> | EmployeeCreateWithoutPositionLevelInput[] | EmployeeUncheckedCreateWithoutPositionLevelInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionLevelInput | EmployeeCreateOrConnectWithoutPositionLevelInput[]
    createMany?: EmployeeCreateManyPositionLevelInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmploymentHistoryCreateNestedManyWithoutPositionLevelInput = {
    create?: XOR<EmploymentHistoryCreateWithoutPositionLevelInput, EmploymentHistoryUncheckedCreateWithoutPositionLevelInput> | EmploymentHistoryCreateWithoutPositionLevelInput[] | EmploymentHistoryUncheckedCreateWithoutPositionLevelInput[]
    connectOrCreate?: EmploymentHistoryCreateOrConnectWithoutPositionLevelInput | EmploymentHistoryCreateOrConnectWithoutPositionLevelInput[]
    createMany?: EmploymentHistoryCreateManyPositionLevelInputEnvelope
    connect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutPositionLevelInput = {
    create?: XOR<EmployeeCreateWithoutPositionLevelInput, EmployeeUncheckedCreateWithoutPositionLevelInput> | EmployeeCreateWithoutPositionLevelInput[] | EmployeeUncheckedCreateWithoutPositionLevelInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionLevelInput | EmployeeCreateOrConnectWithoutPositionLevelInput[]
    createMany?: EmployeeCreateManyPositionLevelInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmploymentHistoryUncheckedCreateNestedManyWithoutPositionLevelInput = {
    create?: XOR<EmploymentHistoryCreateWithoutPositionLevelInput, EmploymentHistoryUncheckedCreateWithoutPositionLevelInput> | EmploymentHistoryCreateWithoutPositionLevelInput[] | EmploymentHistoryUncheckedCreateWithoutPositionLevelInput[]
    connectOrCreate?: EmploymentHistoryCreateOrConnectWithoutPositionLevelInput | EmploymentHistoryCreateOrConnectWithoutPositionLevelInput[]
    createMany?: EmploymentHistoryCreateManyPositionLevelInputEnvelope
    connect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkspaceUpdateOneRequiredWithoutPositionLevelsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutPositionLevelsInput, WorkspaceUncheckedCreateWithoutPositionLevelsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutPositionLevelsInput
    upsert?: WorkspaceUpsertWithoutPositionLevelsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutPositionLevelsInput, WorkspaceUpdateWithoutPositionLevelsInput>, WorkspaceUncheckedUpdateWithoutPositionLevelsInput>
  }

  export type EmployeeUpdateManyWithoutPositionLevelNestedInput = {
    create?: XOR<EmployeeCreateWithoutPositionLevelInput, EmployeeUncheckedCreateWithoutPositionLevelInput> | EmployeeCreateWithoutPositionLevelInput[] | EmployeeUncheckedCreateWithoutPositionLevelInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionLevelInput | EmployeeCreateOrConnectWithoutPositionLevelInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutPositionLevelInput | EmployeeUpsertWithWhereUniqueWithoutPositionLevelInput[]
    createMany?: EmployeeCreateManyPositionLevelInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutPositionLevelInput | EmployeeUpdateWithWhereUniqueWithoutPositionLevelInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutPositionLevelInput | EmployeeUpdateManyWithWhereWithoutPositionLevelInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmploymentHistoryUpdateManyWithoutPositionLevelNestedInput = {
    create?: XOR<EmploymentHistoryCreateWithoutPositionLevelInput, EmploymentHistoryUncheckedCreateWithoutPositionLevelInput> | EmploymentHistoryCreateWithoutPositionLevelInput[] | EmploymentHistoryUncheckedCreateWithoutPositionLevelInput[]
    connectOrCreate?: EmploymentHistoryCreateOrConnectWithoutPositionLevelInput | EmploymentHistoryCreateOrConnectWithoutPositionLevelInput[]
    upsert?: EmploymentHistoryUpsertWithWhereUniqueWithoutPositionLevelInput | EmploymentHistoryUpsertWithWhereUniqueWithoutPositionLevelInput[]
    createMany?: EmploymentHistoryCreateManyPositionLevelInputEnvelope
    set?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    disconnect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    delete?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    connect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    update?: EmploymentHistoryUpdateWithWhereUniqueWithoutPositionLevelInput | EmploymentHistoryUpdateWithWhereUniqueWithoutPositionLevelInput[]
    updateMany?: EmploymentHistoryUpdateManyWithWhereWithoutPositionLevelInput | EmploymentHistoryUpdateManyWithWhereWithoutPositionLevelInput[]
    deleteMany?: EmploymentHistoryScalarWhereInput | EmploymentHistoryScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutPositionLevelNestedInput = {
    create?: XOR<EmployeeCreateWithoutPositionLevelInput, EmployeeUncheckedCreateWithoutPositionLevelInput> | EmployeeCreateWithoutPositionLevelInput[] | EmployeeUncheckedCreateWithoutPositionLevelInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionLevelInput | EmployeeCreateOrConnectWithoutPositionLevelInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutPositionLevelInput | EmployeeUpsertWithWhereUniqueWithoutPositionLevelInput[]
    createMany?: EmployeeCreateManyPositionLevelInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutPositionLevelInput | EmployeeUpdateWithWhereUniqueWithoutPositionLevelInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutPositionLevelInput | EmployeeUpdateManyWithWhereWithoutPositionLevelInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmploymentHistoryUncheckedUpdateManyWithoutPositionLevelNestedInput = {
    create?: XOR<EmploymentHistoryCreateWithoutPositionLevelInput, EmploymentHistoryUncheckedCreateWithoutPositionLevelInput> | EmploymentHistoryCreateWithoutPositionLevelInput[] | EmploymentHistoryUncheckedCreateWithoutPositionLevelInput[]
    connectOrCreate?: EmploymentHistoryCreateOrConnectWithoutPositionLevelInput | EmploymentHistoryCreateOrConnectWithoutPositionLevelInput[]
    upsert?: EmploymentHistoryUpsertWithWhereUniqueWithoutPositionLevelInput | EmploymentHistoryUpsertWithWhereUniqueWithoutPositionLevelInput[]
    createMany?: EmploymentHistoryCreateManyPositionLevelInputEnvelope
    set?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    disconnect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    delete?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    connect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    update?: EmploymentHistoryUpdateWithWhereUniqueWithoutPositionLevelInput | EmploymentHistoryUpdateWithWhereUniqueWithoutPositionLevelInput[]
    updateMany?: EmploymentHistoryUpdateManyWithWhereWithoutPositionLevelInput | EmploymentHistoryUpdateManyWithWhereWithoutPositionLevelInput[]
    deleteMany?: EmploymentHistoryScalarWhereInput | EmploymentHistoryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<WorkspaceCreateWithoutEmployeesInput, WorkspaceUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutEmployeesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type DepartmentCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<TeamCreateWithoutEmployeesInput, TeamUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutEmployeesInput
    connect?: TeamWhereUniqueInput
  }

  export type PositionCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<PositionCreateWithoutEmployeesInput, PositionUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: PositionCreateOrConnectWithoutEmployeesInput
    connect?: PositionWhereUniqueInput
  }

  export type PositionLevelCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<PositionLevelCreateWithoutEmployeesInput, PositionLevelUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: PositionLevelCreateOrConnectWithoutEmployeesInput
    connect?: PositionLevelWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutSubordinatesInput = {
    create?: XOR<EmployeeCreateWithoutSubordinatesInput, EmployeeUncheckedCreateWithoutSubordinatesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSubordinatesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeCreateNestedManyWithoutManagerInput = {
    create?: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput> | EmployeeCreateWithoutManagerInput[] | EmployeeUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutManagerInput | EmployeeCreateOrConnectWithoutManagerInput[]
    createMany?: EmployeeCreateManyManagerInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type ProjectMemberCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ProjectMemberCreateWithoutEmployeeInput, ProjectMemberUncheckedCreateWithoutEmployeeInput> | ProjectMemberCreateWithoutEmployeeInput[] | ProjectMemberUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutEmployeeInput | ProjectMemberCreateOrConnectWithoutEmployeeInput[]
    createMany?: ProjectMemberCreateManyEmployeeInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type EmploymentHistoryCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmploymentHistoryCreateWithoutEmployeeInput, EmploymentHistoryUncheckedCreateWithoutEmployeeInput> | EmploymentHistoryCreateWithoutEmployeeInput[] | EmploymentHistoryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmploymentHistoryCreateOrConnectWithoutEmployeeInput | EmploymentHistoryCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmploymentHistoryCreateManyEmployeeInputEnvelope
    connect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
  }

  export type EmployeeDocumentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeDocumentCreateWithoutEmployeeInput, EmployeeDocumentUncheckedCreateWithoutEmployeeInput> | EmployeeDocumentCreateWithoutEmployeeInput[] | EmployeeDocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeDocumentCreateOrConnectWithoutEmployeeInput | EmployeeDocumentCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeDocumentCreateManyEmployeeInputEnvelope
    connect?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
  }

  export type LeaveQuotaCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveQuotaCreateWithoutEmployeeInput, LeaveQuotaUncheckedCreateWithoutEmployeeInput> | LeaveQuotaCreateWithoutEmployeeInput[] | LeaveQuotaUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveQuotaCreateOrConnectWithoutEmployeeInput | LeaveQuotaCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveQuotaCreateManyEmployeeInputEnvelope
    connect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
  }

  export type LeaveCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type OvertimeCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<OvertimeCreateWithoutEmployeeInput, OvertimeUncheckedCreateWithoutEmployeeInput> | OvertimeCreateWithoutEmployeeInput[] | OvertimeUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutEmployeeInput | OvertimeCreateOrConnectWithoutEmployeeInput[]
    createMany?: OvertimeCreateManyEmployeeInputEnvelope
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput> | EmployeeCreateWithoutManagerInput[] | EmployeeUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutManagerInput | EmployeeCreateOrConnectWithoutManagerInput[]
    createMany?: EmployeeCreateManyManagerInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ProjectMemberCreateWithoutEmployeeInput, ProjectMemberUncheckedCreateWithoutEmployeeInput> | ProjectMemberCreateWithoutEmployeeInput[] | ProjectMemberUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutEmployeeInput | ProjectMemberCreateOrConnectWithoutEmployeeInput[]
    createMany?: ProjectMemberCreateManyEmployeeInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type EmploymentHistoryUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmploymentHistoryCreateWithoutEmployeeInput, EmploymentHistoryUncheckedCreateWithoutEmployeeInput> | EmploymentHistoryCreateWithoutEmployeeInput[] | EmploymentHistoryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmploymentHistoryCreateOrConnectWithoutEmployeeInput | EmploymentHistoryCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmploymentHistoryCreateManyEmployeeInputEnvelope
    connect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
  }

  export type EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeDocumentCreateWithoutEmployeeInput, EmployeeDocumentUncheckedCreateWithoutEmployeeInput> | EmployeeDocumentCreateWithoutEmployeeInput[] | EmployeeDocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeDocumentCreateOrConnectWithoutEmployeeInput | EmployeeDocumentCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeDocumentCreateManyEmployeeInputEnvelope
    connect?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
  }

  export type LeaveQuotaUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveQuotaCreateWithoutEmployeeInput, LeaveQuotaUncheckedCreateWithoutEmployeeInput> | LeaveQuotaCreateWithoutEmployeeInput[] | LeaveQuotaUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveQuotaCreateOrConnectWithoutEmployeeInput | LeaveQuotaCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveQuotaCreateManyEmployeeInputEnvelope
    connect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
  }

  export type LeaveUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type OvertimeUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<OvertimeCreateWithoutEmployeeInput, OvertimeUncheckedCreateWithoutEmployeeInput> | OvertimeCreateWithoutEmployeeInput[] | OvertimeUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutEmployeeInput | OvertimeCreateOrConnectWithoutEmployeeInput[]
    createMany?: OvertimeCreateManyEmployeeInputEnvelope
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
  }

  export type EnumEmployeeStatusFieldUpdateOperationsInput = {
    set?: $Enums.EmployeeStatus
  }

  export type EnumEmploymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.EmploymentType
  }

  export type UserUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    upsert?: UserUpsertWithoutEmployeeInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeInput, UserUpdateWithoutEmployeeInput>, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutEmployeesInput, WorkspaceUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutEmployeesInput
    upsert?: WorkspaceUpsertWithoutEmployeesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutEmployeesInput, WorkspaceUpdateWithoutEmployeesInput>, WorkspaceUncheckedUpdateWithoutEmployeesInput>
  }

  export type DepartmentUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeesInput
    upsert?: DepartmentUpsertWithoutEmployeesInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutEmployeesInput, DepartmentUpdateWithoutEmployeesInput>, DepartmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type TeamUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<TeamCreateWithoutEmployeesInput, TeamUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutEmployeesInput
    upsert?: TeamUpsertWithoutEmployeesInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutEmployeesInput, TeamUpdateWithoutEmployeesInput>, TeamUncheckedUpdateWithoutEmployeesInput>
  }

  export type PositionUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<PositionCreateWithoutEmployeesInput, PositionUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: PositionCreateOrConnectWithoutEmployeesInput
    upsert?: PositionUpsertWithoutEmployeesInput
    disconnect?: PositionWhereInput | boolean
    delete?: PositionWhereInput | boolean
    connect?: PositionWhereUniqueInput
    update?: XOR<XOR<PositionUpdateToOneWithWhereWithoutEmployeesInput, PositionUpdateWithoutEmployeesInput>, PositionUncheckedUpdateWithoutEmployeesInput>
  }

  export type PositionLevelUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<PositionLevelCreateWithoutEmployeesInput, PositionLevelUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: PositionLevelCreateOrConnectWithoutEmployeesInput
    upsert?: PositionLevelUpsertWithoutEmployeesInput
    disconnect?: PositionLevelWhereInput | boolean
    delete?: PositionLevelWhereInput | boolean
    connect?: PositionLevelWhereUniqueInput
    update?: XOR<XOR<PositionLevelUpdateToOneWithWhereWithoutEmployeesInput, PositionLevelUpdateWithoutEmployeesInput>, PositionLevelUncheckedUpdateWithoutEmployeesInput>
  }

  export type EmployeeUpdateOneWithoutSubordinatesNestedInput = {
    create?: XOR<EmployeeCreateWithoutSubordinatesInput, EmployeeUncheckedCreateWithoutSubordinatesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutSubordinatesInput
    upsert?: EmployeeUpsertWithoutSubordinatesInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutSubordinatesInput, EmployeeUpdateWithoutSubordinatesInput>, EmployeeUncheckedUpdateWithoutSubordinatesInput>
  }

  export type EmployeeUpdateManyWithoutManagerNestedInput = {
    create?: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput> | EmployeeCreateWithoutManagerInput[] | EmployeeUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutManagerInput | EmployeeCreateOrConnectWithoutManagerInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutManagerInput | EmployeeUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: EmployeeCreateManyManagerInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutManagerInput | EmployeeUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutManagerInput | EmployeeUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type ProjectMemberUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutEmployeeInput, ProjectMemberUncheckedCreateWithoutEmployeeInput> | ProjectMemberCreateWithoutEmployeeInput[] | ProjectMemberUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutEmployeeInput | ProjectMemberCreateOrConnectWithoutEmployeeInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutEmployeeInput | ProjectMemberUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ProjectMemberCreateManyEmployeeInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutEmployeeInput | ProjectMemberUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutEmployeeInput | ProjectMemberUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type EmploymentHistoryUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmploymentHistoryCreateWithoutEmployeeInput, EmploymentHistoryUncheckedCreateWithoutEmployeeInput> | EmploymentHistoryCreateWithoutEmployeeInput[] | EmploymentHistoryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmploymentHistoryCreateOrConnectWithoutEmployeeInput | EmploymentHistoryCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmploymentHistoryUpsertWithWhereUniqueWithoutEmployeeInput | EmploymentHistoryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmploymentHistoryCreateManyEmployeeInputEnvelope
    set?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    disconnect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    delete?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    connect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    update?: EmploymentHistoryUpdateWithWhereUniqueWithoutEmployeeInput | EmploymentHistoryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmploymentHistoryUpdateManyWithWhereWithoutEmployeeInput | EmploymentHistoryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmploymentHistoryScalarWhereInput | EmploymentHistoryScalarWhereInput[]
  }

  export type EmployeeDocumentUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeDocumentCreateWithoutEmployeeInput, EmployeeDocumentUncheckedCreateWithoutEmployeeInput> | EmployeeDocumentCreateWithoutEmployeeInput[] | EmployeeDocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeDocumentCreateOrConnectWithoutEmployeeInput | EmployeeDocumentCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeDocumentUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeDocumentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeDocumentCreateManyEmployeeInputEnvelope
    set?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
    disconnect?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
    delete?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
    connect?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
    update?: EmployeeDocumentUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeDocumentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeDocumentUpdateManyWithWhereWithoutEmployeeInput | EmployeeDocumentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeDocumentScalarWhereInput | EmployeeDocumentScalarWhereInput[]
  }

  export type LeaveQuotaUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveQuotaCreateWithoutEmployeeInput, LeaveQuotaUncheckedCreateWithoutEmployeeInput> | LeaveQuotaCreateWithoutEmployeeInput[] | LeaveQuotaUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveQuotaCreateOrConnectWithoutEmployeeInput | LeaveQuotaCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveQuotaUpsertWithWhereUniqueWithoutEmployeeInput | LeaveQuotaUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveQuotaCreateManyEmployeeInputEnvelope
    set?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    disconnect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    delete?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    connect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    update?: LeaveQuotaUpdateWithWhereUniqueWithoutEmployeeInput | LeaveQuotaUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveQuotaUpdateManyWithWhereWithoutEmployeeInput | LeaveQuotaUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveQuotaScalarWhereInput | LeaveQuotaScalarWhereInput[]
  }

  export type LeaveUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutEmployeeInput | LeaveUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutEmployeeInput | LeaveUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutEmployeeInput | LeaveUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type OvertimeUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<OvertimeCreateWithoutEmployeeInput, OvertimeUncheckedCreateWithoutEmployeeInput> | OvertimeCreateWithoutEmployeeInput[] | OvertimeUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutEmployeeInput | OvertimeCreateOrConnectWithoutEmployeeInput[]
    upsert?: OvertimeUpsertWithWhereUniqueWithoutEmployeeInput | OvertimeUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: OvertimeCreateManyEmployeeInputEnvelope
    set?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    disconnect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    delete?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    update?: OvertimeUpdateWithWhereUniqueWithoutEmployeeInput | OvertimeUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: OvertimeUpdateManyWithWhereWithoutEmployeeInput | OvertimeUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput> | EmployeeCreateWithoutManagerInput[] | EmployeeUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutManagerInput | EmployeeCreateOrConnectWithoutManagerInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutManagerInput | EmployeeUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: EmployeeCreateManyManagerInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutManagerInput | EmployeeUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutManagerInput | EmployeeUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutEmployeeInput, ProjectMemberUncheckedCreateWithoutEmployeeInput> | ProjectMemberCreateWithoutEmployeeInput[] | ProjectMemberUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutEmployeeInput | ProjectMemberCreateOrConnectWithoutEmployeeInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutEmployeeInput | ProjectMemberUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ProjectMemberCreateManyEmployeeInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutEmployeeInput | ProjectMemberUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutEmployeeInput | ProjectMemberUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type EmploymentHistoryUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmploymentHistoryCreateWithoutEmployeeInput, EmploymentHistoryUncheckedCreateWithoutEmployeeInput> | EmploymentHistoryCreateWithoutEmployeeInput[] | EmploymentHistoryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmploymentHistoryCreateOrConnectWithoutEmployeeInput | EmploymentHistoryCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmploymentHistoryUpsertWithWhereUniqueWithoutEmployeeInput | EmploymentHistoryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmploymentHistoryCreateManyEmployeeInputEnvelope
    set?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    disconnect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    delete?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    connect?: EmploymentHistoryWhereUniqueInput | EmploymentHistoryWhereUniqueInput[]
    update?: EmploymentHistoryUpdateWithWhereUniqueWithoutEmployeeInput | EmploymentHistoryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmploymentHistoryUpdateManyWithWhereWithoutEmployeeInput | EmploymentHistoryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmploymentHistoryScalarWhereInput | EmploymentHistoryScalarWhereInput[]
  }

  export type EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeDocumentCreateWithoutEmployeeInput, EmployeeDocumentUncheckedCreateWithoutEmployeeInput> | EmployeeDocumentCreateWithoutEmployeeInput[] | EmployeeDocumentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeDocumentCreateOrConnectWithoutEmployeeInput | EmployeeDocumentCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeDocumentUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeDocumentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeDocumentCreateManyEmployeeInputEnvelope
    set?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
    disconnect?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
    delete?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
    connect?: EmployeeDocumentWhereUniqueInput | EmployeeDocumentWhereUniqueInput[]
    update?: EmployeeDocumentUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeDocumentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeDocumentUpdateManyWithWhereWithoutEmployeeInput | EmployeeDocumentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeDocumentScalarWhereInput | EmployeeDocumentScalarWhereInput[]
  }

  export type LeaveQuotaUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveQuotaCreateWithoutEmployeeInput, LeaveQuotaUncheckedCreateWithoutEmployeeInput> | LeaveQuotaCreateWithoutEmployeeInput[] | LeaveQuotaUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveQuotaCreateOrConnectWithoutEmployeeInput | LeaveQuotaCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveQuotaUpsertWithWhereUniqueWithoutEmployeeInput | LeaveQuotaUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveQuotaCreateManyEmployeeInputEnvelope
    set?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    disconnect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    delete?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    connect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    update?: LeaveQuotaUpdateWithWhereUniqueWithoutEmployeeInput | LeaveQuotaUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveQuotaUpdateManyWithWhereWithoutEmployeeInput | LeaveQuotaUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveQuotaScalarWhereInput | LeaveQuotaScalarWhereInput[]
  }

  export type LeaveUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput> | LeaveCreateWithoutEmployeeInput[] | LeaveUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutEmployeeInput | LeaveCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutEmployeeInput | LeaveUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveCreateManyEmployeeInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutEmployeeInput | LeaveUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutEmployeeInput | LeaveUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type OvertimeUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<OvertimeCreateWithoutEmployeeInput, OvertimeUncheckedCreateWithoutEmployeeInput> | OvertimeCreateWithoutEmployeeInput[] | OvertimeUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutEmployeeInput | OvertimeCreateOrConnectWithoutEmployeeInput[]
    upsert?: OvertimeUpsertWithWhereUniqueWithoutEmployeeInput | OvertimeUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: OvertimeCreateManyEmployeeInputEnvelope
    set?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    disconnect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    delete?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    update?: OvertimeUpdateWithWhereUniqueWithoutEmployeeInput | OvertimeUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: OvertimeUpdateManyWithWhereWithoutEmployeeInput | OvertimeUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutEmploymentHistoryInput = {
    create?: XOR<EmployeeCreateWithoutEmploymentHistoryInput, EmployeeUncheckedCreateWithoutEmploymentHistoryInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmploymentHistoryInput
    connect?: EmployeeWhereUniqueInput
  }

  export type PositionCreateNestedOneWithoutEmploymentHistoryInput = {
    create?: XOR<PositionCreateWithoutEmploymentHistoryInput, PositionUncheckedCreateWithoutEmploymentHistoryInput>
    connectOrCreate?: PositionCreateOrConnectWithoutEmploymentHistoryInput
    connect?: PositionWhereUniqueInput
  }

  export type PositionLevelCreateNestedOneWithoutEmploymentHistoryInput = {
    create?: XOR<PositionLevelCreateWithoutEmploymentHistoryInput, PositionLevelUncheckedCreateWithoutEmploymentHistoryInput>
    connectOrCreate?: PositionLevelCreateOrConnectWithoutEmploymentHistoryInput
    connect?: PositionLevelWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EmployeeUpdateOneRequiredWithoutEmploymentHistoryNestedInput = {
    create?: XOR<EmployeeCreateWithoutEmploymentHistoryInput, EmployeeUncheckedCreateWithoutEmploymentHistoryInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmploymentHistoryInput
    upsert?: EmployeeUpsertWithoutEmploymentHistoryInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutEmploymentHistoryInput, EmployeeUpdateWithoutEmploymentHistoryInput>, EmployeeUncheckedUpdateWithoutEmploymentHistoryInput>
  }

  export type PositionUpdateOneRequiredWithoutEmploymentHistoryNestedInput = {
    create?: XOR<PositionCreateWithoutEmploymentHistoryInput, PositionUncheckedCreateWithoutEmploymentHistoryInput>
    connectOrCreate?: PositionCreateOrConnectWithoutEmploymentHistoryInput
    upsert?: PositionUpsertWithoutEmploymentHistoryInput
    connect?: PositionWhereUniqueInput
    update?: XOR<XOR<PositionUpdateToOneWithWhereWithoutEmploymentHistoryInput, PositionUpdateWithoutEmploymentHistoryInput>, PositionUncheckedUpdateWithoutEmploymentHistoryInput>
  }

  export type PositionLevelUpdateOneWithoutEmploymentHistoryNestedInput = {
    create?: XOR<PositionLevelCreateWithoutEmploymentHistoryInput, PositionLevelUncheckedCreateWithoutEmploymentHistoryInput>
    connectOrCreate?: PositionLevelCreateOrConnectWithoutEmploymentHistoryInput
    upsert?: PositionLevelUpsertWithoutEmploymentHistoryInput
    disconnect?: PositionLevelWhereInput | boolean
    delete?: PositionLevelWhereInput | boolean
    connect?: PositionLevelWhereUniqueInput
    update?: XOR<XOR<PositionLevelUpdateToOneWithWhereWithoutEmploymentHistoryInput, PositionLevelUpdateWithoutEmploymentHistoryInput>, PositionLevelUncheckedUpdateWithoutEmploymentHistoryInput>
  }

  export type EmployeeCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDocumentsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutDocumentsInput
    upsert?: EmployeeUpsertWithoutDocumentsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutDocumentsInput, EmployeeUpdateWithoutDocumentsInput>, EmployeeUncheckedUpdateWithoutDocumentsInput>
  }

  export type WorkspaceCreateNestedOneWithoutProjectsInput = {
    create?: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutProjectsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type ProjectMemberCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type EnumProjectPriorityFieldUpdateOperationsInput = {
    set?: $Enums.ProjectPriority
  }

  export type WorkspaceUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutProjectsInput
    upsert?: WorkspaceUpsertWithoutProjectsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutProjectsInput, WorkspaceUpdateWithoutProjectsInput>, WorkspaceUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectMemberUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput> | ProjectMemberCreateWithoutProjectInput[] | ProjectMemberUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectInput | ProjectMemberCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectMemberCreateManyProjectInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectInput | ProjectMemberUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutMembersInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    connect?: ProjectWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutProjectMembersInput = {
    create?: XOR<EmployeeCreateWithoutProjectMembersInput, EmployeeUncheckedCreateWithoutProjectMembersInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutProjectMembersInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ProjectRoleCreateNestedOneWithoutProjectMembersInput = {
    create?: XOR<ProjectRoleCreateWithoutProjectMembersInput, ProjectRoleUncheckedCreateWithoutProjectMembersInput>
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutProjectMembersInput
    connect?: ProjectRoleWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMembersInput
    upsert?: ProjectUpsertWithoutMembersInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMembersInput, ProjectUpdateWithoutMembersInput>, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type EmployeeUpdateOneRequiredWithoutProjectMembersNestedInput = {
    create?: XOR<EmployeeCreateWithoutProjectMembersInput, EmployeeUncheckedCreateWithoutProjectMembersInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutProjectMembersInput
    upsert?: EmployeeUpsertWithoutProjectMembersInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutProjectMembersInput, EmployeeUpdateWithoutProjectMembersInput>, EmployeeUncheckedUpdateWithoutProjectMembersInput>
  }

  export type ProjectRoleUpdateOneRequiredWithoutProjectMembersNestedInput = {
    create?: XOR<ProjectRoleCreateWithoutProjectMembersInput, ProjectRoleUncheckedCreateWithoutProjectMembersInput>
    connectOrCreate?: ProjectRoleCreateOrConnectWithoutProjectMembersInput
    upsert?: ProjectRoleUpsertWithoutProjectMembersInput
    connect?: ProjectRoleWhereUniqueInput
    update?: XOR<XOR<ProjectRoleUpdateToOneWithWhereWithoutProjectMembersInput, ProjectRoleUpdateWithoutProjectMembersInput>, ProjectRoleUncheckedUpdateWithoutProjectMembersInput>
  }

  export type WorkspaceCreateNestedOneWithoutProjectRolesInput = {
    create?: XOR<WorkspaceCreateWithoutProjectRolesInput, WorkspaceUncheckedCreateWithoutProjectRolesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutProjectRolesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type ProjectMemberCreateNestedManyWithoutProjectRoleInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectRoleInput, ProjectMemberUncheckedCreateWithoutProjectRoleInput> | ProjectMemberCreateWithoutProjectRoleInput[] | ProjectMemberUncheckedCreateWithoutProjectRoleInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectRoleInput | ProjectMemberCreateOrConnectWithoutProjectRoleInput[]
    createMany?: ProjectMemberCreateManyProjectRoleInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type ProjectMemberUncheckedCreateNestedManyWithoutProjectRoleInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectRoleInput, ProjectMemberUncheckedCreateWithoutProjectRoleInput> | ProjectMemberCreateWithoutProjectRoleInput[] | ProjectMemberUncheckedCreateWithoutProjectRoleInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectRoleInput | ProjectMemberCreateOrConnectWithoutProjectRoleInput[]
    createMany?: ProjectMemberCreateManyProjectRoleInputEnvelope
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
  }

  export type WorkspaceUpdateOneWithoutProjectRolesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutProjectRolesInput, WorkspaceUncheckedCreateWithoutProjectRolesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutProjectRolesInput
    upsert?: WorkspaceUpsertWithoutProjectRolesInput
    disconnect?: WorkspaceWhereInput | boolean
    delete?: WorkspaceWhereInput | boolean
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutProjectRolesInput, WorkspaceUpdateWithoutProjectRolesInput>, WorkspaceUncheckedUpdateWithoutProjectRolesInput>
  }

  export type ProjectMemberUpdateManyWithoutProjectRoleNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectRoleInput, ProjectMemberUncheckedCreateWithoutProjectRoleInput> | ProjectMemberCreateWithoutProjectRoleInput[] | ProjectMemberUncheckedCreateWithoutProjectRoleInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectRoleInput | ProjectMemberCreateOrConnectWithoutProjectRoleInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectRoleInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectRoleInput[]
    createMany?: ProjectMemberCreateManyProjectRoleInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectRoleInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectRoleInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectRoleInput | ProjectMemberUpdateManyWithWhereWithoutProjectRoleInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectRoleNestedInput = {
    create?: XOR<ProjectMemberCreateWithoutProjectRoleInput, ProjectMemberUncheckedCreateWithoutProjectRoleInput> | ProjectMemberCreateWithoutProjectRoleInput[] | ProjectMemberUncheckedCreateWithoutProjectRoleInput[]
    connectOrCreate?: ProjectMemberCreateOrConnectWithoutProjectRoleInput | ProjectMemberCreateOrConnectWithoutProjectRoleInput[]
    upsert?: ProjectMemberUpsertWithWhereUniqueWithoutProjectRoleInput | ProjectMemberUpsertWithWhereUniqueWithoutProjectRoleInput[]
    createMany?: ProjectMemberCreateManyProjectRoleInputEnvelope
    set?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    disconnect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    delete?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    connect?: ProjectMemberWhereUniqueInput | ProjectMemberWhereUniqueInput[]
    update?: ProjectMemberUpdateWithWhereUniqueWithoutProjectRoleInput | ProjectMemberUpdateWithWhereUniqueWithoutProjectRoleInput[]
    updateMany?: ProjectMemberUpdateManyWithWhereWithoutProjectRoleInput | ProjectMemberUpdateManyWithWhereWithoutProjectRoleInput[]
    deleteMany?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutLeaveTypesInput = {
    create?: XOR<WorkspaceCreateWithoutLeaveTypesInput, WorkspaceUncheckedCreateWithoutLeaveTypesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutLeaveTypesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type LeaveQuotaCreateNestedManyWithoutLeaveTypeInput = {
    create?: XOR<LeaveQuotaCreateWithoutLeaveTypeInput, LeaveQuotaUncheckedCreateWithoutLeaveTypeInput> | LeaveQuotaCreateWithoutLeaveTypeInput[] | LeaveQuotaUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveQuotaCreateOrConnectWithoutLeaveTypeInput | LeaveQuotaCreateOrConnectWithoutLeaveTypeInput[]
    createMany?: LeaveQuotaCreateManyLeaveTypeInputEnvelope
    connect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
  }

  export type LeaveCreateNestedManyWithoutLeaveTypeInput = {
    create?: XOR<LeaveCreateWithoutLeaveTypeInput, LeaveUncheckedCreateWithoutLeaveTypeInput> | LeaveCreateWithoutLeaveTypeInput[] | LeaveUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutLeaveTypeInput | LeaveCreateOrConnectWithoutLeaveTypeInput[]
    createMany?: LeaveCreateManyLeaveTypeInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type LeaveQuotaUncheckedCreateNestedManyWithoutLeaveTypeInput = {
    create?: XOR<LeaveQuotaCreateWithoutLeaveTypeInput, LeaveQuotaUncheckedCreateWithoutLeaveTypeInput> | LeaveQuotaCreateWithoutLeaveTypeInput[] | LeaveQuotaUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveQuotaCreateOrConnectWithoutLeaveTypeInput | LeaveQuotaCreateOrConnectWithoutLeaveTypeInput[]
    createMany?: LeaveQuotaCreateManyLeaveTypeInputEnvelope
    connect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
  }

  export type LeaveUncheckedCreateNestedManyWithoutLeaveTypeInput = {
    create?: XOR<LeaveCreateWithoutLeaveTypeInput, LeaveUncheckedCreateWithoutLeaveTypeInput> | LeaveCreateWithoutLeaveTypeInput[] | LeaveUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutLeaveTypeInput | LeaveCreateOrConnectWithoutLeaveTypeInput[]
    createMany?: LeaveCreateManyLeaveTypeInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type WorkspaceUpdateOneRequiredWithoutLeaveTypesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutLeaveTypesInput, WorkspaceUncheckedCreateWithoutLeaveTypesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutLeaveTypesInput
    upsert?: WorkspaceUpsertWithoutLeaveTypesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutLeaveTypesInput, WorkspaceUpdateWithoutLeaveTypesInput>, WorkspaceUncheckedUpdateWithoutLeaveTypesInput>
  }

  export type LeaveQuotaUpdateManyWithoutLeaveTypeNestedInput = {
    create?: XOR<LeaveQuotaCreateWithoutLeaveTypeInput, LeaveQuotaUncheckedCreateWithoutLeaveTypeInput> | LeaveQuotaCreateWithoutLeaveTypeInput[] | LeaveQuotaUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveQuotaCreateOrConnectWithoutLeaveTypeInput | LeaveQuotaCreateOrConnectWithoutLeaveTypeInput[]
    upsert?: LeaveQuotaUpsertWithWhereUniqueWithoutLeaveTypeInput | LeaveQuotaUpsertWithWhereUniqueWithoutLeaveTypeInput[]
    createMany?: LeaveQuotaCreateManyLeaveTypeInputEnvelope
    set?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    disconnect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    delete?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    connect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    update?: LeaveQuotaUpdateWithWhereUniqueWithoutLeaveTypeInput | LeaveQuotaUpdateWithWhereUniqueWithoutLeaveTypeInput[]
    updateMany?: LeaveQuotaUpdateManyWithWhereWithoutLeaveTypeInput | LeaveQuotaUpdateManyWithWhereWithoutLeaveTypeInput[]
    deleteMany?: LeaveQuotaScalarWhereInput | LeaveQuotaScalarWhereInput[]
  }

  export type LeaveUpdateManyWithoutLeaveTypeNestedInput = {
    create?: XOR<LeaveCreateWithoutLeaveTypeInput, LeaveUncheckedCreateWithoutLeaveTypeInput> | LeaveCreateWithoutLeaveTypeInput[] | LeaveUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutLeaveTypeInput | LeaveCreateOrConnectWithoutLeaveTypeInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutLeaveTypeInput | LeaveUpsertWithWhereUniqueWithoutLeaveTypeInput[]
    createMany?: LeaveCreateManyLeaveTypeInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutLeaveTypeInput | LeaveUpdateWithWhereUniqueWithoutLeaveTypeInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutLeaveTypeInput | LeaveUpdateManyWithWhereWithoutLeaveTypeInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type LeaveQuotaUncheckedUpdateManyWithoutLeaveTypeNestedInput = {
    create?: XOR<LeaveQuotaCreateWithoutLeaveTypeInput, LeaveQuotaUncheckedCreateWithoutLeaveTypeInput> | LeaveQuotaCreateWithoutLeaveTypeInput[] | LeaveQuotaUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveQuotaCreateOrConnectWithoutLeaveTypeInput | LeaveQuotaCreateOrConnectWithoutLeaveTypeInput[]
    upsert?: LeaveQuotaUpsertWithWhereUniqueWithoutLeaveTypeInput | LeaveQuotaUpsertWithWhereUniqueWithoutLeaveTypeInput[]
    createMany?: LeaveQuotaCreateManyLeaveTypeInputEnvelope
    set?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    disconnect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    delete?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    connect?: LeaveQuotaWhereUniqueInput | LeaveQuotaWhereUniqueInput[]
    update?: LeaveQuotaUpdateWithWhereUniqueWithoutLeaveTypeInput | LeaveQuotaUpdateWithWhereUniqueWithoutLeaveTypeInput[]
    updateMany?: LeaveQuotaUpdateManyWithWhereWithoutLeaveTypeInput | LeaveQuotaUpdateManyWithWhereWithoutLeaveTypeInput[]
    deleteMany?: LeaveQuotaScalarWhereInput | LeaveQuotaScalarWhereInput[]
  }

  export type LeaveUncheckedUpdateManyWithoutLeaveTypeNestedInput = {
    create?: XOR<LeaveCreateWithoutLeaveTypeInput, LeaveUncheckedCreateWithoutLeaveTypeInput> | LeaveCreateWithoutLeaveTypeInput[] | LeaveUncheckedCreateWithoutLeaveTypeInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutLeaveTypeInput | LeaveCreateOrConnectWithoutLeaveTypeInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutLeaveTypeInput | LeaveUpsertWithWhereUniqueWithoutLeaveTypeInput[]
    createMany?: LeaveCreateManyLeaveTypeInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutLeaveTypeInput | LeaveUpdateWithWhereUniqueWithoutLeaveTypeInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutLeaveTypeInput | LeaveUpdateManyWithWhereWithoutLeaveTypeInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutLeaveQuotasInput = {
    create?: XOR<WorkspaceCreateWithoutLeaveQuotasInput, WorkspaceUncheckedCreateWithoutLeaveQuotasInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutLeaveQuotasInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutLeaveQuotasInput = {
    create?: XOR<EmployeeCreateWithoutLeaveQuotasInput, EmployeeUncheckedCreateWithoutLeaveQuotasInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeaveQuotasInput
    connect?: EmployeeWhereUniqueInput
  }

  export type LeaveTypeCreateNestedOneWithoutLeaveQuotasInput = {
    create?: XOR<LeaveTypeCreateWithoutLeaveQuotasInput, LeaveTypeUncheckedCreateWithoutLeaveQuotasInput>
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutLeaveQuotasInput
    connect?: LeaveTypeWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkspaceUpdateOneRequiredWithoutLeaveQuotasNestedInput = {
    create?: XOR<WorkspaceCreateWithoutLeaveQuotasInput, WorkspaceUncheckedCreateWithoutLeaveQuotasInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutLeaveQuotasInput
    upsert?: WorkspaceUpsertWithoutLeaveQuotasInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutLeaveQuotasInput, WorkspaceUpdateWithoutLeaveQuotasInput>, WorkspaceUncheckedUpdateWithoutLeaveQuotasInput>
  }

  export type EmployeeUpdateOneRequiredWithoutLeaveQuotasNestedInput = {
    create?: XOR<EmployeeCreateWithoutLeaveQuotasInput, EmployeeUncheckedCreateWithoutLeaveQuotasInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeaveQuotasInput
    upsert?: EmployeeUpsertWithoutLeaveQuotasInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLeaveQuotasInput, EmployeeUpdateWithoutLeaveQuotasInput>, EmployeeUncheckedUpdateWithoutLeaveQuotasInput>
  }

  export type LeaveTypeUpdateOneRequiredWithoutLeaveQuotasNestedInput = {
    create?: XOR<LeaveTypeCreateWithoutLeaveQuotasInput, LeaveTypeUncheckedCreateWithoutLeaveQuotasInput>
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutLeaveQuotasInput
    upsert?: LeaveTypeUpsertWithoutLeaveQuotasInput
    connect?: LeaveTypeWhereUniqueInput
    update?: XOR<XOR<LeaveTypeUpdateToOneWithWhereWithoutLeaveQuotasInput, LeaveTypeUpdateWithoutLeaveQuotasInput>, LeaveTypeUncheckedUpdateWithoutLeaveQuotasInput>
  }

  export type WorkspaceCreateNestedOneWithoutLeavesInput = {
    create?: XOR<WorkspaceCreateWithoutLeavesInput, WorkspaceUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutLeavesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutLeavesInput = {
    create?: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeavesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type LeaveTypeCreateNestedOneWithoutLeavesInput = {
    create?: XOR<LeaveTypeCreateWithoutLeavesInput, LeaveTypeUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutLeavesInput
    connect?: LeaveTypeWhereUniqueInput
  }

  export type ApprovalCreateNestedOneWithoutLeaveInput = {
    create?: XOR<ApprovalCreateWithoutLeaveInput, ApprovalUncheckedCreateWithoutLeaveInput>
    connectOrCreate?: ApprovalCreateOrConnectWithoutLeaveInput
    connect?: ApprovalWhereUniqueInput
  }

  export type ApprovalUncheckedCreateNestedOneWithoutLeaveInput = {
    create?: XOR<ApprovalCreateWithoutLeaveInput, ApprovalUncheckedCreateWithoutLeaveInput>
    connectOrCreate?: ApprovalCreateOrConnectWithoutLeaveInput
    connect?: ApprovalWhereUniqueInput
  }

  export type EnumLeaveStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeaveStatus
  }

  export type WorkspaceUpdateOneRequiredWithoutLeavesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutLeavesInput, WorkspaceUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutLeavesInput
    upsert?: WorkspaceUpsertWithoutLeavesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutLeavesInput, WorkspaceUpdateWithoutLeavesInput>, WorkspaceUncheckedUpdateWithoutLeavesInput>
  }

  export type EmployeeUpdateOneRequiredWithoutLeavesNestedInput = {
    create?: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeavesInput
    upsert?: EmployeeUpsertWithoutLeavesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLeavesInput, EmployeeUpdateWithoutLeavesInput>, EmployeeUncheckedUpdateWithoutLeavesInput>
  }

  export type LeaveTypeUpdateOneRequiredWithoutLeavesNestedInput = {
    create?: XOR<LeaveTypeCreateWithoutLeavesInput, LeaveTypeUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: LeaveTypeCreateOrConnectWithoutLeavesInput
    upsert?: LeaveTypeUpsertWithoutLeavesInput
    connect?: LeaveTypeWhereUniqueInput
    update?: XOR<XOR<LeaveTypeUpdateToOneWithWhereWithoutLeavesInput, LeaveTypeUpdateWithoutLeavesInput>, LeaveTypeUncheckedUpdateWithoutLeavesInput>
  }

  export type ApprovalUpdateOneWithoutLeaveNestedInput = {
    create?: XOR<ApprovalCreateWithoutLeaveInput, ApprovalUncheckedCreateWithoutLeaveInput>
    connectOrCreate?: ApprovalCreateOrConnectWithoutLeaveInput
    upsert?: ApprovalUpsertWithoutLeaveInput
    disconnect?: ApprovalWhereInput | boolean
    delete?: ApprovalWhereInput | boolean
    connect?: ApprovalWhereUniqueInput
    update?: XOR<XOR<ApprovalUpdateToOneWithWhereWithoutLeaveInput, ApprovalUpdateWithoutLeaveInput>, ApprovalUncheckedUpdateWithoutLeaveInput>
  }

  export type ApprovalUncheckedUpdateOneWithoutLeaveNestedInput = {
    create?: XOR<ApprovalCreateWithoutLeaveInput, ApprovalUncheckedCreateWithoutLeaveInput>
    connectOrCreate?: ApprovalCreateOrConnectWithoutLeaveInput
    upsert?: ApprovalUpsertWithoutLeaveInput
    disconnect?: ApprovalWhereInput | boolean
    delete?: ApprovalWhereInput | boolean
    connect?: ApprovalWhereUniqueInput
    update?: XOR<XOR<ApprovalUpdateToOneWithWhereWithoutLeaveInput, ApprovalUpdateWithoutLeaveInput>, ApprovalUncheckedUpdateWithoutLeaveInput>
  }

  export type WorkspaceCreateNestedOneWithoutOvertimePoliciesInput = {
    create?: XOR<WorkspaceCreateWithoutOvertimePoliciesInput, WorkspaceUncheckedCreateWithoutOvertimePoliciesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutOvertimePoliciesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type OvertimeCreateNestedManyWithoutOvertimePolicyInput = {
    create?: XOR<OvertimeCreateWithoutOvertimePolicyInput, OvertimeUncheckedCreateWithoutOvertimePolicyInput> | OvertimeCreateWithoutOvertimePolicyInput[] | OvertimeUncheckedCreateWithoutOvertimePolicyInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutOvertimePolicyInput | OvertimeCreateOrConnectWithoutOvertimePolicyInput[]
    createMany?: OvertimeCreateManyOvertimePolicyInputEnvelope
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
  }

  export type OvertimeUncheckedCreateNestedManyWithoutOvertimePolicyInput = {
    create?: XOR<OvertimeCreateWithoutOvertimePolicyInput, OvertimeUncheckedCreateWithoutOvertimePolicyInput> | OvertimeCreateWithoutOvertimePolicyInput[] | OvertimeUncheckedCreateWithoutOvertimePolicyInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutOvertimePolicyInput | OvertimeCreateOrConnectWithoutOvertimePolicyInput[]
    createMany?: OvertimeCreateManyOvertimePolicyInputEnvelope
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkspaceUpdateOneRequiredWithoutOvertimePoliciesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutOvertimePoliciesInput, WorkspaceUncheckedCreateWithoutOvertimePoliciesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutOvertimePoliciesInput
    upsert?: WorkspaceUpsertWithoutOvertimePoliciesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutOvertimePoliciesInput, WorkspaceUpdateWithoutOvertimePoliciesInput>, WorkspaceUncheckedUpdateWithoutOvertimePoliciesInput>
  }

  export type OvertimeUpdateManyWithoutOvertimePolicyNestedInput = {
    create?: XOR<OvertimeCreateWithoutOvertimePolicyInput, OvertimeUncheckedCreateWithoutOvertimePolicyInput> | OvertimeCreateWithoutOvertimePolicyInput[] | OvertimeUncheckedCreateWithoutOvertimePolicyInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutOvertimePolicyInput | OvertimeCreateOrConnectWithoutOvertimePolicyInput[]
    upsert?: OvertimeUpsertWithWhereUniqueWithoutOvertimePolicyInput | OvertimeUpsertWithWhereUniqueWithoutOvertimePolicyInput[]
    createMany?: OvertimeCreateManyOvertimePolicyInputEnvelope
    set?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    disconnect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    delete?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    update?: OvertimeUpdateWithWhereUniqueWithoutOvertimePolicyInput | OvertimeUpdateWithWhereUniqueWithoutOvertimePolicyInput[]
    updateMany?: OvertimeUpdateManyWithWhereWithoutOvertimePolicyInput | OvertimeUpdateManyWithWhereWithoutOvertimePolicyInput[]
    deleteMany?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
  }

  export type OvertimeUncheckedUpdateManyWithoutOvertimePolicyNestedInput = {
    create?: XOR<OvertimeCreateWithoutOvertimePolicyInput, OvertimeUncheckedCreateWithoutOvertimePolicyInput> | OvertimeCreateWithoutOvertimePolicyInput[] | OvertimeUncheckedCreateWithoutOvertimePolicyInput[]
    connectOrCreate?: OvertimeCreateOrConnectWithoutOvertimePolicyInput | OvertimeCreateOrConnectWithoutOvertimePolicyInput[]
    upsert?: OvertimeUpsertWithWhereUniqueWithoutOvertimePolicyInput | OvertimeUpsertWithWhereUniqueWithoutOvertimePolicyInput[]
    createMany?: OvertimeCreateManyOvertimePolicyInputEnvelope
    set?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    disconnect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    delete?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    connect?: OvertimeWhereUniqueInput | OvertimeWhereUniqueInput[]
    update?: OvertimeUpdateWithWhereUniqueWithoutOvertimePolicyInput | OvertimeUpdateWithWhereUniqueWithoutOvertimePolicyInput[]
    updateMany?: OvertimeUpdateManyWithWhereWithoutOvertimePolicyInput | OvertimeUpdateManyWithWhereWithoutOvertimePolicyInput[]
    deleteMany?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutOvertimesInput = {
    create?: XOR<WorkspaceCreateWithoutOvertimesInput, WorkspaceUncheckedCreateWithoutOvertimesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutOvertimesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutOvertimesInput = {
    create?: XOR<EmployeeCreateWithoutOvertimesInput, EmployeeUncheckedCreateWithoutOvertimesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutOvertimesInput
    connect?: EmployeeWhereUniqueInput
  }

  export type OvertimePolicyCreateNestedOneWithoutOvertimesInput = {
    create?: XOR<OvertimePolicyCreateWithoutOvertimesInput, OvertimePolicyUncheckedCreateWithoutOvertimesInput>
    connectOrCreate?: OvertimePolicyCreateOrConnectWithoutOvertimesInput
    connect?: OvertimePolicyWhereUniqueInput
  }

  export type ApprovalCreateNestedOneWithoutOvertimeInput = {
    create?: XOR<ApprovalCreateWithoutOvertimeInput, ApprovalUncheckedCreateWithoutOvertimeInput>
    connectOrCreate?: ApprovalCreateOrConnectWithoutOvertimeInput
    connect?: ApprovalWhereUniqueInput
  }

  export type ApprovalUncheckedCreateNestedOneWithoutOvertimeInput = {
    create?: XOR<ApprovalCreateWithoutOvertimeInput, ApprovalUncheckedCreateWithoutOvertimeInput>
    connectOrCreate?: ApprovalCreateOrConnectWithoutOvertimeInput
    connect?: ApprovalWhereUniqueInput
  }

  export type EnumOvertimeStatusFieldUpdateOperationsInput = {
    set?: $Enums.OvertimeStatus
  }

  export type WorkspaceUpdateOneRequiredWithoutOvertimesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutOvertimesInput, WorkspaceUncheckedCreateWithoutOvertimesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutOvertimesInput
    upsert?: WorkspaceUpsertWithoutOvertimesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutOvertimesInput, WorkspaceUpdateWithoutOvertimesInput>, WorkspaceUncheckedUpdateWithoutOvertimesInput>
  }

  export type EmployeeUpdateOneRequiredWithoutOvertimesNestedInput = {
    create?: XOR<EmployeeCreateWithoutOvertimesInput, EmployeeUncheckedCreateWithoutOvertimesInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutOvertimesInput
    upsert?: EmployeeUpsertWithoutOvertimesInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutOvertimesInput, EmployeeUpdateWithoutOvertimesInput>, EmployeeUncheckedUpdateWithoutOvertimesInput>
  }

  export type OvertimePolicyUpdateOneRequiredWithoutOvertimesNestedInput = {
    create?: XOR<OvertimePolicyCreateWithoutOvertimesInput, OvertimePolicyUncheckedCreateWithoutOvertimesInput>
    connectOrCreate?: OvertimePolicyCreateOrConnectWithoutOvertimesInput
    upsert?: OvertimePolicyUpsertWithoutOvertimesInput
    connect?: OvertimePolicyWhereUniqueInput
    update?: XOR<XOR<OvertimePolicyUpdateToOneWithWhereWithoutOvertimesInput, OvertimePolicyUpdateWithoutOvertimesInput>, OvertimePolicyUncheckedUpdateWithoutOvertimesInput>
  }

  export type ApprovalUpdateOneWithoutOvertimeNestedInput = {
    create?: XOR<ApprovalCreateWithoutOvertimeInput, ApprovalUncheckedCreateWithoutOvertimeInput>
    connectOrCreate?: ApprovalCreateOrConnectWithoutOvertimeInput
    upsert?: ApprovalUpsertWithoutOvertimeInput
    disconnect?: ApprovalWhereInput | boolean
    delete?: ApprovalWhereInput | boolean
    connect?: ApprovalWhereUniqueInput
    update?: XOR<XOR<ApprovalUpdateToOneWithWhereWithoutOvertimeInput, ApprovalUpdateWithoutOvertimeInput>, ApprovalUncheckedUpdateWithoutOvertimeInput>
  }

  export type ApprovalUncheckedUpdateOneWithoutOvertimeNestedInput = {
    create?: XOR<ApprovalCreateWithoutOvertimeInput, ApprovalUncheckedCreateWithoutOvertimeInput>
    connectOrCreate?: ApprovalCreateOrConnectWithoutOvertimeInput
    upsert?: ApprovalUpsertWithoutOvertimeInput
    disconnect?: ApprovalWhereInput | boolean
    delete?: ApprovalWhereInput | boolean
    connect?: ApprovalWhereUniqueInput
    update?: XOR<XOR<ApprovalUpdateToOneWithWhereWithoutOvertimeInput, ApprovalUpdateWithoutOvertimeInput>, ApprovalUncheckedUpdateWithoutOvertimeInput>
  }

  export type WorkspaceCreateNestedOneWithoutApprovalTemplatesInput = {
    create?: XOR<WorkspaceCreateWithoutApprovalTemplatesInput, WorkspaceUncheckedCreateWithoutApprovalTemplatesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutApprovalTemplatesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type ApprovalStepCreateNestedManyWithoutApprovalTemplateInput = {
    create?: XOR<ApprovalStepCreateWithoutApprovalTemplateInput, ApprovalStepUncheckedCreateWithoutApprovalTemplateInput> | ApprovalStepCreateWithoutApprovalTemplateInput[] | ApprovalStepUncheckedCreateWithoutApprovalTemplateInput[]
    connectOrCreate?: ApprovalStepCreateOrConnectWithoutApprovalTemplateInput | ApprovalStepCreateOrConnectWithoutApprovalTemplateInput[]
    createMany?: ApprovalStepCreateManyApprovalTemplateInputEnvelope
    connect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
  }

  export type ApprovalCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ApprovalCreateWithoutTemplateInput, ApprovalUncheckedCreateWithoutTemplateInput> | ApprovalCreateWithoutTemplateInput[] | ApprovalUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutTemplateInput | ApprovalCreateOrConnectWithoutTemplateInput[]
    createMany?: ApprovalCreateManyTemplateInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type ApprovalStepUncheckedCreateNestedManyWithoutApprovalTemplateInput = {
    create?: XOR<ApprovalStepCreateWithoutApprovalTemplateInput, ApprovalStepUncheckedCreateWithoutApprovalTemplateInput> | ApprovalStepCreateWithoutApprovalTemplateInput[] | ApprovalStepUncheckedCreateWithoutApprovalTemplateInput[]
    connectOrCreate?: ApprovalStepCreateOrConnectWithoutApprovalTemplateInput | ApprovalStepCreateOrConnectWithoutApprovalTemplateInput[]
    createMany?: ApprovalStepCreateManyApprovalTemplateInputEnvelope
    connect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
  }

  export type ApprovalUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<ApprovalCreateWithoutTemplateInput, ApprovalUncheckedCreateWithoutTemplateInput> | ApprovalCreateWithoutTemplateInput[] | ApprovalUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutTemplateInput | ApprovalCreateOrConnectWithoutTemplateInput[]
    createMany?: ApprovalCreateManyTemplateInputEnvelope
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutApprovalTemplatesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutApprovalTemplatesInput, WorkspaceUncheckedCreateWithoutApprovalTemplatesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutApprovalTemplatesInput
    upsert?: WorkspaceUpsertWithoutApprovalTemplatesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutApprovalTemplatesInput, WorkspaceUpdateWithoutApprovalTemplatesInput>, WorkspaceUncheckedUpdateWithoutApprovalTemplatesInput>
  }

  export type ApprovalStepUpdateManyWithoutApprovalTemplateNestedInput = {
    create?: XOR<ApprovalStepCreateWithoutApprovalTemplateInput, ApprovalStepUncheckedCreateWithoutApprovalTemplateInput> | ApprovalStepCreateWithoutApprovalTemplateInput[] | ApprovalStepUncheckedCreateWithoutApprovalTemplateInput[]
    connectOrCreate?: ApprovalStepCreateOrConnectWithoutApprovalTemplateInput | ApprovalStepCreateOrConnectWithoutApprovalTemplateInput[]
    upsert?: ApprovalStepUpsertWithWhereUniqueWithoutApprovalTemplateInput | ApprovalStepUpsertWithWhereUniqueWithoutApprovalTemplateInput[]
    createMany?: ApprovalStepCreateManyApprovalTemplateInputEnvelope
    set?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    disconnect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    delete?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    connect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    update?: ApprovalStepUpdateWithWhereUniqueWithoutApprovalTemplateInput | ApprovalStepUpdateWithWhereUniqueWithoutApprovalTemplateInput[]
    updateMany?: ApprovalStepUpdateManyWithWhereWithoutApprovalTemplateInput | ApprovalStepUpdateManyWithWhereWithoutApprovalTemplateInput[]
    deleteMany?: ApprovalStepScalarWhereInput | ApprovalStepScalarWhereInput[]
  }

  export type ApprovalUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ApprovalCreateWithoutTemplateInput, ApprovalUncheckedCreateWithoutTemplateInput> | ApprovalCreateWithoutTemplateInput[] | ApprovalUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutTemplateInput | ApprovalCreateOrConnectWithoutTemplateInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutTemplateInput | ApprovalUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ApprovalCreateManyTemplateInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutTemplateInput | ApprovalUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutTemplateInput | ApprovalUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type ApprovalStepUncheckedUpdateManyWithoutApprovalTemplateNestedInput = {
    create?: XOR<ApprovalStepCreateWithoutApprovalTemplateInput, ApprovalStepUncheckedCreateWithoutApprovalTemplateInput> | ApprovalStepCreateWithoutApprovalTemplateInput[] | ApprovalStepUncheckedCreateWithoutApprovalTemplateInput[]
    connectOrCreate?: ApprovalStepCreateOrConnectWithoutApprovalTemplateInput | ApprovalStepCreateOrConnectWithoutApprovalTemplateInput[]
    upsert?: ApprovalStepUpsertWithWhereUniqueWithoutApprovalTemplateInput | ApprovalStepUpsertWithWhereUniqueWithoutApprovalTemplateInput[]
    createMany?: ApprovalStepCreateManyApprovalTemplateInputEnvelope
    set?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    disconnect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    delete?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    connect?: ApprovalStepWhereUniqueInput | ApprovalStepWhereUniqueInput[]
    update?: ApprovalStepUpdateWithWhereUniqueWithoutApprovalTemplateInput | ApprovalStepUpdateWithWhereUniqueWithoutApprovalTemplateInput[]
    updateMany?: ApprovalStepUpdateManyWithWhereWithoutApprovalTemplateInput | ApprovalStepUpdateManyWithWhereWithoutApprovalTemplateInput[]
    deleteMany?: ApprovalStepScalarWhereInput | ApprovalStepScalarWhereInput[]
  }

  export type ApprovalUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<ApprovalCreateWithoutTemplateInput, ApprovalUncheckedCreateWithoutTemplateInput> | ApprovalCreateWithoutTemplateInput[] | ApprovalUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: ApprovalCreateOrConnectWithoutTemplateInput | ApprovalCreateOrConnectWithoutTemplateInput[]
    upsert?: ApprovalUpsertWithWhereUniqueWithoutTemplateInput | ApprovalUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: ApprovalCreateManyTemplateInputEnvelope
    set?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    disconnect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    delete?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    connect?: ApprovalWhereUniqueInput | ApprovalWhereUniqueInput[]
    update?: ApprovalUpdateWithWhereUniqueWithoutTemplateInput | ApprovalUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: ApprovalUpdateManyWithWhereWithoutTemplateInput | ApprovalUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
  }

  export type ApprovalTemplateCreateNestedOneWithoutStepsInput = {
    create?: XOR<ApprovalTemplateCreateWithoutStepsInput, ApprovalTemplateUncheckedCreateWithoutStepsInput>
    connectOrCreate?: ApprovalTemplateCreateOrConnectWithoutStepsInput
    connect?: ApprovalTemplateWhereUniqueInput
  }

  export type EnumApproverTypeFieldUpdateOperationsInput = {
    set?: $Enums.ApproverType
  }

  export type ApprovalTemplateUpdateOneRequiredWithoutStepsNestedInput = {
    create?: XOR<ApprovalTemplateCreateWithoutStepsInput, ApprovalTemplateUncheckedCreateWithoutStepsInput>
    connectOrCreate?: ApprovalTemplateCreateOrConnectWithoutStepsInput
    upsert?: ApprovalTemplateUpsertWithoutStepsInput
    connect?: ApprovalTemplateWhereUniqueInput
    update?: XOR<XOR<ApprovalTemplateUpdateToOneWithWhereWithoutStepsInput, ApprovalTemplateUpdateWithoutStepsInput>, ApprovalTemplateUncheckedUpdateWithoutStepsInput>
  }

  export type WorkspaceCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<WorkspaceCreateWithoutApprovalsInput, WorkspaceUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutApprovalsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type ApprovalTemplateCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<ApprovalTemplateCreateWithoutApprovalsInput, ApprovalTemplateUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: ApprovalTemplateCreateOrConnectWithoutApprovalsInput
    connect?: ApprovalTemplateWhereUniqueInput
  }

  export type LeaveCreateNestedOneWithoutApprovalInput = {
    create?: XOR<LeaveCreateWithoutApprovalInput, LeaveUncheckedCreateWithoutApprovalInput>
    connectOrCreate?: LeaveCreateOrConnectWithoutApprovalInput
    connect?: LeaveWhereUniqueInput
  }

  export type OvertimeCreateNestedOneWithoutApprovalInput = {
    create?: XOR<OvertimeCreateWithoutApprovalInput, OvertimeUncheckedCreateWithoutApprovalInput>
    connectOrCreate?: OvertimeCreateOrConnectWithoutApprovalInput
    connect?: OvertimeWhereUniqueInput
  }

  export type ApprovalActionCreateNestedManyWithoutApprovalInput = {
    create?: XOR<ApprovalActionCreateWithoutApprovalInput, ApprovalActionUncheckedCreateWithoutApprovalInput> | ApprovalActionCreateWithoutApprovalInput[] | ApprovalActionUncheckedCreateWithoutApprovalInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutApprovalInput | ApprovalActionCreateOrConnectWithoutApprovalInput[]
    createMany?: ApprovalActionCreateManyApprovalInputEnvelope
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
  }

  export type ApprovalActionUncheckedCreateNestedManyWithoutApprovalInput = {
    create?: XOR<ApprovalActionCreateWithoutApprovalInput, ApprovalActionUncheckedCreateWithoutApprovalInput> | ApprovalActionCreateWithoutApprovalInput[] | ApprovalActionUncheckedCreateWithoutApprovalInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutApprovalInput | ApprovalActionCreateOrConnectWithoutApprovalInput[]
    createMany?: ApprovalActionCreateManyApprovalInputEnvelope
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
  }

  export type EnumApprovalStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApprovalStatus
  }

  export type WorkspaceUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutApprovalsInput, WorkspaceUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutApprovalsInput
    upsert?: WorkspaceUpsertWithoutApprovalsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutApprovalsInput, WorkspaceUpdateWithoutApprovalsInput>, WorkspaceUncheckedUpdateWithoutApprovalsInput>
  }

  export type ApprovalTemplateUpdateOneRequiredWithoutApprovalsNestedInput = {
    create?: XOR<ApprovalTemplateCreateWithoutApprovalsInput, ApprovalTemplateUncheckedCreateWithoutApprovalsInput>
    connectOrCreate?: ApprovalTemplateCreateOrConnectWithoutApprovalsInput
    upsert?: ApprovalTemplateUpsertWithoutApprovalsInput
    connect?: ApprovalTemplateWhereUniqueInput
    update?: XOR<XOR<ApprovalTemplateUpdateToOneWithWhereWithoutApprovalsInput, ApprovalTemplateUpdateWithoutApprovalsInput>, ApprovalTemplateUncheckedUpdateWithoutApprovalsInput>
  }

  export type LeaveUpdateOneWithoutApprovalNestedInput = {
    create?: XOR<LeaveCreateWithoutApprovalInput, LeaveUncheckedCreateWithoutApprovalInput>
    connectOrCreate?: LeaveCreateOrConnectWithoutApprovalInput
    upsert?: LeaveUpsertWithoutApprovalInput
    disconnect?: LeaveWhereInput | boolean
    delete?: LeaveWhereInput | boolean
    connect?: LeaveWhereUniqueInput
    update?: XOR<XOR<LeaveUpdateToOneWithWhereWithoutApprovalInput, LeaveUpdateWithoutApprovalInput>, LeaveUncheckedUpdateWithoutApprovalInput>
  }

  export type OvertimeUpdateOneWithoutApprovalNestedInput = {
    create?: XOR<OvertimeCreateWithoutApprovalInput, OvertimeUncheckedCreateWithoutApprovalInput>
    connectOrCreate?: OvertimeCreateOrConnectWithoutApprovalInput
    upsert?: OvertimeUpsertWithoutApprovalInput
    disconnect?: OvertimeWhereInput | boolean
    delete?: OvertimeWhereInput | boolean
    connect?: OvertimeWhereUniqueInput
    update?: XOR<XOR<OvertimeUpdateToOneWithWhereWithoutApprovalInput, OvertimeUpdateWithoutApprovalInput>, OvertimeUncheckedUpdateWithoutApprovalInput>
  }

  export type ApprovalActionUpdateManyWithoutApprovalNestedInput = {
    create?: XOR<ApprovalActionCreateWithoutApprovalInput, ApprovalActionUncheckedCreateWithoutApprovalInput> | ApprovalActionCreateWithoutApprovalInput[] | ApprovalActionUncheckedCreateWithoutApprovalInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutApprovalInput | ApprovalActionCreateOrConnectWithoutApprovalInput[]
    upsert?: ApprovalActionUpsertWithWhereUniqueWithoutApprovalInput | ApprovalActionUpsertWithWhereUniqueWithoutApprovalInput[]
    createMany?: ApprovalActionCreateManyApprovalInputEnvelope
    set?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    disconnect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    delete?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    update?: ApprovalActionUpdateWithWhereUniqueWithoutApprovalInput | ApprovalActionUpdateWithWhereUniqueWithoutApprovalInput[]
    updateMany?: ApprovalActionUpdateManyWithWhereWithoutApprovalInput | ApprovalActionUpdateManyWithWhereWithoutApprovalInput[]
    deleteMany?: ApprovalActionScalarWhereInput | ApprovalActionScalarWhereInput[]
  }

  export type ApprovalActionUncheckedUpdateManyWithoutApprovalNestedInput = {
    create?: XOR<ApprovalActionCreateWithoutApprovalInput, ApprovalActionUncheckedCreateWithoutApprovalInput> | ApprovalActionCreateWithoutApprovalInput[] | ApprovalActionUncheckedCreateWithoutApprovalInput[]
    connectOrCreate?: ApprovalActionCreateOrConnectWithoutApprovalInput | ApprovalActionCreateOrConnectWithoutApprovalInput[]
    upsert?: ApprovalActionUpsertWithWhereUniqueWithoutApprovalInput | ApprovalActionUpsertWithWhereUniqueWithoutApprovalInput[]
    createMany?: ApprovalActionCreateManyApprovalInputEnvelope
    set?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    disconnect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    delete?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    connect?: ApprovalActionWhereUniqueInput | ApprovalActionWhereUniqueInput[]
    update?: ApprovalActionUpdateWithWhereUniqueWithoutApprovalInput | ApprovalActionUpdateWithWhereUniqueWithoutApprovalInput[]
    updateMany?: ApprovalActionUpdateManyWithWhereWithoutApprovalInput | ApprovalActionUpdateManyWithWhereWithoutApprovalInput[]
    deleteMany?: ApprovalActionScalarWhereInput | ApprovalActionScalarWhereInput[]
  }

  export type ApprovalCreateNestedOneWithoutActionsInput = {
    create?: XOR<ApprovalCreateWithoutActionsInput, ApprovalUncheckedCreateWithoutActionsInput>
    connectOrCreate?: ApprovalCreateOrConnectWithoutActionsInput
    connect?: ApprovalWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApprovalActionsInput = {
    create?: XOR<UserCreateWithoutApprovalActionsInput, UserUncheckedCreateWithoutApprovalActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalActionsInput
    connect?: UserWhereUniqueInput
  }

  export type ApprovalUpdateOneRequiredWithoutActionsNestedInput = {
    create?: XOR<ApprovalCreateWithoutActionsInput, ApprovalUncheckedCreateWithoutActionsInput>
    connectOrCreate?: ApprovalCreateOrConnectWithoutActionsInput
    upsert?: ApprovalUpsertWithoutActionsInput
    connect?: ApprovalWhereUniqueInput
    update?: XOR<XOR<ApprovalUpdateToOneWithWhereWithoutActionsInput, ApprovalUpdateWithoutActionsInput>, ApprovalUncheckedUpdateWithoutActionsInput>
  }

  export type UserUpdateOneRequiredWithoutApprovalActionsNestedInput = {
    create?: XOR<UserCreateWithoutApprovalActionsInput, UserUncheckedCreateWithoutApprovalActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutApprovalActionsInput
    upsert?: UserUpsertWithoutApprovalActionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApprovalActionsInput, UserUpdateWithoutApprovalActionsInput>, UserUncheckedUpdateWithoutApprovalActionsInput>
  }

  export type WorkspaceCreateNestedOneWithoutSettingsInput = {
    create?: XOR<WorkspaceCreateWithoutSettingsInput, WorkspaceUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSettingsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutSettingsInput, WorkspaceUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSettingsInput
    upsert?: WorkspaceUpsertWithoutSettingsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutSettingsInput, WorkspaceUpdateWithoutSettingsInput>, WorkspaceUncheckedUpdateWithoutSettingsInput>
  }

  export type UserCreateNestedOneWithoutConsentsInput = {
    create?: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutConsentsNestedInput = {
    create?: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConsentsInput
    upsert?: UserUpsertWithoutConsentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConsentsInput, UserUpdateWithoutConsentsInput>, UserUncheckedUpdateWithoutConsentsInput>
  }

  export type UserCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    upsert?: UserUpsertWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsInput, UserUpdateWithoutActivityLogsInput>, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type WorkspaceCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<WorkspaceCreateWithoutAuditLogsInput, WorkspaceUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAuditLogsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutAuditLogsInput, WorkspaceUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAuditLogsInput
    upsert?: WorkspaceUpsertWithoutAuditLogsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutAuditLogsInput, WorkspaceUpdateWithoutAuditLogsInput>, WorkspaceUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type WorkspaceCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInvitationsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type EnumInvitationTypeFieldUpdateOperationsInput = {
    set?: $Enums.InvitationType
  }

  export type EnumInvitationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvitationStatus
  }

  export type WorkspaceUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInvitationsInput
    upsert?: WorkspaceUpsertWithoutInvitationsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutInvitationsInput, WorkspaceUpdateWithoutInvitationsInput>, WorkspaceUncheckedUpdateWithoutInvitationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedEnumWorkspaceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceStatus | EnumWorkspaceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceStatus[] | ListEnumWorkspaceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceStatus[] | ListEnumWorkspaceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceStatusFilter<$PrismaModel> | $Enums.WorkspaceStatus
  }

  export type NestedEnumPlanTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeFilter<$PrismaModel> | $Enums.PlanType
  }

  export type NestedEnumWorkspaceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WorkspaceStatus | EnumWorkspaceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WorkspaceStatus[] | ListEnumWorkspaceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WorkspaceStatus[] | ListEnumWorkspaceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWorkspaceStatusWithAggregatesFilter<$PrismaModel> | $Enums.WorkspaceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWorkspaceStatusFilter<$PrismaModel>
    _max?: NestedEnumWorkspaceStatusFilter<$PrismaModel>
  }

  export type NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlanType | EnumPlanTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlanType[] | ListEnumPlanTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlanTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlanType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlanTypeFilter<$PrismaModel>
    _max?: NestedEnumPlanTypeFilter<$PrismaModel>
  }

  export type NestedEnumMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleFilter<$PrismaModel> | $Enums.MemberRole
  }

  export type NestedEnumMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusFilter<$PrismaModel> | $Enums.MemberStatus
  }

  export type NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.MemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumMemberRoleFilter<$PrismaModel>
  }

  export type NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.MemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumMemberStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumEmployeeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeStatus | EnumEmployeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeStatus[] | ListEnumEmployeeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeStatus[] | ListEnumEmployeeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeStatusFilter<$PrismaModel> | $Enums.EmployeeStatus
  }

  export type NestedEnumEmploymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeFilter<$PrismaModel> | $Enums.EmploymentType
  }

  export type NestedEnumEmployeeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmployeeStatus | EnumEmployeeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmployeeStatus[] | ListEnumEmployeeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmployeeStatus[] | ListEnumEmployeeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmployeeStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmployeeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmployeeStatusFilter<$PrismaModel>
    _max?: NestedEnumEmployeeStatusFilter<$PrismaModel>
  }

  export type NestedEnumEmploymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmploymentType | EnumEmploymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmploymentType[] | ListEnumEmploymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEmploymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.EmploymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmploymentTypeFilter<$PrismaModel>
    _max?: NestedEnumEmploymentTypeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedEnumProjectPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectPriority | EnumProjectPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectPriority[] | ListEnumProjectPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectPriority[] | ListEnumProjectPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectPriorityFilter<$PrismaModel> | $Enums.ProjectPriority
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedEnumProjectPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectPriority | EnumProjectPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectPriority[] | ListEnumProjectPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectPriority[] | ListEnumProjectPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectPriorityWithAggregatesFilter<$PrismaModel> | $Enums.ProjectPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectPriorityFilter<$PrismaModel>
    _max?: NestedEnumProjectPriorityFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumLeaveStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusFilter<$PrismaModel> | $Enums.LeaveStatus
  }

  export type NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeaveStatus | EnumLeaveStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeaveStatus[] | ListEnumLeaveStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeaveStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeaveStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeaveStatusFilter<$PrismaModel>
    _max?: NestedEnumLeaveStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumOvertimeStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OvertimeStatus | EnumOvertimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OvertimeStatus[] | ListEnumOvertimeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OvertimeStatus[] | ListEnumOvertimeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOvertimeStatusFilter<$PrismaModel> | $Enums.OvertimeStatus
  }

  export type NestedEnumOvertimeStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OvertimeStatus | EnumOvertimeStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OvertimeStatus[] | ListEnumOvertimeStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OvertimeStatus[] | ListEnumOvertimeStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOvertimeStatusWithAggregatesFilter<$PrismaModel> | $Enums.OvertimeStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOvertimeStatusFilter<$PrismaModel>
    _max?: NestedEnumOvertimeStatusFilter<$PrismaModel>
  }

  export type NestedEnumApproverTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApproverType | EnumApproverTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApproverType[] | ListEnumApproverTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApproverType[] | ListEnumApproverTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApproverTypeFilter<$PrismaModel> | $Enums.ApproverType
  }

  export type NestedEnumApproverTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApproverType | EnumApproverTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApproverType[] | ListEnumApproverTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApproverType[] | ListEnumApproverTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumApproverTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApproverType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApproverTypeFilter<$PrismaModel>
    _max?: NestedEnumApproverTypeFilter<$PrismaModel>
  }

  export type NestedEnumApprovalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusFilter<$PrismaModel> | $Enums.ApprovalStatus
  }

  export type NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApprovalStatus | EnumApprovalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApprovalStatus[] | ListEnumApprovalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApprovalStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApprovalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApprovalStatusFilter<$PrismaModel>
    _max?: NestedEnumApprovalStatusFilter<$PrismaModel>
  }

  export type NestedEnumInvitationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationType | EnumInvitationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationType[] | ListEnumInvitationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationType[] | ListEnumInvitationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationTypeFilter<$PrismaModel> | $Enums.InvitationType
  }

  export type NestedEnumInvitationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusFilter<$PrismaModel> | $Enums.InvitationStatus
  }

  export type NestedEnumInvitationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationType | EnumInvitationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationType[] | ListEnumInvitationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationType[] | ListEnumInvitationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationTypeWithAggregatesFilter<$PrismaModel> | $Enums.InvitationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationTypeFilter<$PrismaModel>
    _max?: NestedEnumInvitationTypeFilter<$PrismaModel>
  }

  export type NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvitationStatus | EnumInvitationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvitationStatus[] | ListEnumInvitationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvitationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvitationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvitationStatusFilter<$PrismaModel>
    _max?: NestedEnumInvitationStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    workspaceMember?: WorkspaceMemberCreateNestedManyWithoutUserInput
    approvalActions?: ApprovalActionCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    workspaceMember?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    approvalActions?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    workspaceMember?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    approvalActions?: ApprovalActionUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    workspaceMember?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    approvalActions?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    workspaceMember?: WorkspaceMemberCreateNestedManyWithoutUserInput
    approvalActions?: ApprovalActionCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    workspaceMember?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    approvalActions?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    workspaceMember?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    approvalActions?: ApprovalActionUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    workspaceMember?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    approvalActions?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutUserInput = {
    id?: string
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    positionLevel?: PositionLevelCreateNestedOneWithoutEmployeesInput
    manager?: EmployeeCreateNestedOneWithoutSubordinatesInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    details?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogCreateManyUserInputEnvelope = {
    data: ActivityLogCreateManyUserInput | ActivityLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceMemberCreateWithoutUserInput = {
    id?: string
    role: $Enums.MemberRole
    joinedAt?: Date | string
    invitedBy?: string | null
    status?: $Enums.MemberStatus
    workspace: WorkspaceCreateNestedOneWithoutMembersInput
  }

  export type WorkspaceMemberUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    role: $Enums.MemberRole
    joinedAt?: Date | string
    invitedBy?: string | null
    status?: $Enums.MemberStatus
  }

  export type WorkspaceMemberCreateOrConnectWithoutUserInput = {
    where: WorkspaceMemberWhereUniqueInput
    create: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceMemberCreateManyUserInputEnvelope = {
    data: WorkspaceMemberCreateManyUserInput | WorkspaceMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalActionCreateWithoutUserInput = {
    id?: string
    step: number
    action: string
    comment?: string | null
    createdAt?: Date | string
    approval: ApprovalCreateNestedOneWithoutActionsInput
  }

  export type ApprovalActionUncheckedCreateWithoutUserInput = {
    id?: string
    approvalId: string
    step: number
    action: string
    comment?: string | null
    createdAt?: Date | string
  }

  export type ApprovalActionCreateOrConnectWithoutUserInput = {
    where: ApprovalActionWhereUniqueInput
    create: XOR<ApprovalActionCreateWithoutUserInput, ApprovalActionUncheckedCreateWithoutUserInput>
  }

  export type ApprovalActionCreateManyUserInputEnvelope = {
    data: ApprovalActionCreateManyUserInput | ApprovalActionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserConsentCreateWithoutUserInput = {
    id?: string
    purpose: string
    consentGiven: boolean
    timestamp: Date | string
    ipAddress?: string | null
  }

  export type UserConsentUncheckedCreateWithoutUserInput = {
    id?: string
    purpose: string
    consentGiven: boolean
    timestamp: Date | string
    ipAddress?: string | null
  }

  export type UserConsentCreateOrConnectWithoutUserInput = {
    where: UserConsentWhereUniqueInput
    create: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
  }

  export type UserConsentCreateManyUserInputEnvelope = {
    data: UserConsentCreateManyUserInput | UserConsentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    action: string
    resource: string
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type EmployeeUpsertWithoutUserInput = {
    update: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutUserInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    positionLevel?: PositionLevelUpdateOneWithoutEmployeesNestedInput
    manager?: EmployeeUpdateOneWithoutSubordinatesNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    userId?: StringFilter<"ActivityLog"> | string
    action?: StringFilter<"ActivityLog"> | string
    entity?: StringFilter<"ActivityLog"> | string
    entityId?: StringFilter<"ActivityLog"> | string
    details?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type WorkspaceMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkspaceMemberWhereUniqueInput
    update: XOR<WorkspaceMemberUpdateWithoutUserInput, WorkspaceMemberUncheckedUpdateWithoutUserInput>
    create: XOR<WorkspaceMemberCreateWithoutUserInput, WorkspaceMemberUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkspaceMemberWhereUniqueInput
    data: XOR<WorkspaceMemberUpdateWithoutUserInput, WorkspaceMemberUncheckedUpdateWithoutUserInput>
  }

  export type WorkspaceMemberUpdateManyWithWhereWithoutUserInput = {
    where: WorkspaceMemberScalarWhereInput
    data: XOR<WorkspaceMemberUpdateManyMutationInput, WorkspaceMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkspaceMemberScalarWhereInput = {
    AND?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
    OR?: WorkspaceMemberScalarWhereInput[]
    NOT?: WorkspaceMemberScalarWhereInput | WorkspaceMemberScalarWhereInput[]
    id?: StringFilter<"WorkspaceMember"> | string
    workspaceId?: StringFilter<"WorkspaceMember"> | string
    userId?: StringFilter<"WorkspaceMember"> | string
    role?: EnumMemberRoleFilter<"WorkspaceMember"> | $Enums.MemberRole
    joinedAt?: DateTimeFilter<"WorkspaceMember"> | Date | string
    invitedBy?: StringNullableFilter<"WorkspaceMember"> | string | null
    status?: EnumMemberStatusFilter<"WorkspaceMember"> | $Enums.MemberStatus
  }

  export type ApprovalActionUpsertWithWhereUniqueWithoutUserInput = {
    where: ApprovalActionWhereUniqueInput
    update: XOR<ApprovalActionUpdateWithoutUserInput, ApprovalActionUncheckedUpdateWithoutUserInput>
    create: XOR<ApprovalActionCreateWithoutUserInput, ApprovalActionUncheckedCreateWithoutUserInput>
  }

  export type ApprovalActionUpdateWithWhereUniqueWithoutUserInput = {
    where: ApprovalActionWhereUniqueInput
    data: XOR<ApprovalActionUpdateWithoutUserInput, ApprovalActionUncheckedUpdateWithoutUserInput>
  }

  export type ApprovalActionUpdateManyWithWhereWithoutUserInput = {
    where: ApprovalActionScalarWhereInput
    data: XOR<ApprovalActionUpdateManyMutationInput, ApprovalActionUncheckedUpdateManyWithoutUserInput>
  }

  export type ApprovalActionScalarWhereInput = {
    AND?: ApprovalActionScalarWhereInput | ApprovalActionScalarWhereInput[]
    OR?: ApprovalActionScalarWhereInput[]
    NOT?: ApprovalActionScalarWhereInput | ApprovalActionScalarWhereInput[]
    id?: StringFilter<"ApprovalAction"> | string
    approvalId?: StringFilter<"ApprovalAction"> | string
    userId?: StringFilter<"ApprovalAction"> | string
    step?: IntFilter<"ApprovalAction"> | number
    action?: StringFilter<"ApprovalAction"> | string
    comment?: StringNullableFilter<"ApprovalAction"> | string | null
    createdAt?: DateTimeFilter<"ApprovalAction"> | Date | string
  }

  export type UserConsentUpsertWithWhereUniqueWithoutUserInput = {
    where: UserConsentWhereUniqueInput
    update: XOR<UserConsentUpdateWithoutUserInput, UserConsentUncheckedUpdateWithoutUserInput>
    create: XOR<UserConsentCreateWithoutUserInput, UserConsentUncheckedCreateWithoutUserInput>
  }

  export type UserConsentUpdateWithWhereUniqueWithoutUserInput = {
    where: UserConsentWhereUniqueInput
    data: XOR<UserConsentUpdateWithoutUserInput, UserConsentUncheckedUpdateWithoutUserInput>
  }

  export type UserConsentUpdateManyWithWhereWithoutUserInput = {
    where: UserConsentScalarWhereInput
    data: XOR<UserConsentUpdateManyMutationInput, UserConsentUncheckedUpdateManyWithoutUserInput>
  }

  export type UserConsentScalarWhereInput = {
    AND?: UserConsentScalarWhereInput | UserConsentScalarWhereInput[]
    OR?: UserConsentScalarWhereInput[]
    NOT?: UserConsentScalarWhereInput | UserConsentScalarWhereInput[]
    id?: StringFilter<"UserConsent"> | string
    userId?: StringFilter<"UserConsent"> | string
    purpose?: StringFilter<"UserConsent"> | string
    consentGiven?: BoolFilter<"UserConsent"> | boolean
    timestamp?: DateTimeFilter<"UserConsent"> | Date | string
    ipAddress?: StringNullableFilter<"UserConsent"> | string | null
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    workspaceId?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    resourceId?: StringNullableFilter<"AuditLog"> | string | null
    details?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type WorkspaceMemberCreateWithoutWorkspaceInput = {
    id?: string
    role: $Enums.MemberRole
    joinedAt?: Date | string
    invitedBy?: string | null
    status?: $Enums.MemberStatus
    user: UserCreateNestedOneWithoutWorkspaceMemberInput
  }

  export type WorkspaceMemberUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    role: $Enums.MemberRole
    joinedAt?: Date | string
    invitedBy?: string | null
    status?: $Enums.MemberStatus
  }

  export type WorkspaceMemberCreateOrConnectWithoutWorkspaceInput = {
    where: WorkspaceMemberWhereUniqueInput
    create: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceMemberCreateManyWorkspaceInputEnvelope = {
    data: WorkspaceMemberCreateManyWorkspaceInput | WorkspaceMemberCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    managerId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamCreateNestedManyWithoutDepartmentInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
    parent?: DepartmentCreateNestedOneWithoutChildrenInput
    children?: DepartmentCreateNestedManyWithoutParentInput
  }

  export type DepartmentUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    managerId?: string | null
    parentId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutDepartmentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    children?: DepartmentUncheckedCreateNestedManyWithoutParentInput
  }

  export type DepartmentCreateOrConnectWithoutWorkspaceInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutWorkspaceInput, DepartmentUncheckedCreateWithoutWorkspaceInput>
  }

  export type DepartmentCreateManyWorkspaceInputEnvelope = {
    data: DepartmentCreateManyWorkspaceInput | DepartmentCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    leaderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    department: DepartmentCreateNestedOneWithoutTeamsInput
    employees?: EmployeeCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    departmentId: string
    name: string
    description?: string | null
    leaderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutWorkspaceInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutWorkspaceInput, TeamUncheckedCreateWithoutWorkspaceInput>
  }

  export type TeamCreateManyWorkspaceInputEnvelope = {
    data: TeamCreateManyWorkspaceInput | TeamCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type PositionCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeCreateNestedManyWithoutPositionInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutPositionInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionCreateOrConnectWithoutWorkspaceInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutWorkspaceInput, PositionUncheckedCreateWithoutWorkspaceInput>
  }

  export type PositionCreateManyWorkspaceInputEnvelope = {
    data: PositionCreateManyWorkspaceInput | PositionCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type PositionLevelCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    level: number
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeCreateNestedManyWithoutPositionLevelInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutPositionLevelInput
  }

  export type PositionLevelUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    level: number
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutPositionLevelInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutPositionLevelInput
  }

  export type PositionLevelCreateOrConnectWithoutWorkspaceInput = {
    where: PositionLevelWhereUniqueInput
    create: XOR<PositionLevelCreateWithoutWorkspaceInput, PositionLevelUncheckedCreateWithoutWorkspaceInput>
  }

  export type PositionLevelCreateManyWorkspaceInputEnvelope = {
    data: PositionLevelCreateManyWorkspaceInput | PositionLevelCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutWorkspaceInput = {
    id?: string
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeeInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    positionLevel?: PositionLevelCreateNestedOneWithoutEmployeesInput
    manager?: EmployeeCreateNestedOneWithoutSubordinatesInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutWorkspaceInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutWorkspaceInput, EmployeeUncheckedCreateWithoutWorkspaceInput>
  }

  export type EmployeeCreateManyWorkspaceInputEnvelope = {
    data: EmployeeCreateManyWorkspaceInput | EmployeeCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type ProjectCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.ProjectStatus
    priority?: $Enums.ProjectPriority
    managerId?: string | null
    clientName?: string | null
    clientContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.ProjectStatus
    priority?: $Enums.ProjectPriority
    managerId?: string | null
    clientName?: string | null
    clientContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: ProjectMemberUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutWorkspaceInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutWorkspaceInput, ProjectUncheckedCreateWithoutWorkspaceInput>
  }

  export type ProjectCreateManyWorkspaceInputEnvelope = {
    data: ProjectCreateManyWorkspaceInput | ProjectCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type ProjectRoleCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMembers?: ProjectMemberCreateNestedManyWithoutProjectRoleInput
  }

  export type ProjectRoleUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutProjectRoleInput
  }

  export type ProjectRoleCreateOrConnectWithoutWorkspaceInput = {
    where: ProjectRoleWhereUniqueInput
    create: XOR<ProjectRoleCreateWithoutWorkspaceInput, ProjectRoleUncheckedCreateWithoutWorkspaceInput>
  }

  export type ProjectRoleCreateManyWorkspaceInputEnvelope = {
    data: ProjectRoleCreateManyWorkspaceInput | ProjectRoleCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type LeaveTypeCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    color?: string | null
    isPaid?: boolean
    requiresApproval?: boolean
    requiresAttachment?: boolean
    maxDaysPerYear?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutLeaveTypeInput
    leaves?: LeaveCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    color?: string | null
    isPaid?: boolean
    requiresApproval?: boolean
    requiresAttachment?: boolean
    maxDaysPerYear?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutLeaveTypeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeCreateOrConnectWithoutWorkspaceInput = {
    where: LeaveTypeWhereUniqueInput
    create: XOR<LeaveTypeCreateWithoutWorkspaceInput, LeaveTypeUncheckedCreateWithoutWorkspaceInput>
  }

  export type LeaveTypeCreateManyWorkspaceInputEnvelope = {
    data: LeaveTypeCreateManyWorkspaceInput | LeaveTypeCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type LeaveQuotaCreateWithoutWorkspaceInput = {
    id?: string
    year: number
    total: number
    used?: number
    pending?: number
    remaining: number
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutLeaveQuotasInput
    leaveType: LeaveTypeCreateNestedOneWithoutLeaveQuotasInput
  }

  export type LeaveQuotaUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    employeeId: string
    leaveTypeId: string
    year: number
    total: number
    used?: number
    pending?: number
    remaining: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveQuotaCreateOrConnectWithoutWorkspaceInput = {
    where: LeaveQuotaWhereUniqueInput
    create: XOR<LeaveQuotaCreateWithoutWorkspaceInput, LeaveQuotaUncheckedCreateWithoutWorkspaceInput>
  }

  export type LeaveQuotaCreateManyWorkspaceInputEnvelope = {
    data: LeaveQuotaCreateManyWorkspaceInput | LeaveQuotaCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type LeaveCreateWithoutWorkspaceInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    halfDay?: boolean
    duration: number
    reason?: string | null
    attachment?: string | null
    status?: $Enums.LeaveStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutLeavesInput
    leaveType: LeaveTypeCreateNestedOneWithoutLeavesInput
    approval?: ApprovalCreateNestedOneWithoutLeaveInput
  }

  export type LeaveUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    employeeId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    halfDay?: boolean
    duration: number
    reason?: string | null
    attachment?: string | null
    status?: $Enums.LeaveStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approval?: ApprovalUncheckedCreateNestedOneWithoutLeaveInput
  }

  export type LeaveCreateOrConnectWithoutWorkspaceInput = {
    where: LeaveWhereUniqueInput
    create: XOR<LeaveCreateWithoutWorkspaceInput, LeaveUncheckedCreateWithoutWorkspaceInput>
  }

  export type LeaveCreateManyWorkspaceInputEnvelope = {
    data: LeaveCreateManyWorkspaceInput | LeaveCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type OvertimePolicyCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    rate: number
    minimumHours?: number
    maximumHours?: number | null
    requiresApproval?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    overtimes?: OvertimeCreateNestedManyWithoutOvertimePolicyInput
  }

  export type OvertimePolicyUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    rate: number
    minimumHours?: number
    maximumHours?: number | null
    requiresApproval?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutOvertimePolicyInput
  }

  export type OvertimePolicyCreateOrConnectWithoutWorkspaceInput = {
    where: OvertimePolicyWhereUniqueInput
    create: XOR<OvertimePolicyCreateWithoutWorkspaceInput, OvertimePolicyUncheckedCreateWithoutWorkspaceInput>
  }

  export type OvertimePolicyCreateManyWorkspaceInputEnvelope = {
    data: OvertimePolicyCreateManyWorkspaceInput | OvertimePolicyCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type OvertimeCreateWithoutWorkspaceInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    hours: number
    reason: string
    status?: $Enums.OvertimeStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutOvertimesInput
    overtimePolicy: OvertimePolicyCreateNestedOneWithoutOvertimesInput
    approval?: ApprovalCreateNestedOneWithoutOvertimeInput
  }

  export type OvertimeUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    employeeId: string
    policyId: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    hours: number
    reason: string
    status?: $Enums.OvertimeStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approval?: ApprovalUncheckedCreateNestedOneWithoutOvertimeInput
  }

  export type OvertimeCreateOrConnectWithoutWorkspaceInput = {
    where: OvertimeWhereUniqueInput
    create: XOR<OvertimeCreateWithoutWorkspaceInput, OvertimeUncheckedCreateWithoutWorkspaceInput>
  }

  export type OvertimeCreateManyWorkspaceInputEnvelope = {
    data: OvertimeCreateManyWorkspaceInput | OvertimeCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalTemplateCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    entityType: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: ApprovalStepCreateNestedManyWithoutApprovalTemplateInput
    approvals?: ApprovalCreateNestedManyWithoutTemplateInput
  }

  export type ApprovalTemplateUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    entityType: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: ApprovalStepUncheckedCreateNestedManyWithoutApprovalTemplateInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type ApprovalTemplateCreateOrConnectWithoutWorkspaceInput = {
    where: ApprovalTemplateWhereUniqueInput
    create: XOR<ApprovalTemplateCreateWithoutWorkspaceInput, ApprovalTemplateUncheckedCreateWithoutWorkspaceInput>
  }

  export type ApprovalTemplateCreateManyWorkspaceInputEnvelope = {
    data: ApprovalTemplateCreateManyWorkspaceInput | ApprovalTemplateCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalCreateWithoutWorkspaceInput = {
    id?: string
    entityType: string
    entityId: string
    requesterId: string
    currentStep?: number
    status?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    template: ApprovalTemplateCreateNestedOneWithoutApprovalsInput
    leave?: LeaveCreateNestedOneWithoutApprovalInput
    overtime?: OvertimeCreateNestedOneWithoutApprovalInput
    actions?: ApprovalActionCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    templateId: string
    entityType: string
    entityId: string
    requesterId: string
    currentStep?: number
    status?: $Enums.ApprovalStatus
    leaveId?: string | null
    overtimeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: ApprovalActionUncheckedCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalCreateOrConnectWithoutWorkspaceInput = {
    where: ApprovalWhereUniqueInput
    create: XOR<ApprovalCreateWithoutWorkspaceInput, ApprovalUncheckedCreateWithoutWorkspaceInput>
  }

  export type ApprovalCreateManyWorkspaceInputEnvelope = {
    data: ApprovalCreateManyWorkspaceInput | ApprovalCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type SettingsCreateWithoutWorkspaceInput = {
    id?: string
    category: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingsUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    category: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingsCreateOrConnectWithoutWorkspaceInput = {
    where: SettingsWhereUniqueInput
    create: XOR<SettingsCreateWithoutWorkspaceInput, SettingsUncheckedCreateWithoutWorkspaceInput>
  }

  export type SettingsCreateManyWorkspaceInputEnvelope = {
    data: SettingsCreateManyWorkspaceInput | SettingsCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutWorkspaceInput = {
    id?: string
    action: string
    resource: string
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    action: string
    resource: string
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutWorkspaceInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput>
  }

  export type AuditLogCreateManyWorkspaceInputEnvelope = {
    data: AuditLogCreateManyWorkspaceInput | AuditLogCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type InvitationCreateWithoutWorkspaceInput = {
    id?: string
    email: string
    code: string
    type: $Enums.InvitationType
    status?: $Enums.InvitationStatus
    data?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    email: string
    code: string
    type: $Enums.InvitationType
    status?: $Enums.InvitationStatus
    data?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvitationCreateOrConnectWithoutWorkspaceInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutWorkspaceInput, InvitationUncheckedCreateWithoutWorkspaceInput>
  }

  export type InvitationCreateManyWorkspaceInputEnvelope = {
    data: InvitationCreateManyWorkspaceInput | InvitationCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceMemberUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceMemberWhereUniqueInput
    update: XOR<WorkspaceMemberUpdateWithoutWorkspaceInput, WorkspaceMemberUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkspaceMemberCreateWithoutWorkspaceInput, WorkspaceMemberUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkspaceMemberUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkspaceMemberWhereUniqueInput
    data: XOR<WorkspaceMemberUpdateWithoutWorkspaceInput, WorkspaceMemberUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkspaceMemberUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkspaceMemberScalarWhereInput
    data: XOR<WorkspaceMemberUpdateManyMutationInput, WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type DepartmentUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutWorkspaceInput, DepartmentUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<DepartmentCreateWithoutWorkspaceInput, DepartmentUncheckedCreateWithoutWorkspaceInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutWorkspaceInput, DepartmentUncheckedUpdateWithoutWorkspaceInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutWorkspaceInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    workspaceId?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    code?: StringNullableFilter<"Department"> | string | null
    description?: StringNullableFilter<"Department"> | string | null
    managerId?: StringNullableFilter<"Department"> | string | null
    parentId?: StringNullableFilter<"Department"> | string | null
    status?: StringFilter<"Department"> | string
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
  }

  export type TeamUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutWorkspaceInput, TeamUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<TeamCreateWithoutWorkspaceInput, TeamUncheckedCreateWithoutWorkspaceInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutWorkspaceInput, TeamUncheckedUpdateWithoutWorkspaceInput>
  }

  export type TeamUpdateManyWithWhereWithoutWorkspaceInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: StringFilter<"Team"> | string
    workspaceId?: StringFilter<"Team"> | string
    departmentId?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    description?: StringNullableFilter<"Team"> | string | null
    leaderId?: StringNullableFilter<"Team"> | string | null
    status?: StringFilter<"Team"> | string
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
  }

  export type PositionUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: PositionWhereUniqueInput
    update: XOR<PositionUpdateWithoutWorkspaceInput, PositionUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<PositionCreateWithoutWorkspaceInput, PositionUncheckedCreateWithoutWorkspaceInput>
  }

  export type PositionUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: PositionWhereUniqueInput
    data: XOR<PositionUpdateWithoutWorkspaceInput, PositionUncheckedUpdateWithoutWorkspaceInput>
  }

  export type PositionUpdateManyWithWhereWithoutWorkspaceInput = {
    where: PositionScalarWhereInput
    data: XOR<PositionUpdateManyMutationInput, PositionUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type PositionScalarWhereInput = {
    AND?: PositionScalarWhereInput | PositionScalarWhereInput[]
    OR?: PositionScalarWhereInput[]
    NOT?: PositionScalarWhereInput | PositionScalarWhereInput[]
    id?: StringFilter<"Position"> | string
    workspaceId?: StringFilter<"Position"> | string
    name?: StringFilter<"Position"> | string
    code?: StringNullableFilter<"Position"> | string | null
    description?: StringNullableFilter<"Position"> | string | null
    status?: StringFilter<"Position"> | string
    createdAt?: DateTimeFilter<"Position"> | Date | string
    updatedAt?: DateTimeFilter<"Position"> | Date | string
  }

  export type PositionLevelUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: PositionLevelWhereUniqueInput
    update: XOR<PositionLevelUpdateWithoutWorkspaceInput, PositionLevelUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<PositionLevelCreateWithoutWorkspaceInput, PositionLevelUncheckedCreateWithoutWorkspaceInput>
  }

  export type PositionLevelUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: PositionLevelWhereUniqueInput
    data: XOR<PositionLevelUpdateWithoutWorkspaceInput, PositionLevelUncheckedUpdateWithoutWorkspaceInput>
  }

  export type PositionLevelUpdateManyWithWhereWithoutWorkspaceInput = {
    where: PositionLevelScalarWhereInput
    data: XOR<PositionLevelUpdateManyMutationInput, PositionLevelUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type PositionLevelScalarWhereInput = {
    AND?: PositionLevelScalarWhereInput | PositionLevelScalarWhereInput[]
    OR?: PositionLevelScalarWhereInput[]
    NOT?: PositionLevelScalarWhereInput | PositionLevelScalarWhereInput[]
    id?: StringFilter<"PositionLevel"> | string
    workspaceId?: StringFilter<"PositionLevel"> | string
    name?: StringFilter<"PositionLevel"> | string
    level?: IntFilter<"PositionLevel"> | number
    description?: StringNullableFilter<"PositionLevel"> | string | null
    status?: StringFilter<"PositionLevel"> | string
    createdAt?: DateTimeFilter<"PositionLevel"> | Date | string
    updatedAt?: DateTimeFilter<"PositionLevel"> | Date | string
  }

  export type EmployeeUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutWorkspaceInput, EmployeeUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<EmployeeCreateWithoutWorkspaceInput, EmployeeUncheckedCreateWithoutWorkspaceInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutWorkspaceInput, EmployeeUncheckedUpdateWithoutWorkspaceInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutWorkspaceInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: StringFilter<"Employee"> | string
    workspaceId?: StringFilter<"Employee"> | string
    userId?: StringNullableFilter<"Employee"> | string | null
    employeeCode?: StringNullableFilter<"Employee"> | string | null
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    thaiFirstName?: StringNullableFilter<"Employee"> | string | null
    thaiLastName?: StringNullableFilter<"Employee"> | string | null
    nickname?: StringNullableFilter<"Employee"> | string | null
    email?: StringFilter<"Employee"> | string
    phone?: StringNullableFilter<"Employee"> | string | null
    emergencyContact?: StringNullableFilter<"Employee"> | string | null
    birthdate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    gender?: StringNullableFilter<"Employee"> | string | null
    nationalId?: StringNullableFilter<"Employee"> | string | null
    nationalIdIv?: StringNullableFilter<"Employee"> | string | null
    passportNumber?: StringNullableFilter<"Employee"> | string | null
    passportNumberIv?: StringNullableFilter<"Employee"> | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    taxId?: StringNullableFilter<"Employee"> | string | null
    bankAccount?: StringNullableFilter<"Employee"> | string | null
    bankAccountIv?: StringNullableFilter<"Employee"> | string | null
    bankName?: StringNullableFilter<"Employee"> | string | null
    hireDate?: DateTimeFilter<"Employee"> | Date | string
    probationEndDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    resignDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    departmentId?: StringNullableFilter<"Employee"> | string | null
    teamId?: StringNullableFilter<"Employee"> | string | null
    positionId?: StringNullableFilter<"Employee"> | string | null
    positionLevelId?: StringNullableFilter<"Employee"> | string | null
    managerId?: StringNullableFilter<"Employee"> | string | null
    status?: EnumEmployeeStatusFilter<"Employee"> | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFilter<"Employee"> | $Enums.EmploymentType
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
  }

  export type ProjectUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutWorkspaceInput, ProjectUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ProjectCreateWithoutWorkspaceInput, ProjectUncheckedCreateWithoutWorkspaceInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutWorkspaceInput, ProjectUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ProjectUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    workspaceId?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    code?: StringNullableFilter<"Project"> | string | null
    description?: StringNullableFilter<"Project"> | string | null
    startDate?: DateTimeFilter<"Project"> | Date | string
    endDate?: DateTimeNullableFilter<"Project"> | Date | string | null
    budget?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    priority?: EnumProjectPriorityFilter<"Project"> | $Enums.ProjectPriority
    managerId?: StringNullableFilter<"Project"> | string | null
    clientName?: StringNullableFilter<"Project"> | string | null
    clientContact?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
  }

  export type ProjectRoleUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ProjectRoleWhereUniqueInput
    update: XOR<ProjectRoleUpdateWithoutWorkspaceInput, ProjectRoleUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ProjectRoleCreateWithoutWorkspaceInput, ProjectRoleUncheckedCreateWithoutWorkspaceInput>
  }

  export type ProjectRoleUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ProjectRoleWhereUniqueInput
    data: XOR<ProjectRoleUpdateWithoutWorkspaceInput, ProjectRoleUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ProjectRoleUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ProjectRoleScalarWhereInput
    data: XOR<ProjectRoleUpdateManyMutationInput, ProjectRoleUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ProjectRoleScalarWhereInput = {
    AND?: ProjectRoleScalarWhereInput | ProjectRoleScalarWhereInput[]
    OR?: ProjectRoleScalarWhereInput[]
    NOT?: ProjectRoleScalarWhereInput | ProjectRoleScalarWhereInput[]
    id?: StringFilter<"ProjectRole"> | string
    workspaceId?: StringNullableFilter<"ProjectRole"> | string | null
    name?: StringFilter<"ProjectRole"> | string
    description?: StringNullableFilter<"ProjectRole"> | string | null
    createdAt?: DateTimeFilter<"ProjectRole"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectRole"> | Date | string
  }

  export type LeaveTypeUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: LeaveTypeWhereUniqueInput
    update: XOR<LeaveTypeUpdateWithoutWorkspaceInput, LeaveTypeUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<LeaveTypeCreateWithoutWorkspaceInput, LeaveTypeUncheckedCreateWithoutWorkspaceInput>
  }

  export type LeaveTypeUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: LeaveTypeWhereUniqueInput
    data: XOR<LeaveTypeUpdateWithoutWorkspaceInput, LeaveTypeUncheckedUpdateWithoutWorkspaceInput>
  }

  export type LeaveTypeUpdateManyWithWhereWithoutWorkspaceInput = {
    where: LeaveTypeScalarWhereInput
    data: XOR<LeaveTypeUpdateManyMutationInput, LeaveTypeUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type LeaveTypeScalarWhereInput = {
    AND?: LeaveTypeScalarWhereInput | LeaveTypeScalarWhereInput[]
    OR?: LeaveTypeScalarWhereInput[]
    NOT?: LeaveTypeScalarWhereInput | LeaveTypeScalarWhereInput[]
    id?: StringFilter<"LeaveType"> | string
    workspaceId?: StringFilter<"LeaveType"> | string
    name?: StringFilter<"LeaveType"> | string
    code?: StringFilter<"LeaveType"> | string
    description?: StringNullableFilter<"LeaveType"> | string | null
    color?: StringNullableFilter<"LeaveType"> | string | null
    isPaid?: BoolFilter<"LeaveType"> | boolean
    requiresApproval?: BoolFilter<"LeaveType"> | boolean
    requiresAttachment?: BoolFilter<"LeaveType"> | boolean
    maxDaysPerYear?: IntNullableFilter<"LeaveType"> | number | null
    status?: StringFilter<"LeaveType"> | string
    createdAt?: DateTimeFilter<"LeaveType"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveType"> | Date | string
  }

  export type LeaveQuotaUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: LeaveQuotaWhereUniqueInput
    update: XOR<LeaveQuotaUpdateWithoutWorkspaceInput, LeaveQuotaUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<LeaveQuotaCreateWithoutWorkspaceInput, LeaveQuotaUncheckedCreateWithoutWorkspaceInput>
  }

  export type LeaveQuotaUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: LeaveQuotaWhereUniqueInput
    data: XOR<LeaveQuotaUpdateWithoutWorkspaceInput, LeaveQuotaUncheckedUpdateWithoutWorkspaceInput>
  }

  export type LeaveQuotaUpdateManyWithWhereWithoutWorkspaceInput = {
    where: LeaveQuotaScalarWhereInput
    data: XOR<LeaveQuotaUpdateManyMutationInput, LeaveQuotaUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type LeaveQuotaScalarWhereInput = {
    AND?: LeaveQuotaScalarWhereInput | LeaveQuotaScalarWhereInput[]
    OR?: LeaveQuotaScalarWhereInput[]
    NOT?: LeaveQuotaScalarWhereInput | LeaveQuotaScalarWhereInput[]
    id?: StringFilter<"LeaveQuota"> | string
    workspaceId?: StringFilter<"LeaveQuota"> | string
    employeeId?: StringFilter<"LeaveQuota"> | string
    leaveTypeId?: StringFilter<"LeaveQuota"> | string
    year?: IntFilter<"LeaveQuota"> | number
    total?: FloatFilter<"LeaveQuota"> | number
    used?: FloatFilter<"LeaveQuota"> | number
    pending?: FloatFilter<"LeaveQuota"> | number
    remaining?: FloatFilter<"LeaveQuota"> | number
    createdAt?: DateTimeFilter<"LeaveQuota"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveQuota"> | Date | string
  }

  export type LeaveUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: LeaveWhereUniqueInput
    update: XOR<LeaveUpdateWithoutWorkspaceInput, LeaveUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<LeaveCreateWithoutWorkspaceInput, LeaveUncheckedCreateWithoutWorkspaceInput>
  }

  export type LeaveUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: LeaveWhereUniqueInput
    data: XOR<LeaveUpdateWithoutWorkspaceInput, LeaveUncheckedUpdateWithoutWorkspaceInput>
  }

  export type LeaveUpdateManyWithWhereWithoutWorkspaceInput = {
    where: LeaveScalarWhereInput
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type LeaveScalarWhereInput = {
    AND?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    OR?: LeaveScalarWhereInput[]
    NOT?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    id?: StringFilter<"Leave"> | string
    workspaceId?: StringFilter<"Leave"> | string
    employeeId?: StringFilter<"Leave"> | string
    leaveTypeId?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    halfDay?: BoolFilter<"Leave"> | boolean
    duration?: FloatFilter<"Leave"> | number
    reason?: StringNullableFilter<"Leave"> | string | null
    attachment?: StringNullableFilter<"Leave"> | string | null
    status?: EnumLeaveStatusFilter<"Leave"> | $Enums.LeaveStatus
    notes?: StringNullableFilter<"Leave"> | string | null
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
  }

  export type OvertimePolicyUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: OvertimePolicyWhereUniqueInput
    update: XOR<OvertimePolicyUpdateWithoutWorkspaceInput, OvertimePolicyUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<OvertimePolicyCreateWithoutWorkspaceInput, OvertimePolicyUncheckedCreateWithoutWorkspaceInput>
  }

  export type OvertimePolicyUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: OvertimePolicyWhereUniqueInput
    data: XOR<OvertimePolicyUpdateWithoutWorkspaceInput, OvertimePolicyUncheckedUpdateWithoutWorkspaceInput>
  }

  export type OvertimePolicyUpdateManyWithWhereWithoutWorkspaceInput = {
    where: OvertimePolicyScalarWhereInput
    data: XOR<OvertimePolicyUpdateManyMutationInput, OvertimePolicyUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type OvertimePolicyScalarWhereInput = {
    AND?: OvertimePolicyScalarWhereInput | OvertimePolicyScalarWhereInput[]
    OR?: OvertimePolicyScalarWhereInput[]
    NOT?: OvertimePolicyScalarWhereInput | OvertimePolicyScalarWhereInput[]
    id?: StringFilter<"OvertimePolicy"> | string
    workspaceId?: StringFilter<"OvertimePolicy"> | string
    name?: StringFilter<"OvertimePolicy"> | string
    description?: StringNullableFilter<"OvertimePolicy"> | string | null
    rate?: FloatFilter<"OvertimePolicy"> | number
    minimumHours?: FloatFilter<"OvertimePolicy"> | number
    maximumHours?: FloatNullableFilter<"OvertimePolicy"> | number | null
    requiresApproval?: BoolFilter<"OvertimePolicy"> | boolean
    status?: StringFilter<"OvertimePolicy"> | string
    createdAt?: DateTimeFilter<"OvertimePolicy"> | Date | string
    updatedAt?: DateTimeFilter<"OvertimePolicy"> | Date | string
  }

  export type OvertimeUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: OvertimeWhereUniqueInput
    update: XOR<OvertimeUpdateWithoutWorkspaceInput, OvertimeUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<OvertimeCreateWithoutWorkspaceInput, OvertimeUncheckedCreateWithoutWorkspaceInput>
  }

  export type OvertimeUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: OvertimeWhereUniqueInput
    data: XOR<OvertimeUpdateWithoutWorkspaceInput, OvertimeUncheckedUpdateWithoutWorkspaceInput>
  }

  export type OvertimeUpdateManyWithWhereWithoutWorkspaceInput = {
    where: OvertimeScalarWhereInput
    data: XOR<OvertimeUpdateManyMutationInput, OvertimeUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type OvertimeScalarWhereInput = {
    AND?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
    OR?: OvertimeScalarWhereInput[]
    NOT?: OvertimeScalarWhereInput | OvertimeScalarWhereInput[]
    id?: StringFilter<"Overtime"> | string
    workspaceId?: StringFilter<"Overtime"> | string
    employeeId?: StringFilter<"Overtime"> | string
    policyId?: StringFilter<"Overtime"> | string
    date?: DateTimeFilter<"Overtime"> | Date | string
    startTime?: DateTimeFilter<"Overtime"> | Date | string
    endTime?: DateTimeFilter<"Overtime"> | Date | string
    hours?: FloatFilter<"Overtime"> | number
    reason?: StringFilter<"Overtime"> | string
    status?: EnumOvertimeStatusFilter<"Overtime"> | $Enums.OvertimeStatus
    notes?: StringNullableFilter<"Overtime"> | string | null
    createdAt?: DateTimeFilter<"Overtime"> | Date | string
    updatedAt?: DateTimeFilter<"Overtime"> | Date | string
  }

  export type ApprovalTemplateUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ApprovalTemplateWhereUniqueInput
    update: XOR<ApprovalTemplateUpdateWithoutWorkspaceInput, ApprovalTemplateUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ApprovalTemplateCreateWithoutWorkspaceInput, ApprovalTemplateUncheckedCreateWithoutWorkspaceInput>
  }

  export type ApprovalTemplateUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ApprovalTemplateWhereUniqueInput
    data: XOR<ApprovalTemplateUpdateWithoutWorkspaceInput, ApprovalTemplateUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ApprovalTemplateUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ApprovalTemplateScalarWhereInput
    data: XOR<ApprovalTemplateUpdateManyMutationInput, ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ApprovalTemplateScalarWhereInput = {
    AND?: ApprovalTemplateScalarWhereInput | ApprovalTemplateScalarWhereInput[]
    OR?: ApprovalTemplateScalarWhereInput[]
    NOT?: ApprovalTemplateScalarWhereInput | ApprovalTemplateScalarWhereInput[]
    id?: StringFilter<"ApprovalTemplate"> | string
    workspaceId?: StringFilter<"ApprovalTemplate"> | string
    name?: StringFilter<"ApprovalTemplate"> | string
    description?: StringNullableFilter<"ApprovalTemplate"> | string | null
    entityType?: StringFilter<"ApprovalTemplate"> | string
    active?: BoolFilter<"ApprovalTemplate"> | boolean
    createdAt?: DateTimeFilter<"ApprovalTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"ApprovalTemplate"> | Date | string
  }

  export type ApprovalUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ApprovalWhereUniqueInput
    update: XOR<ApprovalUpdateWithoutWorkspaceInput, ApprovalUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ApprovalCreateWithoutWorkspaceInput, ApprovalUncheckedCreateWithoutWorkspaceInput>
  }

  export type ApprovalUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ApprovalWhereUniqueInput
    data: XOR<ApprovalUpdateWithoutWorkspaceInput, ApprovalUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ApprovalUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ApprovalScalarWhereInput
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ApprovalScalarWhereInput = {
    AND?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
    OR?: ApprovalScalarWhereInput[]
    NOT?: ApprovalScalarWhereInput | ApprovalScalarWhereInput[]
    id?: StringFilter<"Approval"> | string
    workspaceId?: StringFilter<"Approval"> | string
    templateId?: StringFilter<"Approval"> | string
    entityType?: StringFilter<"Approval"> | string
    entityId?: StringFilter<"Approval"> | string
    requesterId?: StringFilter<"Approval"> | string
    currentStep?: IntFilter<"Approval"> | number
    status?: EnumApprovalStatusFilter<"Approval"> | $Enums.ApprovalStatus
    leaveId?: StringNullableFilter<"Approval"> | string | null
    overtimeId?: StringNullableFilter<"Approval"> | string | null
    createdAt?: DateTimeFilter<"Approval"> | Date | string
    updatedAt?: DateTimeFilter<"Approval"> | Date | string
  }

  export type SettingsUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: SettingsWhereUniqueInput
    update: XOR<SettingsUpdateWithoutWorkspaceInput, SettingsUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<SettingsCreateWithoutWorkspaceInput, SettingsUncheckedCreateWithoutWorkspaceInput>
  }

  export type SettingsUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: SettingsWhereUniqueInput
    data: XOR<SettingsUpdateWithoutWorkspaceInput, SettingsUncheckedUpdateWithoutWorkspaceInput>
  }

  export type SettingsUpdateManyWithWhereWithoutWorkspaceInput = {
    where: SettingsScalarWhereInput
    data: XOR<SettingsUpdateManyMutationInput, SettingsUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type SettingsScalarWhereInput = {
    AND?: SettingsScalarWhereInput | SettingsScalarWhereInput[]
    OR?: SettingsScalarWhereInput[]
    NOT?: SettingsScalarWhereInput | SettingsScalarWhereInput[]
    id?: StringFilter<"Settings"> | string
    workspaceId?: StringFilter<"Settings"> | string
    category?: StringFilter<"Settings"> | string
    key?: StringFilter<"Settings"> | string
    value?: StringFilter<"Settings"> | string
    createdAt?: DateTimeFilter<"Settings"> | Date | string
    updatedAt?: DateTimeFilter<"Settings"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutWorkspaceInput, AuditLogUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<AuditLogCreateWithoutWorkspaceInput, AuditLogUncheckedCreateWithoutWorkspaceInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutWorkspaceInput, AuditLogUncheckedUpdateWithoutWorkspaceInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutWorkspaceInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type InvitationUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutWorkspaceInput, InvitationUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<InvitationCreateWithoutWorkspaceInput, InvitationUncheckedCreateWithoutWorkspaceInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutWorkspaceInput, InvitationUncheckedUpdateWithoutWorkspaceInput>
  }

  export type InvitationUpdateManyWithWhereWithoutWorkspaceInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type InvitationScalarWhereInput = {
    AND?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    OR?: InvitationScalarWhereInput[]
    NOT?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    id?: StringFilter<"Invitation"> | string
    workspaceId?: StringFilter<"Invitation"> | string
    email?: StringFilter<"Invitation"> | string
    code?: StringFilter<"Invitation"> | string
    type?: EnumInvitationTypeFilter<"Invitation"> | $Enums.InvitationType
    status?: EnumInvitationStatusFilter<"Invitation"> | $Enums.InvitationStatus
    data?: StringNullableFilter<"Invitation"> | string | null
    expiresAt?: DateTimeFilter<"Invitation"> | Date | string
    createdAt?: DateTimeFilter<"Invitation"> | Date | string
    updatedAt?: DateTimeFilter<"Invitation"> | Date | string
  }

  export type WorkspaceCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutMembersInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutWorkspaceMemberInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    approvalActions?: ApprovalActionCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkspaceMemberInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    approvalActions?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkspaceMemberInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkspaceMemberInput, UserUncheckedCreateWithoutWorkspaceMemberInput>
  }

  export type WorkspaceUpsertWithoutMembersInput = {
    update: XOR<WorkspaceUpdateWithoutMembersInput, WorkspaceUncheckedUpdateWithoutMembersInput>
    create: XOR<WorkspaceCreateWithoutMembersInput, WorkspaceUncheckedCreateWithoutMembersInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutMembersInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutMembersInput, WorkspaceUncheckedUpdateWithoutMembersInput>
  }

  export type WorkspaceUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserUpsertWithoutWorkspaceMemberInput = {
    update: XOR<UserUpdateWithoutWorkspaceMemberInput, UserUncheckedUpdateWithoutWorkspaceMemberInput>
    create: XOR<UserCreateWithoutWorkspaceMemberInput, UserUncheckedCreateWithoutWorkspaceMemberInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkspaceMemberInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkspaceMemberInput, UserUncheckedUpdateWithoutWorkspaceMemberInput>
  }

  export type UserUpdateWithoutWorkspaceMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    approvalActions?: ApprovalActionUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkspaceMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    approvalActions?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutDepartmentsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutDepartmentsInput, WorkspaceUncheckedCreateWithoutDepartmentsInput>
  }

  export type TeamCreateWithoutDepartmentInput = {
    id?: string
    name: string
    description?: string | null
    leaderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutTeamsInput
    employees?: EmployeeCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutDepartmentInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    leaderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutDepartmentInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutDepartmentInput, TeamUncheckedCreateWithoutDepartmentInput>
  }

  export type TeamCreateManyDepartmentInputEnvelope = {
    data: TeamCreateManyDepartmentInput | TeamCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutDepartmentInput = {
    id?: string
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeeInput
    workspace: WorkspaceCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    positionLevel?: PositionLevelCreateNestedOneWithoutEmployeesInput
    manager?: EmployeeCreateNestedOneWithoutSubordinatesInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDepartmentInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    teamId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeCreateManyDepartmentInputEnvelope = {
    data: EmployeeCreateManyDepartmentInput | EmployeeCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutChildrenInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    managerId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutDepartmentsInput
    teams?: TeamCreateNestedManyWithoutDepartmentInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
    parent?: DepartmentCreateNestedOneWithoutChildrenInput
  }

  export type DepartmentUncheckedCreateWithoutChildrenInput = {
    id?: string
    workspaceId: string
    name: string
    code?: string | null
    description?: string | null
    managerId?: string | null
    parentId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutDepartmentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutChildrenInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutChildrenInput, DepartmentUncheckedCreateWithoutChildrenInput>
  }

  export type DepartmentCreateWithoutParentInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    managerId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutDepartmentsInput
    teams?: TeamCreateNestedManyWithoutDepartmentInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
    children?: DepartmentCreateNestedManyWithoutParentInput
  }

  export type DepartmentUncheckedCreateWithoutParentInput = {
    id?: string
    workspaceId: string
    name: string
    code?: string | null
    description?: string | null
    managerId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutDepartmentInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    children?: DepartmentUncheckedCreateNestedManyWithoutParentInput
  }

  export type DepartmentCreateOrConnectWithoutParentInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput>
  }

  export type DepartmentCreateManyParentInputEnvelope = {
    data: DepartmentCreateManyParentInput | DepartmentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutDepartmentsInput = {
    update: XOR<WorkspaceUpdateWithoutDepartmentsInput, WorkspaceUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<WorkspaceCreateWithoutDepartmentsInput, WorkspaceUncheckedCreateWithoutDepartmentsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutDepartmentsInput, WorkspaceUncheckedUpdateWithoutDepartmentsInput>
  }

  export type WorkspaceUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type TeamUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutDepartmentInput, TeamUncheckedUpdateWithoutDepartmentInput>
    create: XOR<TeamCreateWithoutDepartmentInput, TeamUncheckedCreateWithoutDepartmentInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutDepartmentInput, TeamUncheckedUpdateWithoutDepartmentInput>
  }

  export type TeamUpdateManyWithWhereWithoutDepartmentInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type EmployeeUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutDepartmentInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type DepartmentUpsertWithoutChildrenInput = {
    update: XOR<DepartmentUpdateWithoutChildrenInput, DepartmentUncheckedUpdateWithoutChildrenInput>
    create: XOR<DepartmentCreateWithoutChildrenInput, DepartmentUncheckedCreateWithoutChildrenInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutChildrenInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutChildrenInput, DepartmentUncheckedUpdateWithoutChildrenInput>
  }

  export type DepartmentUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutDepartmentsNestedInput
    teams?: TeamUpdateManyWithoutDepartmentNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
    parent?: DepartmentUpdateOneWithoutChildrenNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutDepartmentNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUpsertWithWhereUniqueWithoutParentInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutParentInput, DepartmentUncheckedUpdateWithoutParentInput>
    create: XOR<DepartmentCreateWithoutParentInput, DepartmentUncheckedCreateWithoutParentInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutParentInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutParentInput, DepartmentUncheckedUpdateWithoutParentInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutParentInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutParentInput>
  }

  export type WorkspaceCreateWithoutTeamsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutTeamsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutTeamsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutTeamsInput, WorkspaceUncheckedCreateWithoutTeamsInput>
  }

  export type DepartmentCreateWithoutTeamsInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    managerId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutDepartmentsInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
    parent?: DepartmentCreateNestedOneWithoutChildrenInput
    children?: DepartmentCreateNestedManyWithoutParentInput
  }

  export type DepartmentUncheckedCreateWithoutTeamsInput = {
    id?: string
    workspaceId: string
    name: string
    code?: string | null
    description?: string | null
    managerId?: string | null
    parentId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
    children?: DepartmentUncheckedCreateNestedManyWithoutParentInput
  }

  export type DepartmentCreateOrConnectWithoutTeamsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutTeamsInput, DepartmentUncheckedCreateWithoutTeamsInput>
  }

  export type EmployeeCreateWithoutTeamInput = {
    id?: string
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeeInput
    workspace: WorkspaceCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    positionLevel?: PositionLevelCreateNestedOneWithoutEmployeesInput
    manager?: EmployeeCreateNestedOneWithoutSubordinatesInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutTeamInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutTeamInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutTeamInput, EmployeeUncheckedCreateWithoutTeamInput>
  }

  export type EmployeeCreateManyTeamInputEnvelope = {
    data: EmployeeCreateManyTeamInput | EmployeeCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutTeamsInput = {
    update: XOR<WorkspaceUpdateWithoutTeamsInput, WorkspaceUncheckedUpdateWithoutTeamsInput>
    create: XOR<WorkspaceCreateWithoutTeamsInput, WorkspaceUncheckedCreateWithoutTeamsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutTeamsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutTeamsInput, WorkspaceUncheckedUpdateWithoutTeamsInput>
  }

  export type WorkspaceUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type DepartmentUpsertWithoutTeamsInput = {
    update: XOR<DepartmentUpdateWithoutTeamsInput, DepartmentUncheckedUpdateWithoutTeamsInput>
    create: XOR<DepartmentCreateWithoutTeamsInput, DepartmentUncheckedCreateWithoutTeamsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutTeamsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutTeamsInput, DepartmentUncheckedUpdateWithoutTeamsInput>
  }

  export type DepartmentUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutDepartmentsNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
    parent?: DepartmentUpdateOneWithoutChildrenNestedInput
    children?: DepartmentUpdateManyWithoutParentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
    children?: DepartmentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type EmployeeUpsertWithWhereUniqueWithoutTeamInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutTeamInput, EmployeeUncheckedUpdateWithoutTeamInput>
    create: XOR<EmployeeCreateWithoutTeamInput, EmployeeUncheckedCreateWithoutTeamInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutTeamInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutTeamInput, EmployeeUncheckedUpdateWithoutTeamInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutTeamInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutTeamInput>
  }

  export type WorkspaceCreateWithoutPositionsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutPositionsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutPositionsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutPositionsInput, WorkspaceUncheckedCreateWithoutPositionsInput>
  }

  export type EmployeeCreateWithoutPositionInput = {
    id?: string
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeeInput
    workspace: WorkspaceCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    positionLevel?: PositionLevelCreateNestedOneWithoutEmployeesInput
    manager?: EmployeeCreateNestedOneWithoutSubordinatesInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPositionInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPositionInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput>
  }

  export type EmployeeCreateManyPositionInputEnvelope = {
    data: EmployeeCreateManyPositionInput | EmployeeCreateManyPositionInput[]
    skipDuplicates?: boolean
  }

  export type EmploymentHistoryCreateWithoutPositionInput = {
    id?: string
    departmentId?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutEmploymentHistoryInput
    positionLevel?: PositionLevelCreateNestedOneWithoutEmploymentHistoryInput
  }

  export type EmploymentHistoryUncheckedCreateWithoutPositionInput = {
    id?: string
    employeeId: string
    positionLevelId?: string | null
    departmentId?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmploymentHistoryCreateOrConnectWithoutPositionInput = {
    where: EmploymentHistoryWhereUniqueInput
    create: XOR<EmploymentHistoryCreateWithoutPositionInput, EmploymentHistoryUncheckedCreateWithoutPositionInput>
  }

  export type EmploymentHistoryCreateManyPositionInputEnvelope = {
    data: EmploymentHistoryCreateManyPositionInput | EmploymentHistoryCreateManyPositionInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutPositionsInput = {
    update: XOR<WorkspaceUpdateWithoutPositionsInput, WorkspaceUncheckedUpdateWithoutPositionsInput>
    create: XOR<WorkspaceCreateWithoutPositionsInput, WorkspaceUncheckedCreateWithoutPositionsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutPositionsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutPositionsInput, WorkspaceUncheckedUpdateWithoutPositionsInput>
  }

  export type WorkspaceUpdateWithoutPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutPositionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type EmployeeUpsertWithWhereUniqueWithoutPositionInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutPositionInput, EmployeeUncheckedUpdateWithoutPositionInput>
    create: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutPositionInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutPositionInput, EmployeeUncheckedUpdateWithoutPositionInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutPositionInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutPositionInput>
  }

  export type EmploymentHistoryUpsertWithWhereUniqueWithoutPositionInput = {
    where: EmploymentHistoryWhereUniqueInput
    update: XOR<EmploymentHistoryUpdateWithoutPositionInput, EmploymentHistoryUncheckedUpdateWithoutPositionInput>
    create: XOR<EmploymentHistoryCreateWithoutPositionInput, EmploymentHistoryUncheckedCreateWithoutPositionInput>
  }

  export type EmploymentHistoryUpdateWithWhereUniqueWithoutPositionInput = {
    where: EmploymentHistoryWhereUniqueInput
    data: XOR<EmploymentHistoryUpdateWithoutPositionInput, EmploymentHistoryUncheckedUpdateWithoutPositionInput>
  }

  export type EmploymentHistoryUpdateManyWithWhereWithoutPositionInput = {
    where: EmploymentHistoryScalarWhereInput
    data: XOR<EmploymentHistoryUpdateManyMutationInput, EmploymentHistoryUncheckedUpdateManyWithoutPositionInput>
  }

  export type EmploymentHistoryScalarWhereInput = {
    AND?: EmploymentHistoryScalarWhereInput | EmploymentHistoryScalarWhereInput[]
    OR?: EmploymentHistoryScalarWhereInput[]
    NOT?: EmploymentHistoryScalarWhereInput | EmploymentHistoryScalarWhereInput[]
    id?: StringFilter<"EmploymentHistory"> | string
    employeeId?: StringFilter<"EmploymentHistory"> | string
    positionId?: StringFilter<"EmploymentHistory"> | string
    positionLevelId?: StringNullableFilter<"EmploymentHistory"> | string | null
    departmentId?: StringNullableFilter<"EmploymentHistory"> | string | null
    startDate?: DateTimeFilter<"EmploymentHistory"> | Date | string
    endDate?: DateTimeNullableFilter<"EmploymentHistory"> | Date | string | null
    salary?: DecimalNullableFilter<"EmploymentHistory"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"EmploymentHistory"> | string | null
    createdAt?: DateTimeFilter<"EmploymentHistory"> | Date | string
    updatedAt?: DateTimeFilter<"EmploymentHistory"> | Date | string
  }

  export type WorkspaceCreateWithoutPositionLevelsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutPositionLevelsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutPositionLevelsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutPositionLevelsInput, WorkspaceUncheckedCreateWithoutPositionLevelsInput>
  }

  export type EmployeeCreateWithoutPositionLevelInput = {
    id?: string
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeeInput
    workspace: WorkspaceCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    manager?: EmployeeCreateNestedOneWithoutSubordinatesInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPositionLevelInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPositionLevelInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPositionLevelInput, EmployeeUncheckedCreateWithoutPositionLevelInput>
  }

  export type EmployeeCreateManyPositionLevelInputEnvelope = {
    data: EmployeeCreateManyPositionLevelInput | EmployeeCreateManyPositionLevelInput[]
    skipDuplicates?: boolean
  }

  export type EmploymentHistoryCreateWithoutPositionLevelInput = {
    id?: string
    departmentId?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutEmploymentHistoryInput
    position: PositionCreateNestedOneWithoutEmploymentHistoryInput
  }

  export type EmploymentHistoryUncheckedCreateWithoutPositionLevelInput = {
    id?: string
    employeeId: string
    positionId: string
    departmentId?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmploymentHistoryCreateOrConnectWithoutPositionLevelInput = {
    where: EmploymentHistoryWhereUniqueInput
    create: XOR<EmploymentHistoryCreateWithoutPositionLevelInput, EmploymentHistoryUncheckedCreateWithoutPositionLevelInput>
  }

  export type EmploymentHistoryCreateManyPositionLevelInputEnvelope = {
    data: EmploymentHistoryCreateManyPositionLevelInput | EmploymentHistoryCreateManyPositionLevelInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutPositionLevelsInput = {
    update: XOR<WorkspaceUpdateWithoutPositionLevelsInput, WorkspaceUncheckedUpdateWithoutPositionLevelsInput>
    create: XOR<WorkspaceCreateWithoutPositionLevelsInput, WorkspaceUncheckedCreateWithoutPositionLevelsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutPositionLevelsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutPositionLevelsInput, WorkspaceUncheckedUpdateWithoutPositionLevelsInput>
  }

  export type WorkspaceUpdateWithoutPositionLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutPositionLevelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type EmployeeUpsertWithWhereUniqueWithoutPositionLevelInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutPositionLevelInput, EmployeeUncheckedUpdateWithoutPositionLevelInput>
    create: XOR<EmployeeCreateWithoutPositionLevelInput, EmployeeUncheckedCreateWithoutPositionLevelInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutPositionLevelInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutPositionLevelInput, EmployeeUncheckedUpdateWithoutPositionLevelInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutPositionLevelInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutPositionLevelInput>
  }

  export type EmploymentHistoryUpsertWithWhereUniqueWithoutPositionLevelInput = {
    where: EmploymentHistoryWhereUniqueInput
    update: XOR<EmploymentHistoryUpdateWithoutPositionLevelInput, EmploymentHistoryUncheckedUpdateWithoutPositionLevelInput>
    create: XOR<EmploymentHistoryCreateWithoutPositionLevelInput, EmploymentHistoryUncheckedCreateWithoutPositionLevelInput>
  }

  export type EmploymentHistoryUpdateWithWhereUniqueWithoutPositionLevelInput = {
    where: EmploymentHistoryWhereUniqueInput
    data: XOR<EmploymentHistoryUpdateWithoutPositionLevelInput, EmploymentHistoryUncheckedUpdateWithoutPositionLevelInput>
  }

  export type EmploymentHistoryUpdateManyWithWhereWithoutPositionLevelInput = {
    where: EmploymentHistoryScalarWhereInput
    data: XOR<EmploymentHistoryUpdateManyMutationInput, EmploymentHistoryUncheckedUpdateManyWithoutPositionLevelInput>
  }

  export type UserCreateWithoutEmployeeInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    workspaceMember?: WorkspaceMemberCreateNestedManyWithoutUserInput
    approvalActions?: ApprovalActionCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmployeeInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    workspaceMember?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    approvalActions?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmployeeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
  }

  export type WorkspaceCreateWithoutEmployeesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutEmployeesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutEmployeesInput, WorkspaceUncheckedCreateWithoutEmployeesInput>
  }

  export type DepartmentCreateWithoutEmployeesInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    managerId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutDepartmentsInput
    teams?: TeamCreateNestedManyWithoutDepartmentInput
    parent?: DepartmentCreateNestedOneWithoutChildrenInput
    children?: DepartmentCreateNestedManyWithoutParentInput
  }

  export type DepartmentUncheckedCreateWithoutEmployeesInput = {
    id?: string
    workspaceId: string
    name: string
    code?: string | null
    description?: string | null
    managerId?: string | null
    parentId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutDepartmentInput
    children?: DepartmentUncheckedCreateNestedManyWithoutParentInput
  }

  export type DepartmentCreateOrConnectWithoutEmployeesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
  }

  export type TeamCreateWithoutEmployeesInput = {
    id?: string
    name: string
    description?: string | null
    leaderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutTeamsInput
    department: DepartmentCreateNestedOneWithoutTeamsInput
  }

  export type TeamUncheckedCreateWithoutEmployeesInput = {
    id?: string
    workspaceId: string
    departmentId: string
    name: string
    description?: string | null
    leaderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamCreateOrConnectWithoutEmployeesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutEmployeesInput, TeamUncheckedCreateWithoutEmployeesInput>
  }

  export type PositionCreateWithoutEmployeesInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutPositionsInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateWithoutEmployeesInput = {
    id?: string
    workspaceId: string
    name: string
    code?: string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionCreateOrConnectWithoutEmployeesInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutEmployeesInput, PositionUncheckedCreateWithoutEmployeesInput>
  }

  export type PositionLevelCreateWithoutEmployeesInput = {
    id?: string
    name: string
    level: number
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutPositionLevelsInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutPositionLevelInput
  }

  export type PositionLevelUncheckedCreateWithoutEmployeesInput = {
    id?: string
    workspaceId: string
    name: string
    level: number
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutPositionLevelInput
  }

  export type PositionLevelCreateOrConnectWithoutEmployeesInput = {
    where: PositionLevelWhereUniqueInput
    create: XOR<PositionLevelCreateWithoutEmployeesInput, PositionLevelUncheckedCreateWithoutEmployeesInput>
  }

  export type EmployeeCreateWithoutSubordinatesInput = {
    id?: string
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeeInput
    workspace: WorkspaceCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    positionLevel?: PositionLevelCreateNestedOneWithoutEmployeesInput
    manager?: EmployeeCreateNestedOneWithoutSubordinatesInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutSubordinatesInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutSubordinatesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutSubordinatesInput, EmployeeUncheckedCreateWithoutSubordinatesInput>
  }

  export type EmployeeCreateWithoutManagerInput = {
    id?: string
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeeInput
    workspace: WorkspaceCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    positionLevel?: PositionLevelCreateNestedOneWithoutEmployeesInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutManagerInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutManagerInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput>
  }

  export type EmployeeCreateManyManagerInputEnvelope = {
    data: EmployeeCreateManyManagerInput | EmployeeCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type ProjectMemberCreateWithoutEmployeeInput = {
    id?: string
    allocation?: number
    startDate?: Date | string
    endDate?: Date | string | null
    project: ProjectCreateNestedOneWithoutMembersInput
    projectRole: ProjectRoleCreateNestedOneWithoutProjectMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutEmployeeInput = {
    id?: string
    projectId: string
    roleId: string
    allocation?: number
    startDate?: Date | string
    endDate?: Date | string | null
  }

  export type ProjectMemberCreateOrConnectWithoutEmployeeInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutEmployeeInput, ProjectMemberUncheckedCreateWithoutEmployeeInput>
  }

  export type ProjectMemberCreateManyEmployeeInputEnvelope = {
    data: ProjectMemberCreateManyEmployeeInput | ProjectMemberCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type EmploymentHistoryCreateWithoutEmployeeInput = {
    id?: string
    departmentId?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    position: PositionCreateNestedOneWithoutEmploymentHistoryInput
    positionLevel?: PositionLevelCreateNestedOneWithoutEmploymentHistoryInput
  }

  export type EmploymentHistoryUncheckedCreateWithoutEmployeeInput = {
    id?: string
    positionId: string
    positionLevelId?: string | null
    departmentId?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmploymentHistoryCreateOrConnectWithoutEmployeeInput = {
    where: EmploymentHistoryWhereUniqueInput
    create: XOR<EmploymentHistoryCreateWithoutEmployeeInput, EmploymentHistoryUncheckedCreateWithoutEmployeeInput>
  }

  export type EmploymentHistoryCreateManyEmployeeInputEnvelope = {
    data: EmploymentHistoryCreateManyEmployeeInput | EmploymentHistoryCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeDocumentCreateWithoutEmployeeInput = {
    id?: string
    type: string
    name: string
    filename: string
    mimeType: string
    size: number
    url: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeDocumentUncheckedCreateWithoutEmployeeInput = {
    id?: string
    type: string
    name: string
    filename: string
    mimeType: string
    size: number
    url: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeDocumentCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeDocumentWhereUniqueInput
    create: XOR<EmployeeDocumentCreateWithoutEmployeeInput, EmployeeDocumentUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeDocumentCreateManyEmployeeInputEnvelope = {
    data: EmployeeDocumentCreateManyEmployeeInput | EmployeeDocumentCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LeaveQuotaCreateWithoutEmployeeInput = {
    id?: string
    year: number
    total: number
    used?: number
    pending?: number
    remaining: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutLeaveQuotasInput
    leaveType: LeaveTypeCreateNestedOneWithoutLeaveQuotasInput
  }

  export type LeaveQuotaUncheckedCreateWithoutEmployeeInput = {
    id?: string
    workspaceId: string
    leaveTypeId: string
    year: number
    total: number
    used?: number
    pending?: number
    remaining: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveQuotaCreateOrConnectWithoutEmployeeInput = {
    where: LeaveQuotaWhereUniqueInput
    create: XOR<LeaveQuotaCreateWithoutEmployeeInput, LeaveQuotaUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveQuotaCreateManyEmployeeInputEnvelope = {
    data: LeaveQuotaCreateManyEmployeeInput | LeaveQuotaCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LeaveCreateWithoutEmployeeInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    halfDay?: boolean
    duration: number
    reason?: string | null
    attachment?: string | null
    status?: $Enums.LeaveStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutLeavesInput
    leaveType: LeaveTypeCreateNestedOneWithoutLeavesInput
    approval?: ApprovalCreateNestedOneWithoutLeaveInput
  }

  export type LeaveUncheckedCreateWithoutEmployeeInput = {
    id?: string
    workspaceId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    halfDay?: boolean
    duration: number
    reason?: string | null
    attachment?: string | null
    status?: $Enums.LeaveStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approval?: ApprovalUncheckedCreateNestedOneWithoutLeaveInput
  }

  export type LeaveCreateOrConnectWithoutEmployeeInput = {
    where: LeaveWhereUniqueInput
    create: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveCreateManyEmployeeInputEnvelope = {
    data: LeaveCreateManyEmployeeInput | LeaveCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type OvertimeCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    hours: number
    reason: string
    status?: $Enums.OvertimeStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutOvertimesInput
    overtimePolicy: OvertimePolicyCreateNestedOneWithoutOvertimesInput
    approval?: ApprovalCreateNestedOneWithoutOvertimeInput
  }

  export type OvertimeUncheckedCreateWithoutEmployeeInput = {
    id?: string
    workspaceId: string
    policyId: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    hours: number
    reason: string
    status?: $Enums.OvertimeStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approval?: ApprovalUncheckedCreateNestedOneWithoutOvertimeInput
  }

  export type OvertimeCreateOrConnectWithoutEmployeeInput = {
    where: OvertimeWhereUniqueInput
    create: XOR<OvertimeCreateWithoutEmployeeInput, OvertimeUncheckedCreateWithoutEmployeeInput>
  }

  export type OvertimeCreateManyEmployeeInputEnvelope = {
    data: OvertimeCreateManyEmployeeInput | OvertimeCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutEmployeeInput = {
    update: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type UserUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    workspaceMember?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    approvalActions?: ApprovalActionUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    workspaceMember?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    approvalActions?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutEmployeesInput = {
    update: XOR<WorkspaceUpdateWithoutEmployeesInput, WorkspaceUncheckedUpdateWithoutEmployeesInput>
    create: XOR<WorkspaceCreateWithoutEmployeesInput, WorkspaceUncheckedCreateWithoutEmployeesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutEmployeesInput, WorkspaceUncheckedUpdateWithoutEmployeesInput>
  }

  export type WorkspaceUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type DepartmentUpsertWithoutEmployeesInput = {
    update: XOR<DepartmentUpdateWithoutEmployeesInput, DepartmentUncheckedUpdateWithoutEmployeesInput>
    create: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutEmployeesInput, DepartmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type DepartmentUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutDepartmentsNestedInput
    teams?: TeamUpdateManyWithoutDepartmentNestedInput
    parent?: DepartmentUpdateOneWithoutChildrenNestedInput
    children?: DepartmentUpdateManyWithoutParentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutDepartmentNestedInput
    children?: DepartmentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type TeamUpsertWithoutEmployeesInput = {
    update: XOR<TeamUpdateWithoutEmployeesInput, TeamUncheckedUpdateWithoutEmployeesInput>
    create: XOR<TeamCreateWithoutEmployeesInput, TeamUncheckedCreateWithoutEmployeesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutEmployeesInput, TeamUncheckedUpdateWithoutEmployeesInput>
  }

  export type TeamUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutTeamsNestedInput
    department?: DepartmentUpdateOneRequiredWithoutTeamsNestedInput
  }

  export type TeamUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUpsertWithoutEmployeesInput = {
    update: XOR<PositionUpdateWithoutEmployeesInput, PositionUncheckedUpdateWithoutEmployeesInput>
    create: XOR<PositionCreateWithoutEmployeesInput, PositionUncheckedCreateWithoutEmployeesInput>
    where?: PositionWhereInput
  }

  export type PositionUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: PositionWhereInput
    data: XOR<PositionUpdateWithoutEmployeesInput, PositionUncheckedUpdateWithoutEmployeesInput>
  }

  export type PositionUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutPositionsNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionLevelUpsertWithoutEmployeesInput = {
    update: XOR<PositionLevelUpdateWithoutEmployeesInput, PositionLevelUncheckedUpdateWithoutEmployeesInput>
    create: XOR<PositionLevelCreateWithoutEmployeesInput, PositionLevelUncheckedCreateWithoutEmployeesInput>
    where?: PositionLevelWhereInput
  }

  export type PositionLevelUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: PositionLevelWhereInput
    data: XOR<PositionLevelUpdateWithoutEmployeesInput, PositionLevelUncheckedUpdateWithoutEmployeesInput>
  }

  export type PositionLevelUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutPositionLevelsNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutPositionLevelNestedInput
  }

  export type PositionLevelUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutPositionLevelNestedInput
  }

  export type EmployeeUpsertWithoutSubordinatesInput = {
    update: XOR<EmployeeUpdateWithoutSubordinatesInput, EmployeeUncheckedUpdateWithoutSubordinatesInput>
    create: XOR<EmployeeCreateWithoutSubordinatesInput, EmployeeUncheckedCreateWithoutSubordinatesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutSubordinatesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutSubordinatesInput, EmployeeUncheckedUpdateWithoutSubordinatesInput>
  }

  export type EmployeeUpdateWithoutSubordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeeNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    positionLevel?: PositionLevelUpdateOneWithoutEmployeesNestedInput
    manager?: EmployeeUpdateOneWithoutSubordinatesNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutSubordinatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUpsertWithWhereUniqueWithoutManagerInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutManagerInput, EmployeeUncheckedUpdateWithoutManagerInput>
    create: XOR<EmployeeCreateWithoutManagerInput, EmployeeUncheckedCreateWithoutManagerInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutManagerInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutManagerInput, EmployeeUncheckedUpdateWithoutManagerInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutManagerInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutManagerInput>
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutEmployeeInput, ProjectMemberUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ProjectMemberCreateWithoutEmployeeInput, ProjectMemberUncheckedCreateWithoutEmployeeInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutEmployeeInput, ProjectMemberUncheckedUpdateWithoutEmployeeInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutEmployeeInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type ProjectMemberScalarWhereInput = {
    AND?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    OR?: ProjectMemberScalarWhereInput[]
    NOT?: ProjectMemberScalarWhereInput | ProjectMemberScalarWhereInput[]
    id?: StringFilter<"ProjectMember"> | string
    projectId?: StringFilter<"ProjectMember"> | string
    employeeId?: StringFilter<"ProjectMember"> | string
    roleId?: StringFilter<"ProjectMember"> | string
    allocation?: IntFilter<"ProjectMember"> | number
    startDate?: DateTimeFilter<"ProjectMember"> | Date | string
    endDate?: DateTimeNullableFilter<"ProjectMember"> | Date | string | null
  }

  export type EmploymentHistoryUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmploymentHistoryWhereUniqueInput
    update: XOR<EmploymentHistoryUpdateWithoutEmployeeInput, EmploymentHistoryUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmploymentHistoryCreateWithoutEmployeeInput, EmploymentHistoryUncheckedCreateWithoutEmployeeInput>
  }

  export type EmploymentHistoryUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmploymentHistoryWhereUniqueInput
    data: XOR<EmploymentHistoryUpdateWithoutEmployeeInput, EmploymentHistoryUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmploymentHistoryUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmploymentHistoryScalarWhereInput
    data: XOR<EmploymentHistoryUpdateManyMutationInput, EmploymentHistoryUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeDocumentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeDocumentWhereUniqueInput
    update: XOR<EmployeeDocumentUpdateWithoutEmployeeInput, EmployeeDocumentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeDocumentCreateWithoutEmployeeInput, EmployeeDocumentUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeDocumentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeDocumentWhereUniqueInput
    data: XOR<EmployeeDocumentUpdateWithoutEmployeeInput, EmployeeDocumentUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeDocumentUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeDocumentScalarWhereInput
    data: XOR<EmployeeDocumentUpdateManyMutationInput, EmployeeDocumentUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeDocumentScalarWhereInput = {
    AND?: EmployeeDocumentScalarWhereInput | EmployeeDocumentScalarWhereInput[]
    OR?: EmployeeDocumentScalarWhereInput[]
    NOT?: EmployeeDocumentScalarWhereInput | EmployeeDocumentScalarWhereInput[]
    id?: StringFilter<"EmployeeDocument"> | string
    employeeId?: StringFilter<"EmployeeDocument"> | string
    type?: StringFilter<"EmployeeDocument"> | string
    name?: StringFilter<"EmployeeDocument"> | string
    filename?: StringFilter<"EmployeeDocument"> | string
    mimeType?: StringFilter<"EmployeeDocument"> | string
    size?: IntFilter<"EmployeeDocument"> | number
    url?: StringFilter<"EmployeeDocument"> | string
    uploadedBy?: StringFilter<"EmployeeDocument"> | string
    createdAt?: DateTimeFilter<"EmployeeDocument"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeDocument"> | Date | string
  }

  export type LeaveQuotaUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveQuotaWhereUniqueInput
    update: XOR<LeaveQuotaUpdateWithoutEmployeeInput, LeaveQuotaUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LeaveQuotaCreateWithoutEmployeeInput, LeaveQuotaUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveQuotaUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveQuotaWhereUniqueInput
    data: XOR<LeaveQuotaUpdateWithoutEmployeeInput, LeaveQuotaUncheckedUpdateWithoutEmployeeInput>
  }

  export type LeaveQuotaUpdateManyWithWhereWithoutEmployeeInput = {
    where: LeaveQuotaScalarWhereInput
    data: XOR<LeaveQuotaUpdateManyMutationInput, LeaveQuotaUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type LeaveUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveWhereUniqueInput
    update: XOR<LeaveUpdateWithoutEmployeeInput, LeaveUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LeaveCreateWithoutEmployeeInput, LeaveUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveWhereUniqueInput
    data: XOR<LeaveUpdateWithoutEmployeeInput, LeaveUncheckedUpdateWithoutEmployeeInput>
  }

  export type LeaveUpdateManyWithWhereWithoutEmployeeInput = {
    where: LeaveScalarWhereInput
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type OvertimeUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: OvertimeWhereUniqueInput
    update: XOR<OvertimeUpdateWithoutEmployeeInput, OvertimeUncheckedUpdateWithoutEmployeeInput>
    create: XOR<OvertimeCreateWithoutEmployeeInput, OvertimeUncheckedCreateWithoutEmployeeInput>
  }

  export type OvertimeUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: OvertimeWhereUniqueInput
    data: XOR<OvertimeUpdateWithoutEmployeeInput, OvertimeUncheckedUpdateWithoutEmployeeInput>
  }

  export type OvertimeUpdateManyWithWhereWithoutEmployeeInput = {
    where: OvertimeScalarWhereInput
    data: XOR<OvertimeUpdateManyMutationInput, OvertimeUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeCreateWithoutEmploymentHistoryInput = {
    id?: string
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeeInput
    workspace: WorkspaceCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    positionLevel?: PositionLevelCreateNestedOneWithoutEmployeesInput
    manager?: EmployeeCreateNestedOneWithoutSubordinatesInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutEmploymentHistoryInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutEmploymentHistoryInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutEmploymentHistoryInput, EmployeeUncheckedCreateWithoutEmploymentHistoryInput>
  }

  export type PositionCreateWithoutEmploymentHistoryInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutPositionsInput
    employees?: EmployeeCreateNestedManyWithoutPositionInput
  }

  export type PositionUncheckedCreateWithoutEmploymentHistoryInput = {
    id?: string
    workspaceId: string
    name: string
    code?: string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutPositionInput
  }

  export type PositionCreateOrConnectWithoutEmploymentHistoryInput = {
    where: PositionWhereUniqueInput
    create: XOR<PositionCreateWithoutEmploymentHistoryInput, PositionUncheckedCreateWithoutEmploymentHistoryInput>
  }

  export type PositionLevelCreateWithoutEmploymentHistoryInput = {
    id?: string
    name: string
    level: number
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutPositionLevelsInput
    employees?: EmployeeCreateNestedManyWithoutPositionLevelInput
  }

  export type PositionLevelUncheckedCreateWithoutEmploymentHistoryInput = {
    id?: string
    workspaceId: string
    name: string
    level: number
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutPositionLevelInput
  }

  export type PositionLevelCreateOrConnectWithoutEmploymentHistoryInput = {
    where: PositionLevelWhereUniqueInput
    create: XOR<PositionLevelCreateWithoutEmploymentHistoryInput, PositionLevelUncheckedCreateWithoutEmploymentHistoryInput>
  }

  export type EmployeeUpsertWithoutEmploymentHistoryInput = {
    update: XOR<EmployeeUpdateWithoutEmploymentHistoryInput, EmployeeUncheckedUpdateWithoutEmploymentHistoryInput>
    create: XOR<EmployeeCreateWithoutEmploymentHistoryInput, EmployeeUncheckedCreateWithoutEmploymentHistoryInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutEmploymentHistoryInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutEmploymentHistoryInput, EmployeeUncheckedUpdateWithoutEmploymentHistoryInput>
  }

  export type EmployeeUpdateWithoutEmploymentHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeeNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    positionLevel?: PositionLevelUpdateOneWithoutEmployeesNestedInput
    manager?: EmployeeUpdateOneWithoutSubordinatesNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutEmploymentHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type PositionUpsertWithoutEmploymentHistoryInput = {
    update: XOR<PositionUpdateWithoutEmploymentHistoryInput, PositionUncheckedUpdateWithoutEmploymentHistoryInput>
    create: XOR<PositionCreateWithoutEmploymentHistoryInput, PositionUncheckedCreateWithoutEmploymentHistoryInput>
    where?: PositionWhereInput
  }

  export type PositionUpdateToOneWithWhereWithoutEmploymentHistoryInput = {
    where?: PositionWhereInput
    data: XOR<PositionUpdateWithoutEmploymentHistoryInput, PositionUncheckedUpdateWithoutEmploymentHistoryInput>
  }

  export type PositionUpdateWithoutEmploymentHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutPositionsNestedInput
    employees?: EmployeeUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateWithoutEmploymentHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionLevelUpsertWithoutEmploymentHistoryInput = {
    update: XOR<PositionLevelUpdateWithoutEmploymentHistoryInput, PositionLevelUncheckedUpdateWithoutEmploymentHistoryInput>
    create: XOR<PositionLevelCreateWithoutEmploymentHistoryInput, PositionLevelUncheckedCreateWithoutEmploymentHistoryInput>
    where?: PositionLevelWhereInput
  }

  export type PositionLevelUpdateToOneWithWhereWithoutEmploymentHistoryInput = {
    where?: PositionLevelWhereInput
    data: XOR<PositionLevelUpdateWithoutEmploymentHistoryInput, PositionLevelUncheckedUpdateWithoutEmploymentHistoryInput>
  }

  export type PositionLevelUpdateWithoutEmploymentHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutPositionLevelsNestedInput
    employees?: EmployeeUpdateManyWithoutPositionLevelNestedInput
  }

  export type PositionLevelUncheckedUpdateWithoutEmploymentHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutPositionLevelNestedInput
  }

  export type EmployeeCreateWithoutDocumentsInput = {
    id?: string
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeeInput
    workspace: WorkspaceCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    positionLevel?: PositionLevelCreateNestedOneWithoutEmployeesInput
    manager?: EmployeeCreateNestedOneWithoutSubordinatesInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDocumentsInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDocumentsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
  }

  export type EmployeeUpsertWithoutDocumentsInput = {
    update: XOR<EmployeeUpdateWithoutDocumentsInput, EmployeeUncheckedUpdateWithoutDocumentsInput>
    create: XOR<EmployeeCreateWithoutDocumentsInput, EmployeeUncheckedCreateWithoutDocumentsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutDocumentsInput, EmployeeUncheckedUpdateWithoutDocumentsInput>
  }

  export type EmployeeUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeeNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    positionLevel?: PositionLevelUpdateOneWithoutEmployeesNestedInput
    manager?: EmployeeUpdateOneWithoutSubordinatesNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type WorkspaceCreateWithoutProjectsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutProjectsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutProjectsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectMemberCreateWithoutProjectInput = {
    id?: string
    allocation?: number
    startDate?: Date | string
    endDate?: Date | string | null
    employee: EmployeeCreateNestedOneWithoutProjectMembersInput
    projectRole: ProjectRoleCreateNestedOneWithoutProjectMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutProjectInput = {
    id?: string
    employeeId: string
    roleId: string
    allocation?: number
    startDate?: Date | string
    endDate?: Date | string | null
  }

  export type ProjectMemberCreateOrConnectWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberCreateManyProjectInputEnvelope = {
    data: ProjectMemberCreateManyProjectInput | ProjectMemberCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutProjectsInput = {
    update: XOR<WorkspaceUpdateWithoutProjectsInput, WorkspaceUncheckedUpdateWithoutProjectsInput>
    create: XOR<WorkspaceCreateWithoutProjectsInput, WorkspaceUncheckedCreateWithoutProjectsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutProjectsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutProjectsInput, WorkspaceUncheckedUpdateWithoutProjectsInput>
  }

  export type WorkspaceUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMemberCreateWithoutProjectInput, ProjectMemberUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutProjectInput, ProjectMemberUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectCreateWithoutMembersInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.ProjectStatus
    priority?: $Enums.ProjectPriority
    managerId?: string | null
    clientName?: string | null
    clientContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutProjectsInput
  }

  export type ProjectUncheckedCreateWithoutMembersInput = {
    id?: string
    workspaceId: string
    name: string
    code?: string | null
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.ProjectStatus
    priority?: $Enums.ProjectPriority
    managerId?: string | null
    clientName?: string | null
    clientContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateOrConnectWithoutMembersInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
  }

  export type EmployeeCreateWithoutProjectMembersInput = {
    id?: string
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeeInput
    workspace: WorkspaceCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    positionLevel?: PositionLevelCreateNestedOneWithoutEmployeesInput
    manager?: EmployeeCreateNestedOneWithoutSubordinatesInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutProjectMembersInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutProjectMembersInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutProjectMembersInput, EmployeeUncheckedCreateWithoutProjectMembersInput>
  }

  export type ProjectRoleCreateWithoutProjectMembersInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace?: WorkspaceCreateNestedOneWithoutProjectRolesInput
  }

  export type ProjectRoleUncheckedCreateWithoutProjectMembersInput = {
    id?: string
    workspaceId?: string | null
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectRoleCreateOrConnectWithoutProjectMembersInput = {
    where: ProjectRoleWhereUniqueInput
    create: XOR<ProjectRoleCreateWithoutProjectMembersInput, ProjectRoleUncheckedCreateWithoutProjectMembersInput>
  }

  export type ProjectUpsertWithoutMembersInput = {
    update: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
    create: XOR<ProjectCreateWithoutMembersInput, ProjectUncheckedCreateWithoutMembersInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMembersInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMembersInput, ProjectUncheckedUpdateWithoutMembersInput>
  }

  export type ProjectUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumProjectPriorityFieldUpdateOperationsInput | $Enums.ProjectPriority
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    clientContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumProjectPriorityFieldUpdateOperationsInput | $Enums.ProjectPriority
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    clientContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpsertWithoutProjectMembersInput = {
    update: XOR<EmployeeUpdateWithoutProjectMembersInput, EmployeeUncheckedUpdateWithoutProjectMembersInput>
    create: XOR<EmployeeCreateWithoutProjectMembersInput, EmployeeUncheckedCreateWithoutProjectMembersInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutProjectMembersInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutProjectMembersInput, EmployeeUncheckedUpdateWithoutProjectMembersInput>
  }

  export type EmployeeUpdateWithoutProjectMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeeNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    positionLevel?: PositionLevelUpdateOneWithoutEmployeesNestedInput
    manager?: EmployeeUpdateOneWithoutSubordinatesNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutProjectMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ProjectRoleUpsertWithoutProjectMembersInput = {
    update: XOR<ProjectRoleUpdateWithoutProjectMembersInput, ProjectRoleUncheckedUpdateWithoutProjectMembersInput>
    create: XOR<ProjectRoleCreateWithoutProjectMembersInput, ProjectRoleUncheckedCreateWithoutProjectMembersInput>
    where?: ProjectRoleWhereInput
  }

  export type ProjectRoleUpdateToOneWithWhereWithoutProjectMembersInput = {
    where?: ProjectRoleWhereInput
    data: XOR<ProjectRoleUpdateWithoutProjectMembersInput, ProjectRoleUncheckedUpdateWithoutProjectMembersInput>
  }

  export type ProjectRoleUpdateWithoutProjectMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneWithoutProjectRolesNestedInput
  }

  export type ProjectRoleUncheckedUpdateWithoutProjectMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceCreateWithoutProjectRolesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutProjectRolesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutProjectRolesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutProjectRolesInput, WorkspaceUncheckedCreateWithoutProjectRolesInput>
  }

  export type ProjectMemberCreateWithoutProjectRoleInput = {
    id?: string
    allocation?: number
    startDate?: Date | string
    endDate?: Date | string | null
    project: ProjectCreateNestedOneWithoutMembersInput
    employee: EmployeeCreateNestedOneWithoutProjectMembersInput
  }

  export type ProjectMemberUncheckedCreateWithoutProjectRoleInput = {
    id?: string
    projectId: string
    employeeId: string
    allocation?: number
    startDate?: Date | string
    endDate?: Date | string | null
  }

  export type ProjectMemberCreateOrConnectWithoutProjectRoleInput = {
    where: ProjectMemberWhereUniqueInput
    create: XOR<ProjectMemberCreateWithoutProjectRoleInput, ProjectMemberUncheckedCreateWithoutProjectRoleInput>
  }

  export type ProjectMemberCreateManyProjectRoleInputEnvelope = {
    data: ProjectMemberCreateManyProjectRoleInput | ProjectMemberCreateManyProjectRoleInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutProjectRolesInput = {
    update: XOR<WorkspaceUpdateWithoutProjectRolesInput, WorkspaceUncheckedUpdateWithoutProjectRolesInput>
    create: XOR<WorkspaceCreateWithoutProjectRolesInput, WorkspaceUncheckedCreateWithoutProjectRolesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutProjectRolesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutProjectRolesInput, WorkspaceUncheckedUpdateWithoutProjectRolesInput>
  }

  export type WorkspaceUpdateWithoutProjectRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutProjectRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type ProjectMemberUpsertWithWhereUniqueWithoutProjectRoleInput = {
    where: ProjectMemberWhereUniqueInput
    update: XOR<ProjectMemberUpdateWithoutProjectRoleInput, ProjectMemberUncheckedUpdateWithoutProjectRoleInput>
    create: XOR<ProjectMemberCreateWithoutProjectRoleInput, ProjectMemberUncheckedCreateWithoutProjectRoleInput>
  }

  export type ProjectMemberUpdateWithWhereUniqueWithoutProjectRoleInput = {
    where: ProjectMemberWhereUniqueInput
    data: XOR<ProjectMemberUpdateWithoutProjectRoleInput, ProjectMemberUncheckedUpdateWithoutProjectRoleInput>
  }

  export type ProjectMemberUpdateManyWithWhereWithoutProjectRoleInput = {
    where: ProjectMemberScalarWhereInput
    data: XOR<ProjectMemberUpdateManyMutationInput, ProjectMemberUncheckedUpdateManyWithoutProjectRoleInput>
  }

  export type WorkspaceCreateWithoutLeaveTypesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutLeaveTypesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutLeaveTypesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutLeaveTypesInput, WorkspaceUncheckedCreateWithoutLeaveTypesInput>
  }

  export type LeaveQuotaCreateWithoutLeaveTypeInput = {
    id?: string
    year: number
    total: number
    used?: number
    pending?: number
    remaining: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutLeaveQuotasInput
    employee: EmployeeCreateNestedOneWithoutLeaveQuotasInput
  }

  export type LeaveQuotaUncheckedCreateWithoutLeaveTypeInput = {
    id?: string
    workspaceId: string
    employeeId: string
    year: number
    total: number
    used?: number
    pending?: number
    remaining: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveQuotaCreateOrConnectWithoutLeaveTypeInput = {
    where: LeaveQuotaWhereUniqueInput
    create: XOR<LeaveQuotaCreateWithoutLeaveTypeInput, LeaveQuotaUncheckedCreateWithoutLeaveTypeInput>
  }

  export type LeaveQuotaCreateManyLeaveTypeInputEnvelope = {
    data: LeaveQuotaCreateManyLeaveTypeInput | LeaveQuotaCreateManyLeaveTypeInput[]
    skipDuplicates?: boolean
  }

  export type LeaveCreateWithoutLeaveTypeInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    halfDay?: boolean
    duration: number
    reason?: string | null
    attachment?: string | null
    status?: $Enums.LeaveStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutLeavesInput
    employee: EmployeeCreateNestedOneWithoutLeavesInput
    approval?: ApprovalCreateNestedOneWithoutLeaveInput
  }

  export type LeaveUncheckedCreateWithoutLeaveTypeInput = {
    id?: string
    workspaceId: string
    employeeId: string
    startDate: Date | string
    endDate: Date | string
    halfDay?: boolean
    duration: number
    reason?: string | null
    attachment?: string | null
    status?: $Enums.LeaveStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approval?: ApprovalUncheckedCreateNestedOneWithoutLeaveInput
  }

  export type LeaveCreateOrConnectWithoutLeaveTypeInput = {
    where: LeaveWhereUniqueInput
    create: XOR<LeaveCreateWithoutLeaveTypeInput, LeaveUncheckedCreateWithoutLeaveTypeInput>
  }

  export type LeaveCreateManyLeaveTypeInputEnvelope = {
    data: LeaveCreateManyLeaveTypeInput | LeaveCreateManyLeaveTypeInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutLeaveTypesInput = {
    update: XOR<WorkspaceUpdateWithoutLeaveTypesInput, WorkspaceUncheckedUpdateWithoutLeaveTypesInput>
    create: XOR<WorkspaceCreateWithoutLeaveTypesInput, WorkspaceUncheckedCreateWithoutLeaveTypesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutLeaveTypesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutLeaveTypesInput, WorkspaceUncheckedUpdateWithoutLeaveTypesInput>
  }

  export type WorkspaceUpdateWithoutLeaveTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutLeaveTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type LeaveQuotaUpsertWithWhereUniqueWithoutLeaveTypeInput = {
    where: LeaveQuotaWhereUniqueInput
    update: XOR<LeaveQuotaUpdateWithoutLeaveTypeInput, LeaveQuotaUncheckedUpdateWithoutLeaveTypeInput>
    create: XOR<LeaveQuotaCreateWithoutLeaveTypeInput, LeaveQuotaUncheckedCreateWithoutLeaveTypeInput>
  }

  export type LeaveQuotaUpdateWithWhereUniqueWithoutLeaveTypeInput = {
    where: LeaveQuotaWhereUniqueInput
    data: XOR<LeaveQuotaUpdateWithoutLeaveTypeInput, LeaveQuotaUncheckedUpdateWithoutLeaveTypeInput>
  }

  export type LeaveQuotaUpdateManyWithWhereWithoutLeaveTypeInput = {
    where: LeaveQuotaScalarWhereInput
    data: XOR<LeaveQuotaUpdateManyMutationInput, LeaveQuotaUncheckedUpdateManyWithoutLeaveTypeInput>
  }

  export type LeaveUpsertWithWhereUniqueWithoutLeaveTypeInput = {
    where: LeaveWhereUniqueInput
    update: XOR<LeaveUpdateWithoutLeaveTypeInput, LeaveUncheckedUpdateWithoutLeaveTypeInput>
    create: XOR<LeaveCreateWithoutLeaveTypeInput, LeaveUncheckedCreateWithoutLeaveTypeInput>
  }

  export type LeaveUpdateWithWhereUniqueWithoutLeaveTypeInput = {
    where: LeaveWhereUniqueInput
    data: XOR<LeaveUpdateWithoutLeaveTypeInput, LeaveUncheckedUpdateWithoutLeaveTypeInput>
  }

  export type LeaveUpdateManyWithWhereWithoutLeaveTypeInput = {
    where: LeaveScalarWhereInput
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyWithoutLeaveTypeInput>
  }

  export type WorkspaceCreateWithoutLeaveQuotasInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutLeaveQuotasInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutLeaveQuotasInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutLeaveQuotasInput, WorkspaceUncheckedCreateWithoutLeaveQuotasInput>
  }

  export type EmployeeCreateWithoutLeaveQuotasInput = {
    id?: string
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeeInput
    workspace: WorkspaceCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    positionLevel?: PositionLevelCreateNestedOneWithoutEmployeesInput
    manager?: EmployeeCreateNestedOneWithoutSubordinatesInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLeaveQuotasInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLeaveQuotasInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLeaveQuotasInput, EmployeeUncheckedCreateWithoutLeaveQuotasInput>
  }

  export type LeaveTypeCreateWithoutLeaveQuotasInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    color?: string | null
    isPaid?: boolean
    requiresApproval?: boolean
    requiresAttachment?: boolean
    maxDaysPerYear?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutLeaveTypesInput
    leaves?: LeaveCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeUncheckedCreateWithoutLeaveQuotasInput = {
    id?: string
    workspaceId: string
    name: string
    code: string
    description?: string | null
    color?: string | null
    isPaid?: boolean
    requiresApproval?: boolean
    requiresAttachment?: boolean
    maxDaysPerYear?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    leaves?: LeaveUncheckedCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeCreateOrConnectWithoutLeaveQuotasInput = {
    where: LeaveTypeWhereUniqueInput
    create: XOR<LeaveTypeCreateWithoutLeaveQuotasInput, LeaveTypeUncheckedCreateWithoutLeaveQuotasInput>
  }

  export type WorkspaceUpsertWithoutLeaveQuotasInput = {
    update: XOR<WorkspaceUpdateWithoutLeaveQuotasInput, WorkspaceUncheckedUpdateWithoutLeaveQuotasInput>
    create: XOR<WorkspaceCreateWithoutLeaveQuotasInput, WorkspaceUncheckedCreateWithoutLeaveQuotasInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutLeaveQuotasInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutLeaveQuotasInput, WorkspaceUncheckedUpdateWithoutLeaveQuotasInput>
  }

  export type WorkspaceUpdateWithoutLeaveQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutLeaveQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type EmployeeUpsertWithoutLeaveQuotasInput = {
    update: XOR<EmployeeUpdateWithoutLeaveQuotasInput, EmployeeUncheckedUpdateWithoutLeaveQuotasInput>
    create: XOR<EmployeeCreateWithoutLeaveQuotasInput, EmployeeUncheckedCreateWithoutLeaveQuotasInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLeaveQuotasInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLeaveQuotasInput, EmployeeUncheckedUpdateWithoutLeaveQuotasInput>
  }

  export type EmployeeUpdateWithoutLeaveQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeeNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    positionLevel?: PositionLevelUpdateOneWithoutEmployeesNestedInput
    manager?: EmployeeUpdateOneWithoutSubordinatesNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLeaveQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type LeaveTypeUpsertWithoutLeaveQuotasInput = {
    update: XOR<LeaveTypeUpdateWithoutLeaveQuotasInput, LeaveTypeUncheckedUpdateWithoutLeaveQuotasInput>
    create: XOR<LeaveTypeCreateWithoutLeaveQuotasInput, LeaveTypeUncheckedCreateWithoutLeaveQuotasInput>
    where?: LeaveTypeWhereInput
  }

  export type LeaveTypeUpdateToOneWithWhereWithoutLeaveQuotasInput = {
    where?: LeaveTypeWhereInput
    data: XOR<LeaveTypeUpdateWithoutLeaveQuotasInput, LeaveTypeUncheckedUpdateWithoutLeaveQuotasInput>
  }

  export type LeaveTypeUpdateWithoutLeaveQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    requiresAttachment?: BoolFieldUpdateOperationsInput | boolean
    maxDaysPerYear?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutLeaveTypesNestedInput
    leaves?: LeaveUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeUncheckedUpdateWithoutLeaveQuotasInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    requiresAttachment?: BoolFieldUpdateOperationsInput | boolean
    maxDaysPerYear?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaves?: LeaveUncheckedUpdateManyWithoutLeaveTypeNestedInput
  }

  export type WorkspaceCreateWithoutLeavesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutLeavesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutLeavesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutLeavesInput, WorkspaceUncheckedCreateWithoutLeavesInput>
  }

  export type EmployeeCreateWithoutLeavesInput = {
    id?: string
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeeInput
    workspace: WorkspaceCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    positionLevel?: PositionLevelCreateNestedOneWithoutEmployeesInput
    manager?: EmployeeCreateNestedOneWithoutSubordinatesInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLeavesInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutEmployeeInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLeavesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
  }

  export type LeaveTypeCreateWithoutLeavesInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    color?: string | null
    isPaid?: boolean
    requiresApproval?: boolean
    requiresAttachment?: boolean
    maxDaysPerYear?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutLeaveTypesInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeUncheckedCreateWithoutLeavesInput = {
    id?: string
    workspaceId: string
    name: string
    code: string
    description?: string | null
    color?: string | null
    isPaid?: boolean
    requiresApproval?: boolean
    requiresAttachment?: boolean
    maxDaysPerYear?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutLeaveTypeInput
  }

  export type LeaveTypeCreateOrConnectWithoutLeavesInput = {
    where: LeaveTypeWhereUniqueInput
    create: XOR<LeaveTypeCreateWithoutLeavesInput, LeaveTypeUncheckedCreateWithoutLeavesInput>
  }

  export type ApprovalCreateWithoutLeaveInput = {
    id?: string
    entityType: string
    entityId: string
    requesterId: string
    currentStep?: number
    status?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutApprovalsInput
    template: ApprovalTemplateCreateNestedOneWithoutApprovalsInput
    overtime?: OvertimeCreateNestedOneWithoutApprovalInput
    actions?: ApprovalActionCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalUncheckedCreateWithoutLeaveInput = {
    id?: string
    workspaceId: string
    templateId: string
    entityType: string
    entityId: string
    requesterId: string
    currentStep?: number
    status?: $Enums.ApprovalStatus
    overtimeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: ApprovalActionUncheckedCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalCreateOrConnectWithoutLeaveInput = {
    where: ApprovalWhereUniqueInput
    create: XOR<ApprovalCreateWithoutLeaveInput, ApprovalUncheckedCreateWithoutLeaveInput>
  }

  export type WorkspaceUpsertWithoutLeavesInput = {
    update: XOR<WorkspaceUpdateWithoutLeavesInput, WorkspaceUncheckedUpdateWithoutLeavesInput>
    create: XOR<WorkspaceCreateWithoutLeavesInput, WorkspaceUncheckedCreateWithoutLeavesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutLeavesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutLeavesInput, WorkspaceUncheckedUpdateWithoutLeavesInput>
  }

  export type WorkspaceUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type EmployeeUpsertWithoutLeavesInput = {
    update: XOR<EmployeeUpdateWithoutLeavesInput, EmployeeUncheckedUpdateWithoutLeavesInput>
    create: XOR<EmployeeCreateWithoutLeavesInput, EmployeeUncheckedCreateWithoutLeavesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLeavesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLeavesInput, EmployeeUncheckedUpdateWithoutLeavesInput>
  }

  export type EmployeeUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeeNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    positionLevel?: PositionLevelUpdateOneWithoutEmployeesNestedInput
    manager?: EmployeeUpdateOneWithoutSubordinatesNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type LeaveTypeUpsertWithoutLeavesInput = {
    update: XOR<LeaveTypeUpdateWithoutLeavesInput, LeaveTypeUncheckedUpdateWithoutLeavesInput>
    create: XOR<LeaveTypeCreateWithoutLeavesInput, LeaveTypeUncheckedCreateWithoutLeavesInput>
    where?: LeaveTypeWhereInput
  }

  export type LeaveTypeUpdateToOneWithWhereWithoutLeavesInput = {
    where?: LeaveTypeWhereInput
    data: XOR<LeaveTypeUpdateWithoutLeavesInput, LeaveTypeUncheckedUpdateWithoutLeavesInput>
  }

  export type LeaveTypeUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    requiresAttachment?: BoolFieldUpdateOperationsInput | boolean
    maxDaysPerYear?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutLeaveTypesNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeUncheckedUpdateWithoutLeavesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    requiresAttachment?: BoolFieldUpdateOperationsInput | boolean
    maxDaysPerYear?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutLeaveTypeNestedInput
  }

  export type ApprovalUpsertWithoutLeaveInput = {
    update: XOR<ApprovalUpdateWithoutLeaveInput, ApprovalUncheckedUpdateWithoutLeaveInput>
    create: XOR<ApprovalCreateWithoutLeaveInput, ApprovalUncheckedCreateWithoutLeaveInput>
    where?: ApprovalWhereInput
  }

  export type ApprovalUpdateToOneWithWhereWithoutLeaveInput = {
    where?: ApprovalWhereInput
    data: XOR<ApprovalUpdateWithoutLeaveInput, ApprovalUncheckedUpdateWithoutLeaveInput>
  }

  export type ApprovalUpdateWithoutLeaveInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutApprovalsNestedInput
    template?: ApprovalTemplateUpdateOneRequiredWithoutApprovalsNestedInput
    overtime?: OvertimeUpdateOneWithoutApprovalNestedInput
    actions?: ApprovalActionUpdateManyWithoutApprovalNestedInput
  }

  export type ApprovalUncheckedUpdateWithoutLeaveInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    overtimeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: ApprovalActionUncheckedUpdateManyWithoutApprovalNestedInput
  }

  export type WorkspaceCreateWithoutOvertimePoliciesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutOvertimePoliciesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutOvertimePoliciesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutOvertimePoliciesInput, WorkspaceUncheckedCreateWithoutOvertimePoliciesInput>
  }

  export type OvertimeCreateWithoutOvertimePolicyInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    hours: number
    reason: string
    status?: $Enums.OvertimeStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutOvertimesInput
    employee: EmployeeCreateNestedOneWithoutOvertimesInput
    approval?: ApprovalCreateNestedOneWithoutOvertimeInput
  }

  export type OvertimeUncheckedCreateWithoutOvertimePolicyInput = {
    id?: string
    workspaceId: string
    employeeId: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    hours: number
    reason: string
    status?: $Enums.OvertimeStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approval?: ApprovalUncheckedCreateNestedOneWithoutOvertimeInput
  }

  export type OvertimeCreateOrConnectWithoutOvertimePolicyInput = {
    where: OvertimeWhereUniqueInput
    create: XOR<OvertimeCreateWithoutOvertimePolicyInput, OvertimeUncheckedCreateWithoutOvertimePolicyInput>
  }

  export type OvertimeCreateManyOvertimePolicyInputEnvelope = {
    data: OvertimeCreateManyOvertimePolicyInput | OvertimeCreateManyOvertimePolicyInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutOvertimePoliciesInput = {
    update: XOR<WorkspaceUpdateWithoutOvertimePoliciesInput, WorkspaceUncheckedUpdateWithoutOvertimePoliciesInput>
    create: XOR<WorkspaceCreateWithoutOvertimePoliciesInput, WorkspaceUncheckedCreateWithoutOvertimePoliciesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutOvertimePoliciesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutOvertimePoliciesInput, WorkspaceUncheckedUpdateWithoutOvertimePoliciesInput>
  }

  export type WorkspaceUpdateWithoutOvertimePoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutOvertimePoliciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type OvertimeUpsertWithWhereUniqueWithoutOvertimePolicyInput = {
    where: OvertimeWhereUniqueInput
    update: XOR<OvertimeUpdateWithoutOvertimePolicyInput, OvertimeUncheckedUpdateWithoutOvertimePolicyInput>
    create: XOR<OvertimeCreateWithoutOvertimePolicyInput, OvertimeUncheckedCreateWithoutOvertimePolicyInput>
  }

  export type OvertimeUpdateWithWhereUniqueWithoutOvertimePolicyInput = {
    where: OvertimeWhereUniqueInput
    data: XOR<OvertimeUpdateWithoutOvertimePolicyInput, OvertimeUncheckedUpdateWithoutOvertimePolicyInput>
  }

  export type OvertimeUpdateManyWithWhereWithoutOvertimePolicyInput = {
    where: OvertimeScalarWhereInput
    data: XOR<OvertimeUpdateManyMutationInput, OvertimeUncheckedUpdateManyWithoutOvertimePolicyInput>
  }

  export type WorkspaceCreateWithoutOvertimesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutOvertimesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutOvertimesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutOvertimesInput, WorkspaceUncheckedCreateWithoutOvertimesInput>
  }

  export type EmployeeCreateWithoutOvertimesInput = {
    id?: string
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutEmployeeInput
    workspace: WorkspaceCreateNestedOneWithoutEmployeesInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    team?: TeamCreateNestedOneWithoutEmployeesInput
    position?: PositionCreateNestedOneWithoutEmployeesInput
    positionLevel?: PositionLevelCreateNestedOneWithoutEmployeesInput
    manager?: EmployeeCreateNestedOneWithoutSubordinatesInput
    subordinates?: EmployeeCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutOvertimesInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
    subordinates?: EmployeeUncheckedCreateNestedManyWithoutManagerInput
    projectMembers?: ProjectMemberUncheckedCreateNestedManyWithoutEmployeeInput
    employmentHistory?: EmploymentHistoryUncheckedCreateNestedManyWithoutEmployeeInput
    documents?: EmployeeDocumentUncheckedCreateNestedManyWithoutEmployeeInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutEmployeeInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutOvertimesInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutOvertimesInput, EmployeeUncheckedCreateWithoutOvertimesInput>
  }

  export type OvertimePolicyCreateWithoutOvertimesInput = {
    id?: string
    name: string
    description?: string | null
    rate: number
    minimumHours?: number
    maximumHours?: number | null
    requiresApproval?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutOvertimePoliciesInput
  }

  export type OvertimePolicyUncheckedCreateWithoutOvertimesInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    rate: number
    minimumHours?: number
    maximumHours?: number | null
    requiresApproval?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimePolicyCreateOrConnectWithoutOvertimesInput = {
    where: OvertimePolicyWhereUniqueInput
    create: XOR<OvertimePolicyCreateWithoutOvertimesInput, OvertimePolicyUncheckedCreateWithoutOvertimesInput>
  }

  export type ApprovalCreateWithoutOvertimeInput = {
    id?: string
    entityType: string
    entityId: string
    requesterId: string
    currentStep?: number
    status?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutApprovalsInput
    template: ApprovalTemplateCreateNestedOneWithoutApprovalsInput
    leave?: LeaveCreateNestedOneWithoutApprovalInput
    actions?: ApprovalActionCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalUncheckedCreateWithoutOvertimeInput = {
    id?: string
    workspaceId: string
    templateId: string
    entityType: string
    entityId: string
    requesterId: string
    currentStep?: number
    status?: $Enums.ApprovalStatus
    leaveId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: ApprovalActionUncheckedCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalCreateOrConnectWithoutOvertimeInput = {
    where: ApprovalWhereUniqueInput
    create: XOR<ApprovalCreateWithoutOvertimeInput, ApprovalUncheckedCreateWithoutOvertimeInput>
  }

  export type WorkspaceUpsertWithoutOvertimesInput = {
    update: XOR<WorkspaceUpdateWithoutOvertimesInput, WorkspaceUncheckedUpdateWithoutOvertimesInput>
    create: XOR<WorkspaceCreateWithoutOvertimesInput, WorkspaceUncheckedCreateWithoutOvertimesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutOvertimesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutOvertimesInput, WorkspaceUncheckedUpdateWithoutOvertimesInput>
  }

  export type WorkspaceUpdateWithoutOvertimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutOvertimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type EmployeeUpsertWithoutOvertimesInput = {
    update: XOR<EmployeeUpdateWithoutOvertimesInput, EmployeeUncheckedUpdateWithoutOvertimesInput>
    create: XOR<EmployeeCreateWithoutOvertimesInput, EmployeeUncheckedCreateWithoutOvertimesInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutOvertimesInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutOvertimesInput, EmployeeUncheckedUpdateWithoutOvertimesInput>
  }

  export type EmployeeUpdateWithoutOvertimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeeNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    positionLevel?: PositionLevelUpdateOneWithoutEmployeesNestedInput
    manager?: EmployeeUpdateOneWithoutSubordinatesNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutOvertimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type OvertimePolicyUpsertWithoutOvertimesInput = {
    update: XOR<OvertimePolicyUpdateWithoutOvertimesInput, OvertimePolicyUncheckedUpdateWithoutOvertimesInput>
    create: XOR<OvertimePolicyCreateWithoutOvertimesInput, OvertimePolicyUncheckedCreateWithoutOvertimesInput>
    where?: OvertimePolicyWhereInput
  }

  export type OvertimePolicyUpdateToOneWithWhereWithoutOvertimesInput = {
    where?: OvertimePolicyWhereInput
    data: XOR<OvertimePolicyUpdateWithoutOvertimesInput, OvertimePolicyUncheckedUpdateWithoutOvertimesInput>
  }

  export type OvertimePolicyUpdateWithoutOvertimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    minimumHours?: FloatFieldUpdateOperationsInput | number
    maximumHours?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutOvertimePoliciesNestedInput
  }

  export type OvertimePolicyUncheckedUpdateWithoutOvertimesInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    minimumHours?: FloatFieldUpdateOperationsInput | number
    maximumHours?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUpsertWithoutOvertimeInput = {
    update: XOR<ApprovalUpdateWithoutOvertimeInput, ApprovalUncheckedUpdateWithoutOvertimeInput>
    create: XOR<ApprovalCreateWithoutOvertimeInput, ApprovalUncheckedCreateWithoutOvertimeInput>
    where?: ApprovalWhereInput
  }

  export type ApprovalUpdateToOneWithWhereWithoutOvertimeInput = {
    where?: ApprovalWhereInput
    data: XOR<ApprovalUpdateWithoutOvertimeInput, ApprovalUncheckedUpdateWithoutOvertimeInput>
  }

  export type ApprovalUpdateWithoutOvertimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutApprovalsNestedInput
    template?: ApprovalTemplateUpdateOneRequiredWithoutApprovalsNestedInput
    leave?: LeaveUpdateOneWithoutApprovalNestedInput
    actions?: ApprovalActionUpdateManyWithoutApprovalNestedInput
  }

  export type ApprovalUncheckedUpdateWithoutOvertimeInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    leaveId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: ApprovalActionUncheckedUpdateManyWithoutApprovalNestedInput
  }

  export type WorkspaceCreateWithoutApprovalTemplatesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutApprovalTemplatesInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutApprovalTemplatesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutApprovalTemplatesInput, WorkspaceUncheckedCreateWithoutApprovalTemplatesInput>
  }

  export type ApprovalStepCreateWithoutApprovalTemplateInput = {
    id?: string
    stepNumber: number
    approverType: $Enums.ApproverType
    approverId?: string | null
    backup1Id?: string | null
    backup2Id?: string | null
    timeLimit?: number | null
  }

  export type ApprovalStepUncheckedCreateWithoutApprovalTemplateInput = {
    id?: string
    stepNumber: number
    approverType: $Enums.ApproverType
    approverId?: string | null
    backup1Id?: string | null
    backup2Id?: string | null
    timeLimit?: number | null
  }

  export type ApprovalStepCreateOrConnectWithoutApprovalTemplateInput = {
    where: ApprovalStepWhereUniqueInput
    create: XOR<ApprovalStepCreateWithoutApprovalTemplateInput, ApprovalStepUncheckedCreateWithoutApprovalTemplateInput>
  }

  export type ApprovalStepCreateManyApprovalTemplateInputEnvelope = {
    data: ApprovalStepCreateManyApprovalTemplateInput | ApprovalStepCreateManyApprovalTemplateInput[]
    skipDuplicates?: boolean
  }

  export type ApprovalCreateWithoutTemplateInput = {
    id?: string
    entityType: string
    entityId: string
    requesterId: string
    currentStep?: number
    status?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutApprovalsInput
    leave?: LeaveCreateNestedOneWithoutApprovalInput
    overtime?: OvertimeCreateNestedOneWithoutApprovalInput
    actions?: ApprovalActionCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalUncheckedCreateWithoutTemplateInput = {
    id?: string
    workspaceId: string
    entityType: string
    entityId: string
    requesterId: string
    currentStep?: number
    status?: $Enums.ApprovalStatus
    leaveId?: string | null
    overtimeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: ApprovalActionUncheckedCreateNestedManyWithoutApprovalInput
  }

  export type ApprovalCreateOrConnectWithoutTemplateInput = {
    where: ApprovalWhereUniqueInput
    create: XOR<ApprovalCreateWithoutTemplateInput, ApprovalUncheckedCreateWithoutTemplateInput>
  }

  export type ApprovalCreateManyTemplateInputEnvelope = {
    data: ApprovalCreateManyTemplateInput | ApprovalCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutApprovalTemplatesInput = {
    update: XOR<WorkspaceUpdateWithoutApprovalTemplatesInput, WorkspaceUncheckedUpdateWithoutApprovalTemplatesInput>
    create: XOR<WorkspaceCreateWithoutApprovalTemplatesInput, WorkspaceUncheckedCreateWithoutApprovalTemplatesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutApprovalTemplatesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutApprovalTemplatesInput, WorkspaceUncheckedUpdateWithoutApprovalTemplatesInput>
  }

  export type WorkspaceUpdateWithoutApprovalTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutApprovalTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type ApprovalStepUpsertWithWhereUniqueWithoutApprovalTemplateInput = {
    where: ApprovalStepWhereUniqueInput
    update: XOR<ApprovalStepUpdateWithoutApprovalTemplateInput, ApprovalStepUncheckedUpdateWithoutApprovalTemplateInput>
    create: XOR<ApprovalStepCreateWithoutApprovalTemplateInput, ApprovalStepUncheckedCreateWithoutApprovalTemplateInput>
  }

  export type ApprovalStepUpdateWithWhereUniqueWithoutApprovalTemplateInput = {
    where: ApprovalStepWhereUniqueInput
    data: XOR<ApprovalStepUpdateWithoutApprovalTemplateInput, ApprovalStepUncheckedUpdateWithoutApprovalTemplateInput>
  }

  export type ApprovalStepUpdateManyWithWhereWithoutApprovalTemplateInput = {
    where: ApprovalStepScalarWhereInput
    data: XOR<ApprovalStepUpdateManyMutationInput, ApprovalStepUncheckedUpdateManyWithoutApprovalTemplateInput>
  }

  export type ApprovalStepScalarWhereInput = {
    AND?: ApprovalStepScalarWhereInput | ApprovalStepScalarWhereInput[]
    OR?: ApprovalStepScalarWhereInput[]
    NOT?: ApprovalStepScalarWhereInput | ApprovalStepScalarWhereInput[]
    id?: StringFilter<"ApprovalStep"> | string
    approvalTemplateId?: StringFilter<"ApprovalStep"> | string
    stepNumber?: IntFilter<"ApprovalStep"> | number
    approverType?: EnumApproverTypeFilter<"ApprovalStep"> | $Enums.ApproverType
    approverId?: StringNullableFilter<"ApprovalStep"> | string | null
    backup1Id?: StringNullableFilter<"ApprovalStep"> | string | null
    backup2Id?: StringNullableFilter<"ApprovalStep"> | string | null
    timeLimit?: IntNullableFilter<"ApprovalStep"> | number | null
  }

  export type ApprovalUpsertWithWhereUniqueWithoutTemplateInput = {
    where: ApprovalWhereUniqueInput
    update: XOR<ApprovalUpdateWithoutTemplateInput, ApprovalUncheckedUpdateWithoutTemplateInput>
    create: XOR<ApprovalCreateWithoutTemplateInput, ApprovalUncheckedCreateWithoutTemplateInput>
  }

  export type ApprovalUpdateWithWhereUniqueWithoutTemplateInput = {
    where: ApprovalWhereUniqueInput
    data: XOR<ApprovalUpdateWithoutTemplateInput, ApprovalUncheckedUpdateWithoutTemplateInput>
  }

  export type ApprovalUpdateManyWithWhereWithoutTemplateInput = {
    where: ApprovalScalarWhereInput
    data: XOR<ApprovalUpdateManyMutationInput, ApprovalUncheckedUpdateManyWithoutTemplateInput>
  }

  export type ApprovalTemplateCreateWithoutStepsInput = {
    id?: string
    name: string
    description?: string | null
    entityType: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutApprovalTemplatesInput
    approvals?: ApprovalCreateNestedManyWithoutTemplateInput
  }

  export type ApprovalTemplateUncheckedCreateWithoutStepsInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    entityType: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    approvals?: ApprovalUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type ApprovalTemplateCreateOrConnectWithoutStepsInput = {
    where: ApprovalTemplateWhereUniqueInput
    create: XOR<ApprovalTemplateCreateWithoutStepsInput, ApprovalTemplateUncheckedCreateWithoutStepsInput>
  }

  export type ApprovalTemplateUpsertWithoutStepsInput = {
    update: XOR<ApprovalTemplateUpdateWithoutStepsInput, ApprovalTemplateUncheckedUpdateWithoutStepsInput>
    create: XOR<ApprovalTemplateCreateWithoutStepsInput, ApprovalTemplateUncheckedCreateWithoutStepsInput>
    where?: ApprovalTemplateWhereInput
  }

  export type ApprovalTemplateUpdateToOneWithWhereWithoutStepsInput = {
    where?: ApprovalTemplateWhereInput
    data: XOR<ApprovalTemplateUpdateWithoutStepsInput, ApprovalTemplateUncheckedUpdateWithoutStepsInput>
  }

  export type ApprovalTemplateUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutApprovalTemplatesNestedInput
    approvals?: ApprovalUpdateManyWithoutTemplateNestedInput
  }

  export type ApprovalTemplateUncheckedUpdateWithoutStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approvals?: ApprovalUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type WorkspaceCreateWithoutApprovalsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutApprovalsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutApprovalsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutApprovalsInput, WorkspaceUncheckedCreateWithoutApprovalsInput>
  }

  export type ApprovalTemplateCreateWithoutApprovalsInput = {
    id?: string
    name: string
    description?: string | null
    entityType: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutApprovalTemplatesInput
    steps?: ApprovalStepCreateNestedManyWithoutApprovalTemplateInput
  }

  export type ApprovalTemplateUncheckedCreateWithoutApprovalsInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    entityType: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    steps?: ApprovalStepUncheckedCreateNestedManyWithoutApprovalTemplateInput
  }

  export type ApprovalTemplateCreateOrConnectWithoutApprovalsInput = {
    where: ApprovalTemplateWhereUniqueInput
    create: XOR<ApprovalTemplateCreateWithoutApprovalsInput, ApprovalTemplateUncheckedCreateWithoutApprovalsInput>
  }

  export type LeaveCreateWithoutApprovalInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    halfDay?: boolean
    duration: number
    reason?: string | null
    attachment?: string | null
    status?: $Enums.LeaveStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutLeavesInput
    employee: EmployeeCreateNestedOneWithoutLeavesInput
    leaveType: LeaveTypeCreateNestedOneWithoutLeavesInput
  }

  export type LeaveUncheckedCreateWithoutApprovalInput = {
    id?: string
    workspaceId: string
    employeeId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    halfDay?: boolean
    duration: number
    reason?: string | null
    attachment?: string | null
    status?: $Enums.LeaveStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveCreateOrConnectWithoutApprovalInput = {
    where: LeaveWhereUniqueInput
    create: XOR<LeaveCreateWithoutApprovalInput, LeaveUncheckedCreateWithoutApprovalInput>
  }

  export type OvertimeCreateWithoutApprovalInput = {
    id?: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    hours: number
    reason: string
    status?: $Enums.OvertimeStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutOvertimesInput
    employee: EmployeeCreateNestedOneWithoutOvertimesInput
    overtimePolicy: OvertimePolicyCreateNestedOneWithoutOvertimesInput
  }

  export type OvertimeUncheckedCreateWithoutApprovalInput = {
    id?: string
    workspaceId: string
    employeeId: string
    policyId: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    hours: number
    reason: string
    status?: $Enums.OvertimeStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeCreateOrConnectWithoutApprovalInput = {
    where: OvertimeWhereUniqueInput
    create: XOR<OvertimeCreateWithoutApprovalInput, OvertimeUncheckedCreateWithoutApprovalInput>
  }

  export type ApprovalActionCreateWithoutApprovalInput = {
    id?: string
    step: number
    action: string
    comment?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutApprovalActionsInput
  }

  export type ApprovalActionUncheckedCreateWithoutApprovalInput = {
    id?: string
    userId: string
    step: number
    action: string
    comment?: string | null
    createdAt?: Date | string
  }

  export type ApprovalActionCreateOrConnectWithoutApprovalInput = {
    where: ApprovalActionWhereUniqueInput
    create: XOR<ApprovalActionCreateWithoutApprovalInput, ApprovalActionUncheckedCreateWithoutApprovalInput>
  }

  export type ApprovalActionCreateManyApprovalInputEnvelope = {
    data: ApprovalActionCreateManyApprovalInput | ApprovalActionCreateManyApprovalInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutApprovalsInput = {
    update: XOR<WorkspaceUpdateWithoutApprovalsInput, WorkspaceUncheckedUpdateWithoutApprovalsInput>
    create: XOR<WorkspaceCreateWithoutApprovalsInput, WorkspaceUncheckedCreateWithoutApprovalsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutApprovalsInput, WorkspaceUncheckedUpdateWithoutApprovalsInput>
  }

  export type WorkspaceUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type ApprovalTemplateUpsertWithoutApprovalsInput = {
    update: XOR<ApprovalTemplateUpdateWithoutApprovalsInput, ApprovalTemplateUncheckedUpdateWithoutApprovalsInput>
    create: XOR<ApprovalTemplateCreateWithoutApprovalsInput, ApprovalTemplateUncheckedCreateWithoutApprovalsInput>
    where?: ApprovalTemplateWhereInput
  }

  export type ApprovalTemplateUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: ApprovalTemplateWhereInput
    data: XOR<ApprovalTemplateUpdateWithoutApprovalsInput, ApprovalTemplateUncheckedUpdateWithoutApprovalsInput>
  }

  export type ApprovalTemplateUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutApprovalTemplatesNestedInput
    steps?: ApprovalStepUpdateManyWithoutApprovalTemplateNestedInput
  }

  export type ApprovalTemplateUncheckedUpdateWithoutApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: ApprovalStepUncheckedUpdateManyWithoutApprovalTemplateNestedInput
  }

  export type LeaveUpsertWithoutApprovalInput = {
    update: XOR<LeaveUpdateWithoutApprovalInput, LeaveUncheckedUpdateWithoutApprovalInput>
    create: XOR<LeaveCreateWithoutApprovalInput, LeaveUncheckedCreateWithoutApprovalInput>
    where?: LeaveWhereInput
  }

  export type LeaveUpdateToOneWithWhereWithoutApprovalInput = {
    where?: LeaveWhereInput
    data: XOR<LeaveUpdateWithoutApprovalInput, LeaveUncheckedUpdateWithoutApprovalInput>
  }

  export type LeaveUpdateWithoutApprovalInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    halfDay?: BoolFieldUpdateOperationsInput | boolean
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutLeavesNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLeavesNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutLeavesNestedInput
  }

  export type LeaveUncheckedUpdateWithoutApprovalInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    halfDay?: BoolFieldUpdateOperationsInput | boolean
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeUpsertWithoutApprovalInput = {
    update: XOR<OvertimeUpdateWithoutApprovalInput, OvertimeUncheckedUpdateWithoutApprovalInput>
    create: XOR<OvertimeCreateWithoutApprovalInput, OvertimeUncheckedCreateWithoutApprovalInput>
    where?: OvertimeWhereInput
  }

  export type OvertimeUpdateToOneWithWhereWithoutApprovalInput = {
    where?: OvertimeWhereInput
    data: XOR<OvertimeUpdateWithoutApprovalInput, OvertimeUncheckedUpdateWithoutApprovalInput>
  }

  export type OvertimeUpdateWithoutApprovalInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutOvertimesNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutOvertimesNestedInput
    overtimePolicy?: OvertimePolicyUpdateOneRequiredWithoutOvertimesNestedInput
  }

  export type OvertimeUncheckedUpdateWithoutApprovalInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalActionUpsertWithWhereUniqueWithoutApprovalInput = {
    where: ApprovalActionWhereUniqueInput
    update: XOR<ApprovalActionUpdateWithoutApprovalInput, ApprovalActionUncheckedUpdateWithoutApprovalInput>
    create: XOR<ApprovalActionCreateWithoutApprovalInput, ApprovalActionUncheckedCreateWithoutApprovalInput>
  }

  export type ApprovalActionUpdateWithWhereUniqueWithoutApprovalInput = {
    where: ApprovalActionWhereUniqueInput
    data: XOR<ApprovalActionUpdateWithoutApprovalInput, ApprovalActionUncheckedUpdateWithoutApprovalInput>
  }

  export type ApprovalActionUpdateManyWithWhereWithoutApprovalInput = {
    where: ApprovalActionScalarWhereInput
    data: XOR<ApprovalActionUpdateManyMutationInput, ApprovalActionUncheckedUpdateManyWithoutApprovalInput>
  }

  export type ApprovalCreateWithoutActionsInput = {
    id?: string
    entityType: string
    entityId: string
    requesterId: string
    currentStep?: number
    status?: $Enums.ApprovalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutApprovalsInput
    template: ApprovalTemplateCreateNestedOneWithoutApprovalsInput
    leave?: LeaveCreateNestedOneWithoutApprovalInput
    overtime?: OvertimeCreateNestedOneWithoutApprovalInput
  }

  export type ApprovalUncheckedCreateWithoutActionsInput = {
    id?: string
    workspaceId: string
    templateId: string
    entityType: string
    entityId: string
    requesterId: string
    currentStep?: number
    status?: $Enums.ApprovalStatus
    leaveId?: string | null
    overtimeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalCreateOrConnectWithoutActionsInput = {
    where: ApprovalWhereUniqueInput
    create: XOR<ApprovalCreateWithoutActionsInput, ApprovalUncheckedCreateWithoutActionsInput>
  }

  export type UserCreateWithoutApprovalActionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    workspaceMember?: WorkspaceMemberCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApprovalActionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    workspaceMember?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApprovalActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApprovalActionsInput, UserUncheckedCreateWithoutApprovalActionsInput>
  }

  export type ApprovalUpsertWithoutActionsInput = {
    update: XOR<ApprovalUpdateWithoutActionsInput, ApprovalUncheckedUpdateWithoutActionsInput>
    create: XOR<ApprovalCreateWithoutActionsInput, ApprovalUncheckedCreateWithoutActionsInput>
    where?: ApprovalWhereInput
  }

  export type ApprovalUpdateToOneWithWhereWithoutActionsInput = {
    where?: ApprovalWhereInput
    data: XOR<ApprovalUpdateWithoutActionsInput, ApprovalUncheckedUpdateWithoutActionsInput>
  }

  export type ApprovalUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutApprovalsNestedInput
    template?: ApprovalTemplateUpdateOneRequiredWithoutApprovalsNestedInput
    leave?: LeaveUpdateOneWithoutApprovalNestedInput
    overtime?: OvertimeUpdateOneWithoutApprovalNestedInput
  }

  export type ApprovalUncheckedUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    leaveId?: NullableStringFieldUpdateOperationsInput | string | null
    overtimeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutApprovalActionsInput = {
    update: XOR<UserUpdateWithoutApprovalActionsInput, UserUncheckedUpdateWithoutApprovalActionsInput>
    create: XOR<UserCreateWithoutApprovalActionsInput, UserUncheckedCreateWithoutApprovalActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApprovalActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApprovalActionsInput, UserUncheckedUpdateWithoutApprovalActionsInput>
  }

  export type UserUpdateWithoutApprovalActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    workspaceMember?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApprovalActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    workspaceMember?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceCreateWithoutSettingsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutSettingsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutSettingsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutSettingsInput, WorkspaceUncheckedCreateWithoutSettingsInput>
  }

  export type WorkspaceUpsertWithoutSettingsInput = {
    update: XOR<WorkspaceUpdateWithoutSettingsInput, WorkspaceUncheckedUpdateWithoutSettingsInput>
    create: XOR<WorkspaceCreateWithoutSettingsInput, WorkspaceUncheckedCreateWithoutSettingsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutSettingsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutSettingsInput, WorkspaceUncheckedUpdateWithoutSettingsInput>
  }

  export type WorkspaceUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserCreateWithoutConsentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    workspaceMember?: WorkspaceMemberCreateNestedManyWithoutUserInput
    approvalActions?: ApprovalActionCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConsentsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    workspaceMember?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    approvalActions?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConsentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
  }

  export type UserUpsertWithoutConsentsInput = {
    update: XOR<UserUpdateWithoutConsentsInput, UserUncheckedUpdateWithoutConsentsInput>
    create: XOR<UserCreateWithoutConsentsInput, UserUncheckedCreateWithoutConsentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConsentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConsentsInput, UserUncheckedUpdateWithoutConsentsInput>
  }

  export type UserUpdateWithoutConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    workspaceMember?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    approvalActions?: ApprovalActionUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConsentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    workspaceMember?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    approvalActions?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutActivityLogsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    workspaceMember?: WorkspaceMemberCreateNestedManyWithoutUserInput
    approvalActions?: ApprovalActionCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivityLogsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    workspaceMember?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    approvalActions?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserUpsertWithoutActivityLogsInput = {
    update: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    workspaceMember?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    approvalActions?: ApprovalActionUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    workspaceMember?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    approvalActions?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    invitations?: InvitationUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutAuditLogsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutAuditLogsInput, WorkspaceUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    employee?: EmployeeCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    workspaceMember?: WorkspaceMemberCreateNestedManyWithoutUserInput
    approvalActions?: ApprovalActionCreateNestedManyWithoutUserInput
    consents?: UserConsentCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    password?: string | null
    image?: string | null
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    workspaceMember?: WorkspaceMemberUncheckedCreateNestedManyWithoutUserInput
    approvalActions?: ApprovalActionUncheckedCreateNestedManyWithoutUserInput
    consents?: UserConsentUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type WorkspaceUpsertWithoutAuditLogsInput = {
    update: XOR<WorkspaceUpdateWithoutAuditLogsInput, WorkspaceUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<WorkspaceCreateWithoutAuditLogsInput, WorkspaceUncheckedCreateWithoutAuditLogsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutAuditLogsInput, WorkspaceUncheckedUpdateWithoutAuditLogsInput>
  }

  export type WorkspaceUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    invitations?: InvitationUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    employee?: EmployeeUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    workspaceMember?: WorkspaceMemberUpdateManyWithoutUserNestedInput
    approvalActions?: ApprovalActionUpdateManyWithoutUserNestedInput
    consents?: UserConsentUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    workspaceMember?: WorkspaceMemberUncheckedUpdateManyWithoutUserNestedInput
    approvalActions?: ApprovalActionUncheckedUpdateManyWithoutUserNestedInput
    consents?: UserConsentUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceCreateWithoutInvitationsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentCreateNestedManyWithoutWorkspaceInput
    teams?: TeamCreateNestedManyWithoutWorkspaceInput
    positions?: PositionCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutInvitationsInput = {
    id?: string
    name: string
    slug: string
    logo?: string | null
    address?: string | null
    taxId?: string | null
    phone?: string | null
    email?: string | null
    contactPerson?: string | null
    status?: $Enums.WorkspaceStatus
    planType?: $Enums.PlanType
    subscriptionStart?: Date | string | null
    subscriptionEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: WorkspaceMemberUncheckedCreateNestedManyWithoutWorkspaceInput
    departments?: DepartmentUncheckedCreateNestedManyWithoutWorkspaceInput
    teams?: TeamUncheckedCreateNestedManyWithoutWorkspaceInput
    positions?: PositionUncheckedCreateNestedManyWithoutWorkspaceInput
    positionLevels?: PositionLevelUncheckedCreateNestedManyWithoutWorkspaceInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutWorkspaceInput
    projects?: ProjectUncheckedCreateNestedManyWithoutWorkspaceInput
    projectRoles?: ProjectRoleUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveTypes?: LeaveTypeUncheckedCreateNestedManyWithoutWorkspaceInput
    leaveQuotas?: LeaveQuotaUncheckedCreateNestedManyWithoutWorkspaceInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimePolicies?: OvertimePolicyUncheckedCreateNestedManyWithoutWorkspaceInput
    overtimes?: OvertimeUncheckedCreateNestedManyWithoutWorkspaceInput
    approvalTemplates?: ApprovalTemplateUncheckedCreateNestedManyWithoutWorkspaceInput
    approvals?: ApprovalUncheckedCreateNestedManyWithoutWorkspaceInput
    settings?: SettingsUncheckedCreateNestedManyWithoutWorkspaceInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutInvitationsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
  }

  export type WorkspaceUpsertWithoutInvitationsInput = {
    update: XOR<WorkspaceUpdateWithoutInvitationsInput, WorkspaceUncheckedUpdateWithoutInvitationsInput>
    create: XOR<WorkspaceCreateWithoutInvitationsInput, WorkspaceUncheckedCreateWithoutInvitationsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutInvitationsInput, WorkspaceUncheckedUpdateWithoutInvitationsInput>
  }

  export type WorkspaceUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactPerson?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumWorkspaceStatusFieldUpdateOperationsInput | $Enums.WorkspaceStatus
    planType?: EnumPlanTypeFieldUpdateOperationsInput | $Enums.PlanType
    subscriptionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceNestedInput
    departments?: DepartmentUncheckedUpdateManyWithoutWorkspaceNestedInput
    teams?: TeamUncheckedUpdateManyWithoutWorkspaceNestedInput
    positions?: PositionUncheckedUpdateManyWithoutWorkspaceNestedInput
    positionLevels?: PositionLevelUncheckedUpdateManyWithoutWorkspaceNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutWorkspaceNestedInput
    projects?: ProjectUncheckedUpdateManyWithoutWorkspaceNestedInput
    projectRoles?: ProjectRoleUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveTypes?: LeaveTypeUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutWorkspaceNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimePolicies?: OvertimePolicyUncheckedUpdateManyWithoutWorkspaceNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvalTemplates?: ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutWorkspaceNestedInput
    settings?: SettingsUncheckedUpdateManyWithoutWorkspaceNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type ActivityLogCreateManyUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    details?: string | null
    createdAt?: Date | string
  }

  export type WorkspaceMemberCreateManyUserInput = {
    id?: string
    workspaceId: string
    role: $Enums.MemberRole
    joinedAt?: Date | string
    invitedBy?: string | null
    status?: $Enums.MemberStatus
  }

  export type ApprovalActionCreateManyUserInput = {
    id?: string
    approvalId: string
    step: number
    action: string
    comment?: string | null
    createdAt?: Date | string
  }

  export type UserConsentCreateManyUserInput = {
    id?: string
    purpose: string
    consentGiven: boolean
    timestamp: Date | string
    ipAddress?: string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    workspaceId: string
    action: string
    resource: string
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    workspace?: WorkspaceUpdateOneRequiredWithoutMembersNestedInput
  }

  export type WorkspaceMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
  }

  export type WorkspaceMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
  }

  export type ApprovalActionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approval?: ApprovalUpdateOneRequiredWithoutActionsNestedInput
  }

  export type ApprovalActionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    approvalId?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalActionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    approvalId?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserConsentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    consentGiven?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserConsentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    consentGiven?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserConsentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    consentGiven?: BoolFieldUpdateOperationsInput | boolean
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceMemberCreateManyWorkspaceInput = {
    id?: string
    userId: string
    role: $Enums.MemberRole
    joinedAt?: Date | string
    invitedBy?: string | null
    status?: $Enums.MemberStatus
  }

  export type DepartmentCreateManyWorkspaceInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    managerId?: string | null
    parentId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamCreateManyWorkspaceInput = {
    id?: string
    departmentId: string
    name: string
    description?: string | null
    leaderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionCreateManyWorkspaceInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PositionLevelCreateManyWorkspaceInput = {
    id?: string
    name: string
    level: number
    description?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeCreateManyWorkspaceInput = {
    id?: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateManyWorkspaceInput = {
    id?: string
    name: string
    code?: string | null
    description?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    budget?: Decimal | DecimalJsLike | number | string | null
    status?: $Enums.ProjectStatus
    priority?: $Enums.ProjectPriority
    managerId?: string | null
    clientName?: string | null
    clientContact?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectRoleCreateManyWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveTypeCreateManyWorkspaceInput = {
    id?: string
    name: string
    code: string
    description?: string | null
    color?: string | null
    isPaid?: boolean
    requiresApproval?: boolean
    requiresAttachment?: boolean
    maxDaysPerYear?: number | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveQuotaCreateManyWorkspaceInput = {
    id?: string
    employeeId: string
    leaveTypeId: string
    year: number
    total: number
    used?: number
    pending?: number
    remaining: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveCreateManyWorkspaceInput = {
    id?: string
    employeeId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    halfDay?: boolean
    duration: number
    reason?: string | null
    attachment?: string | null
    status?: $Enums.LeaveStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimePolicyCreateManyWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    rate: number
    minimumHours?: number
    maximumHours?: number | null
    requiresApproval?: boolean
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeCreateManyWorkspaceInput = {
    id?: string
    employeeId: string
    policyId: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    hours: number
    reason: string
    status?: $Enums.OvertimeStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalTemplateCreateManyWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    entityType: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalCreateManyWorkspaceInput = {
    id?: string
    templateId: string
    entityType: string
    entityId: string
    requesterId: string
    currentStep?: number
    status?: $Enums.ApprovalStatus
    leaveId?: string | null
    overtimeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingsCreateManyWorkspaceInput = {
    id?: string
    category: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyWorkspaceInput = {
    id?: string
    userId: string
    action: string
    resource: string
    resourceId?: string | null
    details?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type InvitationCreateManyWorkspaceInput = {
    id?: string
    email: string
    code: string
    type: $Enums.InvitationType
    status?: $Enums.InvitationStatus
    data?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceMemberUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    user?: UserUpdateOneRequiredWithoutWorkspaceMemberNestedInput
  }

  export type WorkspaceMemberUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
  }

  export type WorkspaceMemberUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
  }

  export type DepartmentUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUpdateManyWithoutDepartmentNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
    parent?: DepartmentUpdateOneWithoutChildrenNestedInput
    children?: DepartmentUpdateManyWithoutParentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutDepartmentNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
    children?: DepartmentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    department?: DepartmentUpdateOneRequiredWithoutTeamsNestedInput
    employees?: EmployeeUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutPositionNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutPositionNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type PositionUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PositionLevelUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutPositionLevelNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutPositionLevelNestedInput
  }

  export type PositionLevelUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutPositionLevelNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutPositionLevelNestedInput
  }

  export type PositionLevelUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeeNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    positionLevel?: PositionLevelUpdateOneWithoutEmployeesNestedInput
    manager?: EmployeeUpdateOneWithoutSubordinatesNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumProjectPriorityFieldUpdateOperationsInput | $Enums.ProjectPriority
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    clientContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumProjectPriorityFieldUpdateOperationsInput | $Enums.ProjectPriority
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    clientContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: ProjectMemberUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    budget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    priority?: EnumProjectPriorityFieldUpdateOperationsInput | $Enums.ProjectPriority
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    clientName?: NullableStringFieldUpdateOperationsInput | string | null
    clientContact?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectRoleUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMembers?: ProjectMemberUpdateManyWithoutProjectRoleNestedInput
  }

  export type ProjectRoleUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutProjectRoleNestedInput
  }

  export type ProjectRoleUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveTypeUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    requiresAttachment?: BoolFieldUpdateOperationsInput | boolean
    maxDaysPerYear?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveQuotas?: LeaveQuotaUpdateManyWithoutLeaveTypeNestedInput
    leaves?: LeaveUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    requiresAttachment?: BoolFieldUpdateOperationsInput | boolean
    maxDaysPerYear?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutLeaveTypeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutLeaveTypeNestedInput
  }

  export type LeaveTypeUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    requiresAttachment?: BoolFieldUpdateOperationsInput | boolean
    maxDaysPerYear?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveQuotaUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutLeaveQuotasNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutLeaveQuotasNestedInput
  }

  export type LeaveQuotaUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveQuotaUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    halfDay?: BoolFieldUpdateOperationsInput | boolean
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutLeavesNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutLeavesNestedInput
    approval?: ApprovalUpdateOneWithoutLeaveNestedInput
  }

  export type LeaveUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    halfDay?: BoolFieldUpdateOperationsInput | boolean
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approval?: ApprovalUncheckedUpdateOneWithoutLeaveNestedInput
  }

  export type LeaveUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    halfDay?: BoolFieldUpdateOperationsInput | boolean
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimePolicyUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    minimumHours?: FloatFieldUpdateOperationsInput | number
    maximumHours?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overtimes?: OvertimeUpdateManyWithoutOvertimePolicyNestedInput
  }

  export type OvertimePolicyUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    minimumHours?: FloatFieldUpdateOperationsInput | number
    maximumHours?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overtimes?: OvertimeUncheckedUpdateManyWithoutOvertimePolicyNestedInput
  }

  export type OvertimePolicyUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    rate?: FloatFieldUpdateOperationsInput | number
    minimumHours?: FloatFieldUpdateOperationsInput | number
    maximumHours?: NullableFloatFieldUpdateOperationsInput | number | null
    requiresApproval?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutOvertimesNestedInput
    overtimePolicy?: OvertimePolicyUpdateOneRequiredWithoutOvertimesNestedInput
    approval?: ApprovalUpdateOneWithoutOvertimeNestedInput
  }

  export type OvertimeUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approval?: ApprovalUncheckedUpdateOneWithoutOvertimeNestedInput
  }

  export type OvertimeUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalTemplateUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: ApprovalStepUpdateManyWithoutApprovalTemplateNestedInput
    approvals?: ApprovalUpdateManyWithoutTemplateNestedInput
  }

  export type ApprovalTemplateUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    steps?: ApprovalStepUncheckedUpdateManyWithoutApprovalTemplateNestedInput
    approvals?: ApprovalUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type ApprovalTemplateUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: ApprovalTemplateUpdateOneRequiredWithoutApprovalsNestedInput
    leave?: LeaveUpdateOneWithoutApprovalNestedInput
    overtime?: OvertimeUpdateOneWithoutApprovalNestedInput
    actions?: ApprovalActionUpdateManyWithoutApprovalNestedInput
  }

  export type ApprovalUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    leaveId?: NullableStringFieldUpdateOperationsInput | string | null
    overtimeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: ApprovalActionUncheckedUpdateManyWithoutApprovalNestedInput
  }

  export type ApprovalUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    leaveId?: NullableStringFieldUpdateOperationsInput | string | null
    overtimeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingsUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    resourceId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumInvitationTypeFieldUpdateOperationsInput | $Enums.InvitationType
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    data?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumInvitationTypeFieldUpdateOperationsInput | $Enums.InvitationType
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    data?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumInvitationTypeFieldUpdateOperationsInput | $Enums.InvitationType
    status?: EnumInvitationStatusFieldUpdateOperationsInput | $Enums.InvitationStatus
    data?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateManyDepartmentInput = {
    id?: string
    workspaceId: string
    name: string
    description?: string | null
    leaderId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeCreateManyDepartmentInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    teamId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentCreateManyParentInput = {
    id?: string
    workspaceId: string
    name: string
    code?: string | null
    description?: string | null
    managerId?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutTeamsNestedInput
    employees?: EmployeeUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    leaderId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeeNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    positionLevel?: PositionLevelUpdateOneWithoutEmployeesNestedInput
    manager?: EmployeeUpdateOneWithoutSubordinatesNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutDepartmentsNestedInput
    teams?: TeamUpdateManyWithoutDepartmentNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
    children?: DepartmentUpdateManyWithoutParentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutDepartmentNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
    children?: DepartmentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyTeamInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeeNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    positionLevel?: PositionLevelUpdateOneWithoutEmployeesNestedInput
    manager?: EmployeeUpdateOneWithoutSubordinatesNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyPositionInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionLevelId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmploymentHistoryCreateManyPositionInput = {
    id?: string
    employeeId: string
    positionLevelId?: string | null
    departmentId?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeeNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    positionLevel?: PositionLevelUpdateOneWithoutEmployeesNestedInput
    manager?: EmployeeUpdateOneWithoutSubordinatesNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentHistoryUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutEmploymentHistoryNestedInput
    positionLevel?: PositionLevelUpdateOneWithoutEmploymentHistoryNestedInput
  }

  export type EmploymentHistoryUncheckedUpdateWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentHistoryUncheckedUpdateManyWithoutPositionInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyPositionLevelInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionId?: string | null
    managerId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmploymentHistoryCreateManyPositionLevelInput = {
    id?: string
    employeeId: string
    positionId: string
    departmentId?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutPositionLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeeNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    manager?: EmployeeUpdateOneWithoutSubordinatesNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPositionLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutPositionLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentHistoryUpdateWithoutPositionLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutEmploymentHistoryNestedInput
    position?: PositionUpdateOneRequiredWithoutEmploymentHistoryNestedInput
  }

  export type EmploymentHistoryUncheckedUpdateWithoutPositionLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentHistoryUncheckedUpdateManyWithoutPositionLevelInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyManagerInput = {
    id?: string
    workspaceId: string
    userId?: string | null
    employeeCode?: string | null
    firstName: string
    lastName: string
    thaiFirstName?: string | null
    thaiLastName?: string | null
    nickname?: string | null
    email: string
    phone?: string | null
    emergencyContact?: string | null
    birthdate?: Date | string | null
    gender?: string | null
    nationalId?: string | null
    nationalIdIv?: string | null
    passportNumber?: string | null
    passportNumberIv?: string | null
    address?: string | null
    taxId?: string | null
    bankAccount?: string | null
    bankAccountIv?: string | null
    bankName?: string | null
    hireDate: Date | string
    probationEndDate?: Date | string | null
    resignDate?: Date | string | null
    departmentId?: string | null
    teamId?: string | null
    positionId?: string | null
    positionLevelId?: string | null
    status?: $Enums.EmployeeStatus
    employmentType?: $Enums.EmploymentType
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMemberCreateManyEmployeeInput = {
    id?: string
    projectId: string
    roleId: string
    allocation?: number
    startDate?: Date | string
    endDate?: Date | string | null
  }

  export type EmploymentHistoryCreateManyEmployeeInput = {
    id?: string
    positionId: string
    positionLevelId?: string | null
    departmentId?: string | null
    startDate: Date | string
    endDate?: Date | string | null
    salary?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeDocumentCreateManyEmployeeInput = {
    id?: string
    type: string
    name: string
    filename: string
    mimeType: string
    size: number
    url: string
    uploadedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveQuotaCreateManyEmployeeInput = {
    id?: string
    workspaceId: string
    leaveTypeId: string
    year: number
    total: number
    used?: number
    pending?: number
    remaining: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveCreateManyEmployeeInput = {
    id?: string
    workspaceId: string
    leaveTypeId: string
    startDate: Date | string
    endDate: Date | string
    halfDay?: boolean
    duration: number
    reason?: string | null
    attachment?: string | null
    status?: $Enums.LeaveStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeCreateManyEmployeeInput = {
    id?: string
    workspaceId: string
    policyId: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    hours: number
    reason: string
    status?: $Enums.OvertimeStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutEmployeeNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutEmployeesNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    team?: TeamUpdateOneWithoutEmployeesNestedInput
    position?: PositionUpdateOneWithoutEmployeesNestedInput
    positionLevel?: PositionLevelUpdateOneWithoutEmployeesNestedInput
    subordinates?: EmployeeUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subordinates?: EmployeeUncheckedUpdateManyWithoutManagerNestedInput
    projectMembers?: ProjectMemberUncheckedUpdateManyWithoutEmployeeNestedInput
    employmentHistory?: EmploymentHistoryUncheckedUpdateManyWithoutEmployeeNestedInput
    documents?: EmployeeDocumentUncheckedUpdateManyWithoutEmployeeNestedInput
    leaveQuotas?: LeaveQuotaUncheckedUpdateManyWithoutEmployeeNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutEmployeeNestedInput
    overtimes?: OvertimeUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutManagerInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeCode?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    thaiFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    thaiLastName?: NullableStringFieldUpdateOperationsInput | string | null
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    emergencyContact?: NullableStringFieldUpdateOperationsInput | string | null
    birthdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    nationalId?: NullableStringFieldUpdateOperationsInput | string | null
    nationalIdIv?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumber?: NullableStringFieldUpdateOperationsInput | string | null
    passportNumberIv?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    bankAccountIv?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    hireDate?: DateTimeFieldUpdateOperationsInput | Date | string
    probationEndDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    resignDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEmployeeStatusFieldUpdateOperationsInput | $Enums.EmployeeStatus
    employmentType?: EnumEmploymentTypeFieldUpdateOperationsInput | $Enums.EmploymentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocation?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    projectRole?: ProjectRoleUpdateOneRequiredWithoutProjectMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    allocation?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectMemberUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    allocation?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmploymentHistoryUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    position?: PositionUpdateOneRequiredWithoutEmploymentHistoryNestedInput
    positionLevel?: PositionLevelUpdateOneWithoutEmploymentHistoryNestedInput
  }

  export type EmploymentHistoryUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmploymentHistoryUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    positionId?: StringFieldUpdateOperationsInput | string
    positionLevelId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    salary?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeDocumentUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeDocumentUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeDocumentUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveQuotaUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutLeaveQuotasNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutLeaveQuotasNestedInput
  }

  export type LeaveQuotaUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveQuotaUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    halfDay?: BoolFieldUpdateOperationsInput | boolean
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutLeavesNestedInput
    leaveType?: LeaveTypeUpdateOneRequiredWithoutLeavesNestedInput
    approval?: ApprovalUpdateOneWithoutLeaveNestedInput
  }

  export type LeaveUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    halfDay?: BoolFieldUpdateOperationsInput | boolean
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approval?: ApprovalUncheckedUpdateOneWithoutLeaveNestedInput
  }

  export type LeaveUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    leaveTypeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    halfDay?: BoolFieldUpdateOperationsInput | boolean
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutOvertimesNestedInput
    overtimePolicy?: OvertimePolicyUpdateOneRequiredWithoutOvertimesNestedInput
    approval?: ApprovalUpdateOneWithoutOvertimeNestedInput
  }

  export type OvertimeUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approval?: ApprovalUncheckedUpdateOneWithoutOvertimeNestedInput
  }

  export type OvertimeUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    policyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMemberCreateManyProjectInput = {
    id?: string
    employeeId: string
    roleId: string
    allocation?: number
    startDate?: Date | string
    endDate?: Date | string | null
  }

  export type ProjectMemberUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocation?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    employee?: EmployeeUpdateOneRequiredWithoutProjectMembersNestedInput
    projectRole?: ProjectRoleUpdateOneRequiredWithoutProjectMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    allocation?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    roleId?: StringFieldUpdateOperationsInput | string
    allocation?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectMemberCreateManyProjectRoleInput = {
    id?: string
    projectId: string
    employeeId: string
    allocation?: number
    startDate?: Date | string
    endDate?: Date | string | null
  }

  export type ProjectMemberUpdateWithoutProjectRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    allocation?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    project?: ProjectUpdateOneRequiredWithoutMembersNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutProjectMembersNestedInput
  }

  export type ProjectMemberUncheckedUpdateWithoutProjectRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    allocation?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProjectMemberUncheckedUpdateManyWithoutProjectRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    allocation?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LeaveQuotaCreateManyLeaveTypeInput = {
    id?: string
    workspaceId: string
    employeeId: string
    year: number
    total: number
    used?: number
    pending?: number
    remaining: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveCreateManyLeaveTypeInput = {
    id?: string
    workspaceId: string
    employeeId: string
    startDate: Date | string
    endDate: Date | string
    halfDay?: boolean
    duration: number
    reason?: string | null
    attachment?: string | null
    status?: $Enums.LeaveStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveQuotaUpdateWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutLeaveQuotasNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLeaveQuotasNestedInput
  }

  export type LeaveQuotaUncheckedUpdateWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveQuotaUncheckedUpdateManyWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    used?: FloatFieldUpdateOperationsInput | number
    pending?: FloatFieldUpdateOperationsInput | number
    remaining?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUpdateWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    halfDay?: BoolFieldUpdateOperationsInput | boolean
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutLeavesNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutLeavesNestedInput
    approval?: ApprovalUpdateOneWithoutLeaveNestedInput
  }

  export type LeaveUncheckedUpdateWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    halfDay?: BoolFieldUpdateOperationsInput | boolean
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approval?: ApprovalUncheckedUpdateOneWithoutLeaveNestedInput
  }

  export type LeaveUncheckedUpdateManyWithoutLeaveTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    halfDay?: BoolFieldUpdateOperationsInput | boolean
    duration?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLeaveStatusFieldUpdateOperationsInput | $Enums.LeaveStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OvertimeCreateManyOvertimePolicyInput = {
    id?: string
    workspaceId: string
    employeeId: string
    date: Date | string
    startTime: Date | string
    endTime: Date | string
    hours: number
    reason: string
    status?: $Enums.OvertimeStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OvertimeUpdateWithoutOvertimePolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutOvertimesNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutOvertimesNestedInput
    approval?: ApprovalUpdateOneWithoutOvertimeNestedInput
  }

  export type OvertimeUncheckedUpdateWithoutOvertimePolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approval?: ApprovalUncheckedUpdateOneWithoutOvertimeNestedInput
  }

  export type OvertimeUncheckedUpdateManyWithoutOvertimePolicyInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    hours?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: EnumOvertimeStatusFieldUpdateOperationsInput | $Enums.OvertimeStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalStepCreateManyApprovalTemplateInput = {
    id?: string
    stepNumber: number
    approverType: $Enums.ApproverType
    approverId?: string | null
    backup1Id?: string | null
    backup2Id?: string | null
    timeLimit?: number | null
  }

  export type ApprovalCreateManyTemplateInput = {
    id?: string
    workspaceId: string
    entityType: string
    entityId: string
    requesterId: string
    currentStep?: number
    status?: $Enums.ApprovalStatus
    leaveId?: string | null
    overtimeId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApprovalStepUpdateWithoutApprovalTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    backup1Id?: NullableStringFieldUpdateOperationsInput | string | null
    backup2Id?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ApprovalStepUncheckedUpdateWithoutApprovalTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    backup1Id?: NullableStringFieldUpdateOperationsInput | string | null
    backup2Id?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ApprovalStepUncheckedUpdateManyWithoutApprovalTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    approverType?: EnumApproverTypeFieldUpdateOperationsInput | $Enums.ApproverType
    approverId?: NullableStringFieldUpdateOperationsInput | string | null
    backup1Id?: NullableStringFieldUpdateOperationsInput | string | null
    backup2Id?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ApprovalUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutApprovalsNestedInput
    leave?: LeaveUpdateOneWithoutApprovalNestedInput
    overtime?: OvertimeUpdateOneWithoutApprovalNestedInput
    actions?: ApprovalActionUpdateManyWithoutApprovalNestedInput
  }

  export type ApprovalUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    leaveId?: NullableStringFieldUpdateOperationsInput | string | null
    overtimeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: ApprovalActionUncheckedUpdateManyWithoutApprovalNestedInput
  }

  export type ApprovalUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    currentStep?: IntFieldUpdateOperationsInput | number
    status?: EnumApprovalStatusFieldUpdateOperationsInput | $Enums.ApprovalStatus
    leaveId?: NullableStringFieldUpdateOperationsInput | string | null
    overtimeId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalActionCreateManyApprovalInput = {
    id?: string
    userId: string
    step: number
    action: string
    comment?: string | null
    createdAt?: Date | string
  }

  export type ApprovalActionUpdateWithoutApprovalInput = {
    id?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApprovalActionsNestedInput
  }

  export type ApprovalActionUncheckedUpdateWithoutApprovalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApprovalActionUncheckedUpdateManyWithoutApprovalInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    step?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}